#!/usr/bin/env bash

# ***** WELCOME! Scroll further down to set the user settings. *****

#myth2kodi is a modified version of mythicalLibrarian by Adam Outler
#
# mythicalLibrarian Author: Adam Outler
# email: adamoutler gmail.com
# mythicalLibrarian Originally Written: 2009ish
# https://github.com/adamoutler/mythicallibrarian
#
# myth2kodi Author: Stuart A. Knock
# myth2kodi Originally Written: 2015-2016ish
# https://github.com/stuart-knock/myth2kodi
#
#Software the way it should be: Free and Open Source
#
#mythicalLibrarian Tech Support: http://forum.kodi.tv/showthread.php?pid=470402
#

#Intention:
#  This program automates the mapping of MythTV recordings to a Kodi library.
#  It is designed to be a user job in MythTV. It can also be run manually from
#  a command line. It must have access to your MythTV recordings. The program
#  generates file names compatible with Kodi, then moves or links recordings
#  based on user settings. Comskip and NFO files are also generated from your
#  MythTV database, as required, so that Kodi can make use of them.
#
#Installation:
#  The myth2kodi file should be placed in the users path, see the binpath
#  variable in user settings (Default: /usr/local/bin). Some of the
#  functionality of this script is provided in other files, these will also
#  need to be placed in $binpath along with this script. They are:
#  mythdb_access -- Uses MythTV python bindings to access database information.
#  m2k_notify -- A script for sending notifications to Gnome Desktop.
#  bashlogging -- A set of bash functions that provide the logging mechanism
#                 used throughout myth2kodi.
#
#Usage:
#  To function on your system, some of the variables specified in the
#  USER SETTINGS section below may need to be modified from their defaults.
#  For example, to avoid permission issues, myth2kodi should be run as the
#  same user running MythTV (see USER SETTING, Librarian), or at the very
#  least a user permitted to read and write the recording files generated
#  by MythTV.
#  The MythTV user job should be called as follows:
#    $binpath/myth2kodi "%DIR%/%FILE%"
#  where "$binpath" is replaced by the full explicit path from USER SETTINGS.
#  At the command line, the script can be called with the following form:
#    myth2kodi "Input File" "show name" "episode name"
#  for example:
#    myth2kodi "/home/myth/recordings/2308320472023429837.mpg" "South Park" "Here Comes the Neighborhood"
#  for additional functionality type:
#    myth2kodi --help
#
#Output-target:
#  If an error occurs and the file cannot be moved, then no change will occur to
#  the original file. If the MoveDir is full or not available, such as when
#  running a NAS and the computer is disconnected from the network, the
#  AlternateMoveDir will be used. If both of these dirs fail, the show will be
#  SymLinked in the FailSafeDir. You may elect to run the user job at a later
#  time when the issue has been resolved. Output dir and link type will depend
#  on user settings. The file name is preset to the most acceptable standard:
#    Show Title - SxxExx (Episode Title).ext
#
#Symlinking:
#  When Symlinking is enabled, myth2kodi will follow its normal mode of
#  operation. In MOVE mode, myth2kodi will create a symlink from the new
#  file in the same name and location of the old file. In LINK mode,
#  myth2kodi will not move the file, LINK mode creates a new symlink to
#  the original file. Both approaches enable Kodi to access the recording
#  while still allowing MythTV to keep track of it. If 'SYMLINK'ing is set
#  to 'Disabled' then, when myth2kodi moves a recording, it will also
#  delete it from MythTV's database.
#
#Output-Files:
#  myth2kodi will create several files in it's working folder. This is a
#  list of the files and their functions:
#    +created.tracking keeps track of created comskip.txt and NFO files so they
#      can be deleted in the future if their video file is deleted.
#    +doover.sh is designed to keep track of failed jobs. It is designed to be
#      executable. #Commented commands are those which are determined to be
#      questionable. This file can be made executable and run after a problem is
#      corrected which caused the problem. Questionable commands are those which
#      will require you to add an episode title and set the myth2kodi
#      Database=Disabled setting. Questionable files do not have sufficient
#      guide data.
#    +markupstart.txt and markupstop.txt are files which contain information
#      from the last comskip generation. Deletion will cause no adverse effects.
#    +myth2kodi.log keeps track of operations and can be used to determine problems.
#    +shn.txt, sid.txt, and working.xml are used each time to determine the name
#      and show id of the last show identified.
#    +DailyReport directory is used to log the files which were moved that day.
#      It can be used as a "program guide" of sorts to keep track of what has
#      been added to your library.
#
#Logging:
#  Log files can be generated to show information for troubleshooting. You can
#  find the log file in myth2kodi's working folder (see USER SETTING, m2kdir).
#  For configuration options, see, the "Logging settings" section of
#  USER SETTINGS below. The default location of the main log file is:
#    /home/$Librarian/.myth2kodi/myth2kodi.log
#
#Database-external:
#  This program will make 3 calls to TheTVDB for every episode. The first one is
#  to obtain the series ID and verify the show name is correct. The second is to
#  check if the internally managed database is up-to-date. The third call will
#  only be made if the internal database is not up-to-date. The third call will
#  download a larger file which contains all information about the show which is
#  known on TheTVDB.
#
#Database-internal:
#  While myth2kodi maintains and requires it's own external file/folder
#  database in the working directory, there is also support for integration with
#  MythTV's internal database. MythTV Database is required for movies to be
#  recognized and handled by myth2kodi. Also, in the event that the
#  integrated fuzzy logic cannot make a determination of the correct show name,
#  myth2kodi will pull the original air date from the MythTV database
#  and attempt to make an exact match to TheTVDB.com supplied data. In addition,
#  the type of program is extracted from the mythtv database and a determination
#  is made weather or not there is sufficient information available to identify
#  the show based upon guide data. In order to make myth2kodi work to
#  it's full potential, all settings must be filled out correctly under the
#  database section of the user settings. Currently, the only guide data
#  supported is schedulesdirect through mythtv. When updating myth2kodi
#  it is best to delete all database folders to ensure proper data formatting.
#
#Dependencies:
#  "curl" -- downloads webpages and sends commands to Kodi;
#  "jq" -- parses json files, used for tvmaze data.
#  "agrep" -- provides fuzzy string matching;
#  "libnotify-bin" -- allows GNOME desktop notifications;
#  "mythbackend" -- Access the MythTV database.
#
#  These should all be available through the package manager for your Linux
#  distribution. For example:
#    "apt-get install curl"
#  or
#    "zypper install curl"
#
#  Logging in myth2kodi relies on a script called:
#    "bashlogging"
#  if you downloaded a release, then, this should be included in the tarball.
#  Otherwise it can be found at:
#    https://github.com/stuart-knock/bash-tools
#
#Gnome Notifications:
#  In order for myth2kodi to send notifications to the GNOME desktop, it
#  must have no-password sudo access. It uses this access strictly to send
#  complete, moving and failure status notifications. Because this program is
#  launched by the user $Librarian under normal circumstances, $Librarian must
#  temporarily become your user name in order to send a notification to your
#  desktop. This requires the use of a separate script, and for $Librarian to
#  have a sudoers group with no password option. Notifications are an optional
#  feature and will only work on the MythTV backend computer. The m2k_notify
#  script should be located in $binpath.
#
#KODI Notifications:
#   If enabled, myth2kodi will send a http requests to any specified KODI
#   servers to display library updates, to update the library and to clean out
#   the library. In order for this to work KODI you must ensure that the
#   setting in KODI under System->Network->Services->Allow control of KODI via
#   HTTP and Allow programs on other systems to control KODI are enabled.
#
#Show Name Translation:
#  The user may elect to create a file in the myth2kodi working folder which
#  will then translate any recorded show name into the desired show name.
#  This is useful for adding a year to distinguish between a new series and an
#  older series and/or typos in your guide data. By default it should be called
#  "showTranslations" and it will be in your $m2kdir folder. Correct show titles
#  can be determined by manually searching www.TheTVDB.com. The showTranslations
#  file is not needed by most SchedulesDirect users and the file should only be
#  created if it is needed. However, it is almost essential when using digital
#  free to air guide data, such as SydFTA (See USER SETTING, "GuideDataType").
#  An example file, "showTranslations.SydFTA", should be bundled with this script.
#  The format of showTranslations is (NB: no "#" or space at the start of a
#  line, only one space either side of "=", and no trailing space or any other
#  characters):
#    Filename: $m2kdir/showTranslations
#      My Guide Show Title = www.TheTVDB.com Show Title
#      Battlestar Gallactica = Battlestar Gallactica (2003)
#      The Office = The Office (US)
#      Millionaire = Who Wants To Be A Millionaire
#      Aqua teen Hungerforce = Aqua Teen Hunger Force
##############################################################################


##############################################################################
########################## BEGIN USER SETTINGS ###############################
##############################################################################

#Specify the name of the user running mythbackend, myth2kodi should always be
#run by that user. Default: 'mythtv'
Librarian='mythtv'                           #<------THIS VALUE MUST BE SET-------


############################ Processing settings #############################

#TODO: Should also add a 'COPY' mode... Useful for dumping recordings to a removable media. It would behave like 'MOVE' with
#      'SYMLINK'ing 'Disabled', but wouldn't delete the original file or remove the MythTV-DB entry. It should happily process
#      recordings that we've already processed, so, when implementing, will need to check abort on identification of
#      previously-run logic throughout the script.

# PROCESS_RECORDING_MODE has 2 modes. 'MOVE'(DEFAULT)|'LINK':
# 'MOVE' -- Move the recording. And, by default: create a symlink at InputPath;
# 'LINK' -- Do not move, just create a sym'LINK';
PROCESS_RECORDING_MODE='MOVE'

#A modifier switch, relevant for PROCESS_RECORDING_MODE='MOVE'. With this
#setting 'Enabled' a link is created from the original MythTV recording file
#location to the file just moved into your Kodi library. This enables MythTV
#to continue tracking and maintain control of the recording.
#Options: ['Enabled'(DEFAULT)|'Disabled']
#WARNING: 'Disabled' Mode removes MythTV-DB entry, SO CANNOT BE UNDONE.
SYMLINK='Enabled'

#If TargetPathIsInputPath is Enabled, original dir will override MoveDir. This
#is useful for multiple recording dirs. TargetPathIsInputPath will separate
#generic shows from episodes and movies. Options: ['Enabled'|'Disabled'(DEFAULT)]
TargetPathIsInputPath='Disabled'

#ShowStopper prevents generic shows and unrecognised episodes from being
#processed. Options: ['Enabled'(DEFAULT)|'Disabled']
ShowStopper='Enabled'

#TODO: Review. Consider renaming this.
#DirTracking will check for and remove the folders created by myth2kodi
#Options: ['Enabled'(DEFAULT)|'Disabled']
DirTracking='Enabled'

#FailSafe mode will enable symlinks to be formed in FailSafeDir if the move or
#symlink operation fails. Options: Enabled|Disabled
FailSafeMode='Disabled'

#StorageGroupFallback can enable/disable a bit of code that, if Guide Data
#identified the input file as a show or episode, but no episode or series
#information was found, then it checks if the MythTV-DB's storagegroup is
#movie[s] or film[s] and uses this to reset the recording type as Movie.
#To function it requires that you have created a MythTV storagegroup called
#something like 'Movies' and selected that storagegroup when making the rule
#for the recording. This works for my setup SAK.
#Options: ['Enabled'|'Disabled'(DEFAULT)]
StorageGroupFallback='Disabled'

#PlotMatchFallback can be used to enable/disable a bit of code that, if a
#SeriesID has been determined but no subtitle nor Season & Episode numbers
#have been identified, falls back to fuzzy matching the Plot field from the
#Guide data in MythTV-DB against the Plot data for the series, which we
#retrieved from TheTVDB and tvmaze.
#Options: ['Enabled'(DEFAULT)|'Disabled']
PlotMatchFallback='Enabled'

#CommercialMarkup will generate comskip files for recordings when they are moved.
#Options: ['Enabled'(DEFAULT)|'Disabled']
CommercialMarkup='Enabled'

#CommercialMarkupCleanup if 'Enabled', when m2k_maintenance() is run, removes
#comskip & NFO files if the associated .mpg file can't be found.
#Options: ['Enabled'(DEFAULT)|'Disabled']
CommercialMarkupCleanup='Enabled'

#Whether to track files and directories created by myth2kodi. This should always
#be 'Enabled' when performing ordinary processing to make MythTV recordings
#available to a Kodi library. It exists so we don't mess-up the tracking of
#myth2kodi's modifications to our Kodi library when we want to use myth2kodi
#with PROCESS_RECORDING_MODE='COPY' to put nicely named copies of our MythTV
#recordings on a removable media. See, 'example_copy_to_removable_media_myth2kodi.conf'.
#Options: ['Enabled'(DEFAULT)|'Disabled']
TRACKING='Enabled'


############################# Directory Settings #############################

#myth2kodi working directory: Default: "$HOME/.myth2kodi"
#NOTE: This is the one parameter that cannot be set in 'myth2kodi.conf' and
#      must be set in the script -- as it's used to find 'myth2kodi.conf'.
m2kdir="$HOME/.myth2kodi"

#The path which contains myth2kodi and associated scripts default=/usr/local/bin
#TODO: make this to just be used for essential sudo stuff, at the moment, I think, this is only Notify...
#      then require caller add the location they choose to be in there path... recommend a default of /home/$Librarian/bin, see other related TODOs...
binpath='/usr/local/bin'

#The directory where myth2kodi writes its temporary files, Default='/tmp'
#Typically, /tmp is tmpfs and so avoids unnecessary writes to disk. If you're
#on Linux and /tmp isn't tmpfs but you would rather avoid writing to disk then
#/dev/shm is guaranteed to be tmpfs. Alternatively, if you're short on RAM but
#don't mind some extra disk writes then use "$m2kdir". NOTE: When running with
#LOGLEVEL>=3, there are a number of temporary files that aren't automatically
#deleted, they will, however, be cleared as part of: myth2kodi --maintenance
M2K_TMPDIR='/tmp'

#MoveDir is the folder which myth2kodi will move the file. No trailing / is
#accepted eg. "$HOME/videos"
MoveDir='/media/video/tv'                    #<------THIS VALUE MUST BE SET-------

#AlternateMoveDir will act as a secondary MoveDir if the primary MoveDir fails.
#No trailing / is accepted eg. "$HOME/videos"
AlternateMoveDir="$HOME/recordedTV"

#Primary Movie Dir. myth2kodi will attempt to move to this dir first. No
#trailing / is accepted eg. "$HOME/videos"
PrimaryMovieDir='/media/video/movies'        #<------THIS VALUE MUST BE SET-------

#AlternateMovieDir is a fallback move dir if the primary movie dir fails.
AlternateMovieDir="$HOME/recordedMovies"

#Primary Show Dir. myth2kodi will attempt to move to this dir first. No
#trailing / is accepted eg. "$HOME/videos"
PrimaryShowDir='/media/video/recordedShows'  #<------THIS VALUE MUST BE SET-------

#AlternateMoveDir is a fallback move dir if the primary move dir fails
AlternateShowDir="$HOME/recordedShows"

#FailSafeDir is used when the file cannot be moved to the MoveDir. FailSafe
#will not create folders. eg. /home/username
FailSafeDir="$HOME/FailSafe"                 #<------THIS VALUE MUST BE SET-------


######################### myth2kodi Database Settings ########################

#Language setting, used when accessing www.TheTVDB.com to build our local DB.
Language='en'

#API key used to access www.TheTVDB.com. Default: '3B054E548E3F4FBE'
APIkey='3B054E548E3F4FBE'

#Internet access Timeout in seconds, used for TheTVDB. Default: 50
Timeout=50

#Update database time in seconds, Longer duration means faster processing time
#and less strain on TheTVDB. Default='88920' (1 day + eps)
UpdateDatabase=264920


########################## MythTV Database Settings ##########################

#MythTV database access allows addition of movies, comskip data, and improves
#accuracy of episode recognition. Options: ['Enabled'(DEFAULT)|'Disabled']
Database='Enabled'  #TODO: Review this: I'm not clear on the purpose/function in the absence of MythTV-DB...

#Database access method for MythTV-DB ['PythonBindings'(DEFAULT)|'MySQL']
DATABASE_ACCESS='PythonBindings'

#MySQL Myth Database: Default: 'mythconverg'
MySQLMythDb='mythconverg'

#Guide data type: SchedulesDirect currently covers DataDirect, MC2XML and others.
#NoLookup will bypass tvdb scanning
#SydFTA was written to handle the guide data transmitted by free-to-air digital
#channels in Sydney, Australia.
#Options: ['SchedulesDirect'|'NoLookup'|'SydFTA'(DEFAULT)]
GuideDataType='SydFTA'

#The IP address or name of the server for MythTV Database (used in python bindings only)
#TODO: This doesn't seem to be being used, at least, having it set incorrectly (192.168.1.42 while testing on borg (.78)) doesn't seem to cause a problem...
DBHostName='192.168.1.78'                    #<------THIS VALUE MUST BE SET-------

#MySQL User name: Default: 'mythtv'
MySQLuser='mythtv'

#MySQL Password: Default: 'mythtv'
MySQLpass='mythtv'                           #<------THIS VALUE MUST BE SET-------

#The Database Pin for the MythTV Database (used in python bindings only)
DBPin=0000                                   #<------THIS VALUE MUST BE SET-------


########################## Reporting/Communications ##########################

#DailyReport provides a local log of shows added to your library per day.
#Options: ['Enabled'(DEFAULT)|'Disabled']
DailyReport='Enabled'

#Notify tells myth2kodi to send a notification to the Desktop (currently only
#gnome) via DBUS upon completion. Options: ['Enabled'|'Disabled'(DEFAULT)]
Notify='Disabled'

#If notifications are enabled, desktop (currently only gnome) messages are
#sent to the user specified by NotifyUserName, Default: "$Librarian".
#  NOTE: if you want to specify a user other than $Librarian then $Librarian
#        must have passwordless sudo privileges otherwise the call to
#        m2k_notify will block, waiting for a password.
NotifyUserName="$Librarian"

#Send a notification to KODI to Update library upon Successful move job.
#Options: ['Enabled'(DEFAULT)|'Disabled']
KODIUpdate='Enabled'

#PREVENT CLOBBERING ON RECURSIVE CALLS#[[ -z "$KODIUpdate" ]] && KODIUpdate='Enabled'
#Send a notification to KODI to cleanup the library upon Successful move job.
#Options: ['Enabled'|'Disabled'(DEFAULT)]
KODIClean='Disabled'

#Send Notifications to KODI UI when the library is updated.
#Options: ['Enabled'(DEFAULT)|'Disabled']
KODINotify='Enabled'

#IP-Address and port for KODI Notifications. NOTE: If you've set username and
#password for remote access to kodi then you'll need to prepend user:password@
#to the ip addresses.
#Eg.KODIIPs=( '192.168.1.110:8080' 'user:password@192.168.1.111:8080' 'XBOX:8080' )
KODIIPs=( '127.0.0.1:8080' )                 #<------THIS VALUE MUST BE SET-------

#Whether to create an RSS entry. The RSS can be given as a target for the
#RSS-ticker running across the bottom of the default Kodi interface. If enabled
#it will show a list of recent successfully processed recordings. See,
#    myth2kodi --config-help
#for more information on setting this up.
#Options: ['Enabled'(DEFAULT)|'Disabled']
CREATE_RSS='Enabled'

#RSSmaxItems controls the number of items in the RSS. RSS Can be activated by
#creating a folder in /var/www/myth2kodi-rss. NOTE: setting this to 0 will
#essentially be ignored as generateRSS() considers it unset and defaults to 8.
declare -i RSSmaxItems=8


############################ Maintenance Settings ############################

#How often (in seconds) to perform routine maintenance of tracked files.
#DEFAULT=259200 (72 hours)
#NOTE: Maintenance can be forced at any time using 'myth2kodi --maintenance'.
MAINTENANCE_PERIOD=259200

#How long to persist archived myth2kodi database files in months, DEFAULT=6.
M2K_DB_LIFE=6

#How long to persist daily report files in months, DEFAULT=12.
DAILYREPORT_LIFE=12

#How long to persist archived log files in months. Log files older than this
#will be deleted during maintenance. Default: 6
LOG_LIFE=6


############################## Logging Settings ##############################
#The settings below are for the bashlogging script which provides the configurable
#logging functionality used in myth2kodi.
#LOGLEVEL provides control over the amount of information myth2kodi reports.
#    0=Only Errors;
#    1=adds warnings;
#    2=adds more information;  --> DEFAULT
#    3=provides debugging output.
#Recommend 2 to start with or if you want to keep track of what myth2kodi is doing.
#Recommend 1 for usual operation, once you're confident that everything is working.
#Only use 3 if you have a particular problem that you're trying to track down,
#it significantly increases the output.
LOGLEVEL=2

#LogFileName is the name of the log file, this will be placed in myth2kodi's
#working directory, $m2kdir set above, and have the suffix '.log' appended.
#DEFAULT: 'myth2kodi'. Resulting in: "/home/$Librarian/.myth2kodi/myth2kodi.log"
#NOTE: LOGFILE is overridden in special contexts, such as running Diagnostics.
LogFileName='myth2kodi'

#LOGTYPE defines where to direct logging messages ['stdout|'logfile'|'both'(DEFAULT)]:
#NOTE: This is made read only within the bashlogging script.
LOGTYPE='both'

##############################################################################
######################### END USER SETTINGS ##################################
##############################################################################



#TODO: Review text under: Output-Files; Database-external; Database-internal;
#      Dependencies; .

#TODO: If making a tar ball as a "Release", include the following:
#    myth2kodi
#    bashlogging
#    mythdb_access
#    m2k_notify
#    myth2kodi.conf
#    myth2kodi.png
#    myth2kodi_failed.png
#    showTranslations.SydFTA

#TODO: Make use of TMDb (https://www.themoviedb.org/) when the recorded
#  program is identified as being a Movie... eg
#    "https://api.themoviedb.org/3/search/movie?query=$$tmdbshowname&api_key=%(apikey)s&page=%%s" % (config)
#    "https://api.themoviedb.org/3/movie/$TMDbID?api_key=$TMDb_key
#Or http://omdbapi.com/, eg
#  http://www.omdbapi.com/?t=Casino&y=&plot=short&r=xml

#TODO: Review logging statements throughout... Add consistent stack-trace
#      information to all warn and err statements (maybe in bash-logging).
#      Move some of the inform statements to debug, to avoid lots of
#      repetition with inform (level 2) logging.

#TODO: Consider changing default binpath from "/usr/local/bin" to
#      "/home/$Librarian/bin". We really want to avoid root/sudo requirements
#      as much as possible.

#TODO: really need to review doover and undo usage...
#TODO: REALLY NEED TO REVIEW sudo USE AND PERMISSIONS EXPECTATIONS WITHIN THE SCRIPT...

#TODO: Review RequiresDoover and EpisodeConfidenceRating usage...

#TODO: If we just prepend $binpath to $Librarian's path we could avoid all the
#      explicit paths in our function calls... Though we may need to clean up before we finished...
#          SCRIPTPATH="$( cd "$(dirname "$0")" ; pwd -P )"

#TODO: Check all deletion or other reference of ' ' and consider whether it
#      would be better to use the more inclusive [[:blank:]] or [[:space:]]...

#TODO: review issues caused by multiple simultaneous instances, eg log file
#      needs to be locked to prevent deleting by subsequent call that triggers
#      logrotate... maybe GUID log files on a per-call basis???

#
#TODO: ?Would it be neater to just have undo and doover as lists of MythTV
#      recording file names, then just have functions to process them???

################################################################################
##################### Abandon all hope, ye who enter here. #####################
################################################################################
#################### ADEPT PERSONNEL ONLY BEYOND THIS POINT ####################
################################################################################

######################### BEGIN FUNCTION DEFINITIONS ###########################
#The exit_job function is a place where your custom scripts can be run at the
#end of execution. Though it may be at the top, this is actually the end of
#the program. Place custom scripts in $m2kdir/userjobs/ with filename $jobtype.
exit_job(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "Called with $# arguments"
  local -i i=0; local var; for var in "$@"; do ((++i)); debugcont "arg $i = ${var}"; done
  local jobtype="$1"
  local ERR_HEADER="${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}()."
  local -i exitstatus
  local -a NOTIFY_ICON
  NOTIFY_ICON[0]="$m2kdir/myth2kodi.png"
  NOTIFY_ICON[1]="$m2kdir/myth2kodi_failed.png"

  case "$jobtype" in
    SuccessfulCommandLineSwitch)
      exitstatus=0
      ;;
    #Successful Completion of myth2kodi
    LinkModeSuccessful|MoveModeSuccessful)
      inform "SUCCESSFUL COMPLETION TYPE: $jobtype"
      exitstatus=0
      ;;
    #Information was not obtainable
    TheTVDBIsIncomplete)
      warn "INSUFFICIENT INFORMATION WAS SUPPLIED: $jobtype"
      exitstatus=0
      ;;
    #File system error occurred #TODO: clean-up...
    PermissionError|ZeroLengthFile|FileOrPathDoesNotExist|MoveFailed|FailSafeModeComplete|LinkingFailed)
      err "$ERR_HEADER FILE SYSTEM ERROR: $jobtype"
      exitstatus=1
      ;;
    #File name we're trying to move to already exists
    FileAlreadyExists)
      err "$ERR_HEADER NOT MOVING RECORDING: $jobtype"
      exitstatus=1
      ;;
    #Generic error occurred
    GenericUnspecifiedError)
      err "$ERR_HEADER UNKNOWN ERROR OCCOURED: $jobtype"
      exitstatus=1
      ;;
    #User elected not to process jobs which can not be properly categorized
    MythTVdatabaseFailure)
      err "$ERR_HEADER COULDN'T EXTRACT RECORDING INFO FROM MythTV-DB: $jobtype"
      exitstatus=1
      ;;
    #User elected not to process jobs which can not be properly categorized
    NameCouldNotBeAssigned)
      warn 'NAME COULD NOT BE ASSIGNED BASED UPON DATA SUPPLIED'
      exitstatus=1
      ;;
    #User elected to use a title/category ignore file
    titleIgnore|categoricIgnore)
      warn "Show was ignored based on $jobtype"
      exitstatus=0
      ;;
    #The invocation of myth2kodi had something wrong with it.
    InvalidCall|InputPathNotFile|InsufficientInformationProvided|UserSettingError)
      err "$ERR_HEADER myth2kodi called incorrectly: $jobtype"
      exitstatus=1
      ;;
    #Catch any incorrectly set exit types.
    *)
      warn "Unrecognised exit job type: '$jobtype'"
      exitstatus=1
      ;;
  esac

  #Send a desktop notification message if appropriate conditions are met.
  if [[ "$m2kScanMode" != 'True' && "$Notify" = 'Enabled' && -n "$NOTIFY_MSG" ]]; then
    debug "NOTIFY_MSG=$NOTIFY_MSG  ;  NOTIFY_ICON=${NOTIFY_ICON[$exitstatus]}"
    sudo -u "$NotifyUserName" "$binpath/m2k_notify" "myth2kodi: $jobtype" "$NOTIFY_MSG" "${NOTIFY_ICON[$exitstatus]}"
  else
    debug 'Either: Notify=Disabled; scan mode; recording is in an ignore list; or NOTIFY_MSG was not set.'
  fi

  #Final myth2kodi log entry when processing a recording, regardless of LOGLEVEL.
  if [[ "$PROCESSING_RECORDING" = "True" ]]; then
    printf '%s\n' "@@@@ COMPLETE: $(date --rfc-3339=seconds) @@@@" >> "$LOGFILE"
  fi

  #TODO: Hacky fix to work around markupframes temp files we loose track of when processing fails...
  [[ -f "$MARKUPFRAMES_TMP" ]] && (( LOGLEVEL < 3 )) && rm -rf "$MARKUPFRAMES_TMP"

  #Some excessive logging for extra buggy bugs.
  ((LOGLEVEL>=4)) && env | err_pipe 'env:  '
  ((LOGLEVEL>=42)) && set | err_pipe 'set:  '

  #Run any user job specified for this job type.
  if [[ -f "$m2kdir/userjobs/$jobtype" ]]; then
    inform "Processing user job: $m2kdir/userjobs/$jobtype"
    source "$m2kdir/userjobs/$jobtype" 2>&1 | err_pipe "${FUNCNAME[0]}(): $jobtype: "
  fi
  exit "$exitstatus"
}

#Initialises a new log file with creation information -- can be run before
#the logging system is initialised.
initialise_new_logfile(){
  touch "$LOGFILE"
  {
    printf 'Creating Log File: %s\n' "$LOGFILE"
    printf 'Created on %s at %s\n' "$Today" "$ScriptStartTime"
  } >> "$LOGFILE"
}

#When a file exceeds a specified size, give it an archive name and compress it.
log_rotation(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local FILE_NAME ARCHIVE_NAME
  local -i FILE_SIZE_LIMIT
  FILE_NAME="$1"
  ARCHIVE_NAME="$2"
  FILE_SIZE_LIMIT="${3-1048576}" #Default to ~1MB
  declare -g ARCHIVED_FILE
  ARCHIVED_FILE='' #Global/return-state set to 'True' when we archive a file.

  #When the $FILE_NAME exceeds $FILE_SIZE_LIMIT, archive it.
  if [ -f "$FILE_NAME" ]; then
    local FILE_SIZE mvstatus gzipstatus
    FILE_SIZE=$(wc --bytes < "$FILE_NAME")
    if ((FILE_SIZE > FILE_SIZE_LIMIT)); then
      inform "Moving and compressing $FILE_NAME"
      mv "$FILE_NAME" "$ARCHIVE_NAME" 2>&1 | err_pipe "${FUNCNAME[0]}(): "
      mvstatus="${PIPESTATUS[0]}"
      ((mvstatus==0)) && gzip "$ARCHIVE_NAME" 2>&1 | err_pipe "${FUNCNAME[0]}(): "
      gzipstatus="${PIPESTATUS[0]}"
      if ((mvstatus+gzipstatus==0)); then
        inform "Moved old $FILE_NAME to ${ARCHIVE_NAME}.gz"
        ARCHIVED_FILE='True'
      else
        err "Errors archiving $FILE_NAME: mv=$mvstatus; gzip=$gzipstatus"
        ARCHIVED_FILE='False'
      fi
    fi
  fi
}

#This is the first command executed after the setting of variables at the top
#of this file. It initialises the state of the script and the logging system.
m2k_init(){
  #Override default settings with anything in myth2kodi.conf
  [[ -f "$m2kdir/myth2kodi.conf" ]] && source "$m2kdir/myth2kodi.conf"

  #What am I...
  m2kVersion="myth2kodi Version 0.9.9" ; declare -gr m2kVersion
  m2kPlatform="$(uname)" ; declare -gr m2kPlatform

  #Who called me...
  CALLER=$(whoami) ; declare -gr CALLER
  if [[ "$CALLER" != "$Librarian" ]]; then
    printf 'ERROR: %s\n' "myth2kodi should be run by user '$Librarian'"
    printf '  %s\n' "Check the USER SETTINGS section near the top of the script"
    printf '  %s\n' "you just ran or the settings file. That is, take a look at"
    printf '  %s\n' "the top few hundred lines of: ${BASH_SOURCE[0]}"
    printf '  %s\n' "or: $m2kdir/myth2kodi.conf"
    exit 1
  fi
  #Strongly recommend against running as root.
  if [[ "$EUID" = '0' || "$UID" = '0' || "$USER" = 'root' ]]; then
    local yesorno='no'
    printf 'WARNING: %s\n' "myth2kodi should NOT be run as root."
    printf '  %s\n' "myth2kodi has detected that you are running as"
    printf '  %s\n' "a privileged user. This may lead to permission"
    printf '  %s\n' "contamination of normally unprivileged files."
    printf '  %s\n' "Do not run this script with sudo."
    read -r -p "Possible permission contamination. Continue anyway? yes/(no)" yesorno
    printf '\n'
    #Default to safety, ie do nothing and exit with status 1.
    [[ "$yesorno" != "yes" ]] && exit 1
    printf 'WARNING: %s\n' "Continuation forced by $CALLER, despite possible permission contamination."
  fi

  #And when...
  Today="$(date +%F)"  #Date in IEEE standard format, ie YYYY-mm-dd
  ScriptStartTime="$(date +%H:%M:%S)" #Time in a readable IEEE standard format, ie HH:MM:SS
  FileNameNow="$(date +%FT%H%M%S)"  #ISO 8601: YYYY-mm-ddThhMMSS
  declare -gr Today
  declare -gr ScriptStartTime
  declare -gr FileNameNow

  #The full path version of the file to which logging output will be sent:
  LOGFILE="$m2kdir/${LogFileName}.log"
  #When running diagnostics mode, output will instead be sent to this file:
  DiagnosticsFile="$m2kdir/diagnostics.log" ; declare -gr DiagnosticsFile
  #A file containing a list of possible duplicate recordings:
  DuplicatesFile="$m2kdir/duplicates.log" ; declare -gr DuplicatesFile
  #A file containing a list of unrecognised recordings:
  UnrecognizedSeriesFile="$m2kdir/unrecognizedseries.log" ; declare -gr UnrecognizedSeriesFile

  #Make our working directory if it doesn't already exist
  if [[ ! -d "$m2kdir" ]]; then
    local createworkingdirstatus
    mkdir --parents "$m2kdir"
    createworkingdirstatus="$?"
    if [[ "$createworkingdirstatus" != 0 || ! -d "$m2kdir" ]]; then
      printf 'ERROR: %s\n' "Creation of our working directory failed... This needs to be corrected."
      printf '  %s\n' "First check that the user settings 'Librarian' and 'm2kdir' are correct."
      printf '  %s\n' "Then check that $Librarian has a home directory, if not create it, eg:"
      printf '    %s\n' "sudo mkdir /home/$Librarian"
      printf '    %s\n' "sudo chown -R $Librarian:users /home/$Librarian"
      printf '  %s\n' "Finally, be sure to run 'myth2kodi --diagnostics' before first use."
      exit 1
    fi
    initialise_new_logfile
    {
      printf 'Created Working Directory: %s\n' "$m2kdir"
      printf '  %s\n' 'If you intend to Enable desktop notifications'
      printf '  %s\n' "then you'll need to copy myth2kodi.png and"
      printf '  %s\n' "myth2kodi_failed.png into $m2kdir"
    } | tee -a "$LOGFILE"
  fi

  #Initialise logging system
  if [ -f "$binpath/bashlogging" ] ; then
    local bashloggingstatus
    source "$binpath/bashlogging"
    bashloggingstatus="$?"
    [[ "$bashloggingstatus" != "0" ]] && exit "$bashloggingstatus"
  else
    printf 'ERROR: %s\n' "$binpath/bashlogging doesn't exist." | tee -a "$LOGFILE"
    exit 1
  fi

  #When the LOGFILE exceeds 4MB compress it and start a fresh one.
  log_rotation "$LOGFILE" "$m2kdir/${LogFileName}_${FileNameNow}.log" '4000000'
  if [[ "$ARCHIVED_FILE" = 'True' ]]; then
   initialise_new_logfile
   inform "Previous LOGFILE moved to: $m2kdir/${LogFileName}_${FileNameNow}.log"
  fi

  #Set defaults for searching Series information
  SeriesID=""
  NewShowName=""
  RequiresDoover=0
  ConfidenceRating=0
  SeriesConfidenceRating=0
  #Setup defaults for searching Episode information
  Exx=""
  Sxx=""
  GotEpisodeNumber=0
  EpisodeConfidenceRating=0

  debug "myth2kodi script initialisation complete."
  debug "Running myth2kodi as $CALLER"

  #Some excessive logging for extra buggy bugs.
  ((LOGLEVEL>=4)) && env | err_pipe 'env:  '
  ((LOGLEVEL>=42)) && set | err_pipe 'set:  '
}

#TODO: Consider adding a validate_settings function, it should check for
#      incompatible or inadvisable setting combinations, or just wrong settings,
#      such as directory settings that aren't directories and then warn or err
#      and abort as appropriate.
validate_settings(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  err "${FUNCNAME[0]}(): NotImplemented."
  return 1

  #A local reusable message variable
  local msg

  #Check all Enabled|Disabled switches are set correctly.
  msg="is expected to be set as either 'Enabled' or 'Disabled'."
  [[ "$SYMLINK"                 =~ ^(Enabled|Disabled)$ ]] || err "SYMLINK $msg"
  [[ "$TargetPathIsInputPath"   =~ ^(Enabled|Disabled)$ ]] || err "TargetPathIsInputPath $msg"
  [[ "$FailSafeMode"            =~ ^(Enabled|Disabled)$ ]] || err "FailSafeMode $msg"
  [[ "$DirTracking"             =~ ^(Enabled|Disabled)$ ]] || err "DirTracking $msg"
  [[ "$StorageGroupFallback"    =~ ^(Enabled|Disabled)$ ]] || err "StorageGroupFallback $msg"
  [[ "$PlotMatchFallback"       =~ ^(Enabled|Disabled)$ ]] || err "PlotMatchFallback $msg"
  [[ "$Database"                =~ ^(Enabled|Disabled)$ ]] || err "Database $msg"
  [[ "$ShowStopper"             =~ ^(Enabled|Disabled)$ ]] || err "ShowStopper $msg"
  [[ "$CommercialMarkup"        =~ ^(Enabled|Disabled)$ ]] || err "CommercialMarkup $msg"
  [[ "$CommercialMarkupCleanup" =~ ^(Enabled|Disabled)$ ]] || err "CommercialMarkupCleanup $msg"
  [[ "$DailyReport"             =~ ^(Enabled|Disabled)$ ]] || err "DailyReport $msg"
  [[ "$Notify"                  =~ ^(Enabled|Disabled)$ ]] || err "Notify $msg"
  [[ "$KODIUpdate"              =~ ^(Enabled|Disabled)$ ]] || err "KODIUpdate $msg"
  [[ "$KODIClean"               =~ ^(Enabled|Disabled)$ ]] || err "KODIClean $msg"
  [[ "$KODINotify"              =~ ^(Enabled|Disabled)$ ]] || err "KODINotify $msg"
  #Or
  # local -a switch_user_settings
  # switch_user_settings=('SYMLINK' 'TargetPathIsInputPath' 'FailSafeMode'         \
  #                       'DirTracking' 'StorageGroupFallback' 'PlotMatchFallback' \
  #                       'Database' 'ShowStopper' 'CommercialMarkup'              \
  #                       'CommercialMarkupCleanup' 'DailyReport' 'Notify'         \
  #                       'KODIUpdate' 'KODIClean' 'KODINotify' )
  # for var in switch_user_settings ; do
  #   [[ "${!var}" =~ ^(Enabled|Disabled)$ ]] || err "$var $msg"
  # done

  msg="is expected to be set as either 'PythonBindings' or 'MySQL'."
  [[ "$DATABASE_ACCESS" =~ ^(PythonBindings|MySQL)$ ]] || err "DATABASE_ACCESS  $msg"

  #Check that all user set directories are, in fact, directories.
  msg='is not a directory:'
  [[ -d "$m2kdir" ]]            || err "'m2kdir' $msg $m2kdir"
  [[ -d "$binpath" ]]           || err "'binpath' $msg $binpath"
  [[ -d "$M2K_TMPDIR" ]]        || err "'M2K_TMPDIR' $msg $M2K_TMPDIR"
  [[ -d "$MoveDir" ]]           || err "'MoveDir' $msg $MoveDir"
  [[ -d "$AlternateMoveDir" ]]  || err "'AlternateMoveDir' $msg $AlternateMoveDir"
  [[ -d "$PrimaryMovieDir" ]]   || err "'PrimaryMovieDir' $msg $PrimaryMovieDir"
  [[ -d "$AlternateMovieDir" ]] || err "'AlternateMovieDir' $msg $AlternateMovieDir"
  [[ -d "$PrimaryShowDir" ]]    || err "'PrimaryShowDir' $msg $PrimaryShowDir"
  [[ -d "$AlternateShowDir" ]]  || err "'AlternateShowDir' $msg $AlternateShowDir"
  [[ -d "$FailSafeDir" ]]       || err "'FailSafeDir' $msg $FailSafeDir"

  #Discourage excessive load on TheTVDB.
  msg="Don't update from TheTVDB more than once per day, ie set UpdateDatabase>=86400."
  ((UpdateDatabase < 86400)) && err "$msg"

  #PROCESS_RECORDING_MODE='LINK' and SYMLINK='Disabled' are incompatible
  if [[ "$PROCESS_RECORDING_MODE" = 'LINK' && "$SYMLINK" != 'Enabled' ]]; then
    err "Using LINK mode processing without 'SYMLINK'ing set as 'Enabled' doesn't make sense."
    return 1
  fi

}

#Do some basic tests to make sure we were called correctly
validate_args(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: Review/Expand the checks of whether we were called correctly.
  #We need at least one arg
  if [[ -z "$m2karg1" ]]; then
    NOTIFY_MSG='myth2kodi must be called with at least one argument.'
    err "${FUNCNAME[0]}(): $NOTIFY_MSG"
    msg_usage
    EXIT_JOB_TYPE='InvalidCall'
    return 1
  fi

  #Called at command line with MythTV user job form.
  if [[ "$m2karg1" = '%DIR%/%FILE%' ]]; then
    msg_userjob_outside_mythtv_error
    return 1
  fi

  #If the first arg isn't a switch or our testfile, then it must be a file.
  if [[ "${m2karg1:0:1}" != "-" && "$m2karg1" != "testfile.ext" && ! -f "$m2karg1" ]]; then
    if [[ "$Notify" = 'Enabled' ]]; then
      NOTIFY_MSG="The specified InputPath is not a file."
    fi
    err "${FUNCNAME[0]}(): InputPath is not a file."
    msg_usage
    EXIT_JOB_TYPE='InputPathNotFile'
    return 1
  fi

  debug "Call seems correct: myth2kodi '$m2karg1' '$m2karg2' '$m2karg3' '$m2karg4'"
  return 0
}

parse_command_flags(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  EXIT_JOB_TYPE='SuccessfulCommandLineSwitch'
  #check for command line switches
  case "$m2karg1" in

    --scan) #filetype /path/to/folder
      debug "Recognised command line switch '--scan'"
      #TODO: Add ability to scan only specific files, eg those for a specific ShowName
      export m2kScanMode="True"
      m2k_scan
      declare -i scanreturnstatus="$?"
      unset m2kScanMode
      return $scanreturnstatus
    ;;
    --movie) #/path/to/recording/filename.mpg
      debug "Recognised command line switch '--movie'"
      export ShowCategory="Movie"
      myth2kodi "$m2karg2" "$m2karg3" "$m2karg4"
      declare -i m2kreturnstatus="$?"
      unset ShowCategory
      return $m2kreturnstatus
    ;;
    --diagnostics)
      debug "Recognised command line switch '--diagnostics'"
      export m2kDiagnosticsMode="True"
      local PreCallLogFile="$LOGFILE"
      local PreCallLogLevel="$LOGLEVEL"
      (( LOGLEVEL < 2 )) && LOGLEVEL=2 && inform "Escalating LOGLEVEL to Info (2)."
      if [[ "$LOGTYPE" != "stdout" ]] ; then
        inform "Running diagnostics, so redirecting subsequent messages to $DiagnosticsFile"
      else
        warn "Running diagnostics without any logging to file, consider using LOGTYPE 'logfile' or 'both'"
      fi
      LOGFILE="$DiagnosticsFile"
      m2k_diagnostics
      declare -i diagnosticsreturnstatus="$?"
      #Reset the LOGFILE & LOGLEVEL to previous state, in case we ever call
      # myth2kodi --diagnostics from within myth2kodi
      LOGFILE="$PreCallLogFile"
      LOGLEVEL="$PreCallLogLevel"
      [[ "$LOGTYPE" != "stdout" ]] && inform 'Finished running diagnostics.'
      unset m2kDiagnosticsMode
      return $diagnosticsreturnstatus
    ;;
    --confidence)
      debug "Recognised command line switch '--confidence'"
      msg_improve_confidence
      return 0
    ;;
    --doover)
      debug "Recognised command line switch '--doover'"
      m2k_doover
      return $?
    ;;
    --delete)
      debug "Recognised command line switch '--delete'"
      delete_recording "$m2karg2"
      return $?
    ;;
    --disconnect)
      debug "Recognised command line switch '--disconnect'"
      disconnect_recording "$m2karg2"
      return $?
    ;;
    --log)
      debug "Recognised command line switch '--log'"
      recording_log "$m2karg2"
      return $?
    ;;
    --unmanned_doover)
      debug "Recognised command line switch '--unmanned_doover'"
      declare -gi DoOverBypass=1
      m2k_doover
      return $?
    ;;
    --undo)
      debug "Recognised command line switch '--undo'"
      #TODO: Enable undo for a specific file, eg: myth2kodi --undo '/path/to/recordings/1070_20160331073100.mpg'
      #      Ideally we'd alternatively be able to provide the moved file name and it would still work.
      if ((m2karg_count > 1)); then
        err "${FUNCNAME[0]}(): NotImplemented: file specific --undo."
        return 1
        #m2k_undo_rec "$m2karg2"
        #return $?
      else
        m2k_undo_all
        return $?
      fi
    ;;
    --series-info) #ShowName
      debug "Recognised command line switch '--series-info'"
      #Example usage: myth2kodi --series-info "Black Books"
      get_series_info
      return $?
    ;;
    --recording-info) #recording_filename
      debug "Recognised command line switch '--recording-info'"
      #Example usage: myth2kodi --recording-info "1070_20160331073100.mpg"
      inform "Attempting to access recording info for: $m2karg2"
      set_recording_name "$m2karg2"
      [[ "$?" != 0 ]] && return "$?"
      InputFileBasename="$RECORDING_NAME"
      InputTitle=''
      process_mythtvdb
      declare -i recordinginforeturnstatus="$?"
      [[ "$recordinginforeturnstatus" != 0 ]] && return "$recordinginforeturnstatus"
      msg_recording_info
      (( LOGLEVEL < 3 )) && rm -rf "$MARKUPFRAMES_TMP"
      return "$recordinginforeturnstatus"
    ;;
    --about)
      debug "Recognised command line switch '--about'"
      msg_about
      return 0
    ;;
    --usage)
      debug "Recognised command line switch '--usage'"
      msg_usage
      return 0
    ;;
    --help|-?|-h)
      debug "Recognised command line switch '--help|-?|-h'"
      msg_about
      msg_usage
      msg_options
      return 0
    ;;
    --maintenance)
      debug "Recognised command line switch '--maintenance'"
      maintenance_warning
      [[ "$?" != 0 ]] && return $?
      declare -gi removedead=1
      m2k_maintenance
      return $?
    ;;
    --cleanse)
      debug "Recognised command line switch '--cleanse'"
      cleanse_warning
      [[ "$?" != 0 ]] && return $?
      m2k_cleanse
      return $?
    ;;
    --config-help)
      debug "Recognised command line switch '--config-help'"
      msg_config
      msg_rss
      return 0
    ;;
    --version)
      debug "Recognised command line switch '--version'"
      printf '%s\n' "$m2kVersion"
      return 0
    ;;
    --comskip) #/path/to/recording/filename.mpg | /path/to/recordings
      debug "Recognised command line switch '--comskip'"
      #eg: myth2kodi --comskip '/path/to/recordings/1070_20160331073100.mpg'
      InputPath="$m2karg2"
      if [[ ! -e "$InputPath" ]]; then
        EXIT_JOB_TYPE='FileOrPathDoesNotExist'
        NOTIFY_MSG="InputPath does not exist: '$InputPath'"
        err "${FUNCNAME[0]}(): --comskip: $NOTIFY_MSG"
        return 1
      elif [[ ! -f "$InputPath" && ! -d "$InputPath" ]]; then
        EXIT_JOB_TYPE='FileOrPathDoesNotExist'
        NOTIFY_MSG="InputPath is neither a file nor a directory: '$InputPath'"
        err "${FUNCNAME[0]}(): --comskip: $NOTIFY_MSG"
        return 1
      fi
      recreate_comskip
      return $?
    ;;
  esac

  NOTIFY_MSG="Unrecognised command line switch: $m2karg1"
  err "${FUNCNAME[0]}(): $NOTIFY_MSG"
  msg_usage
  EXIT_JOB_TYPE='UnrecognisedCommand'
  return 1
}

periodic_maintenace(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Do periodic maintenance
  if [[ "$m2kScanMode" != "True" ]]; then
    local CURRENT_TIME
    local LAST_MAINTENANCE_TIME
    CURRENT_TIME="$(date +%s)"
    #If file exist for last maintenance time, then get value
    if [[ -f "$m2kdir/lastmaintenace.time" ]]; then
      LAST_MAINTENANCE_TIME="$(cat "$m2kdir/lastmaintenace.time")"
    else #no last maintenance time, so assign a never updated value.
      inform "Seems we've never run maintenance -- no lastmaintenace.time file."
      LAST_MAINTENANCE_TIME=42 #A meaningless low number to start from...
    fi
    if ((CURRENT_TIME > LAST_MAINTENANCE_TIME+MAINTENANCE_PERIOD)); then
      inform "Last maintenance more than $((MAINTENANCE_PERIOD/3600)) hours ago."
      m2k_maintenance
      local m2k_maintenance_status="$?"
      if [[ "$m2k_maintenance_status" = '0' ]]; then
        printf '%s\n' "$CURRENT_TIME" > "$m2kdir/lastmaintenace.time"
      else
        warn "FUNCNAME[0]}(): maintenance failed to run correctly."
        return "$m2k_maintenance_status"
      fi
    fi
  else
    debug "Skipping m2k_maintenance() as m2kScanMode has been set to 'True'"
  fi
}

#Set the name for episode & movie recordings when making them accessible to Kodi
set_show_file_name(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Format Episodes showname=show name Sxx=season number Exx=episode number EpisodeSubtitle=episode name
  if [[ -n "$Exx" && "$Exx" != "E" ]]; then
    debug "Naming as episode"
    ShowFileName="$NewShowName $Sxx$Exx ($EpisodeSubtitle)"
  #Format Movies
  elif [ "$m2kProgramIDCheck" = "MV" ]; then
    debug "Naming as movie"
    Exx="Movie"
    MoveDir="$PrimaryMovieDir"
    #TODO: If adding a year then we really want original release date so the Kodi metadata lookup works reliably.
    if [[ -n "$MovieAirDate" ]]; then
      warn "${FUNCNAME[0]}() Currently forcing bypass of adding MovieAirDate to Movie file names."
      ShowFileName="$NewShowName" # ShowFileName="$NewShowName ($MovieAirDate)"
    else
      ShowFileName="$NewShowName"
    fi
  #Format generic Shows
  else
    debug "Naming as generic show"
    Exx="Generic"
    MoveDir="$PrimaryShowDir"
    ShowFileName="$ShowName S0E0 ($EpisodeSubtitle Recorded $datehour on $ChanID)"
    RequiresNFO=1
    [[ "$m2kProgramIDCheck" = "EP" ]] && RequiresDoover=1
  fi
  inform "Set file name as: $ShowFileName"
}

#Set the name for special recording "Categories": 'NEWS'; 'SPORT'; etc
set_show_file_name_categoric(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local -i testedmethod
  #Method1 - use airdate for season
  if [[ "${OriginalAirDate:0:4}" != "0000" && -n "${OriginalAirDate:0:4}" && "$UseMethod2" != "1" ]]; then
    EventYear="${OriginalAirDate:0:4}"
    Sxx="$EventYear"
    EventMonthDay="$(echo "${OriginalAirDate:5:5}" | tr -d "-" | sed 's/0*//')"
    Exx="$EventMonthDay"
    [[ -z "$NewShowName" ]] && NewShowName="$ShowName"
  else #Flag failure of Method1
    testedmethod=0
  fi
  #Slight further testing of Method1 results
  if [[ -n "$EventMonthDay" ]] && ((EventYear > 1900)) && ((EventMonthDay > 0)); then
    testedmethod=1
  else
    testedmethod=0
  fi

  #Method2 -
  if ((testedmethod != 1)); then
    if [[ "${ShowStartTime:0:4}" != 0000 && -n "${ShowStartTime:0:4}" ]] ; then
      EventYear="${ShowStartTime:0:4}"
      EventMonthDay="$(echo "${ShowStartTime:5:5}" | tr -d "-" | sed 's/0*//')"
    fi
    Exx="$EventMonthDay"
    Sxx="$EventYear"
    #TODO: Check validity of Method2
  fi

  #Test final result and assign ShowFileName
  ((EventYear > 1900)) && ((EventMonthDay > 0)) && ShowFileName="$NewShowName S$EventYear""E$EventMonthDay ($InputSubtitle Recorded $datehour)"

  RequiresNFO=1
  HasSxxExx=1
  inform "Set file name as: $ShowFileName"
}

#Appends an entry to today's DailyReport file for the show just processed.
dailyreport(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [ "$DailyReport" = 'Enabled' ]; then
    [[ ! -d "$m2kdir/DailyReport" ]] && mkdir "$m2kdir/DailyReport"
    local reporttime ; reporttime=$(date +%T) #TODO: This should use a time generated at the same time as $Today otherwise processing near midnight could cause misleading information.
    inform "Writing to DailyReport file: ${Today}"
    printf '%s\n' "$reporttime - $ShowFileName" >> "$m2kdir/DailyReport/${Today}"
  fi
  return 0
}

#Check write permission and free space, return 0 (writeable) or 1 (not).
#Takes 3 args: $1=filesize ; $2=freespace ; $3=directory
check_write(){
  #TODO: Do we really need to write a dummy file here??? Wouldn't file comparisons using -e -d -r -w etc be sufficient...
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "Called with $# arguments"
  local -i i=0 ; local var ; for var in "$@"; do ((++i)) ; debugcont "arg $i = ${var}" ; done
  if [[ -n "$2" ]]; then
    if [[ -n "$1" ]]; then
      if [ -d "$3" ]; then
        if (($1 < $2)); then
          printf '%s\n' "Testing write permission on $3" > "$3/arbitraryfile.ext"
          if [ -f "$3/arbitraryfile.ext" ] ; then
            if [ -s "$3/arbitraryfile.ext" ]; then
              rm -f "$3/arbitraryfile.ext"
              if [[ ! -f "$3/arbitraryfile.ext" ]]; then return 0 ; else return 1; fi
            else
              err "${FUNCNAME[0]}() CREATED $3/arbitraryfile.ext BUT COULD NOT WRITE DATA INTO THE FILE"
              return 1
            fi
          else
            err "${FUNCNAME[0]}() $CALLER TRIED TO WRITE TO $3 --FAILED"
            [[ ! -r "$3" ]] && inform "QUICK FIX: sudo chmod a+r '$3'"
            [[ ! -w "$3" ]] && inform "QUICK FIX: sudo chmod a+w '$3'"
            inform "QUICK FIX: sudo chown $CALLER '$3'"
          fi
        elif [ -z "$2" ] || (( $1 >= $2 )); then
          err "${FUNCNAME[0]}() INSUFFICIENT FREE SPACE ON '$3'"
          inform "QUICK FIX: Remove unnecessary files"
          return 1
        fi
      else
        err "${FUNCNAME[0]}() FOLDER DOES NOT EXIST: '$3'"
        inform "QUICK FIX: mkdir '$3'"
      fi
    else
      warn "${FUNCNAME[0]}() COULD NOT READ FILESIZE ON $InputPath"
      inform "QUICK FIX: chmod -R 775 '$InputPath'"
    fi
  else
    warn "${FUNCNAME[0]}() COULD NOT READ FREE SPACE on '$3'"
    inform "QUICK FIX: mkdir '$3' ; chmod -R 775 '$3'"
  fi

  return 1
}

#Create a comskip.txt file from MythTV database information for use by Kodi.
generate_comskip(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local -i Counter=0
  local StartData
  local StopData
  MARKUPFRAMES_TMP="$(mktemp "$M2K_TMPDIR/m2k_markupframes_$FileNameNow"-XXXX)"
  [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
  debug "Created a temporary comskip markupframes file: '$MARKUPFRAMES_TMP'"
  declare -gr MARKUPFRAMES_TMP
  #Set up comskip file
  {
    printf '%s\n' "FILE PROCESSING COMPLETE"
    printf '%s\n' "------------------------"
  } > "$MARKUPFRAMES_TMP"

  while read -r StopData ; do
    ((++Counter))
    StartData=$(sed -n "$Counter"p "$MARKUPSTART_TMP")
    if [[ ! -z "$StopData" ]]; then
      printf '%s\n' "$StartData $StopData" >> "$MARKUPFRAMES_TMP"
      CommercialMarkup="Created"
      debug "COMMERCIAL DATA START:$StartData STOP:$StopData"
    fi
  done < "$MARKUPSTOP_TMP"

  #If we're not in debug mode then remove the temporary files we just processed.
  if (( LOGLEVEL < 3 )); then
    rm -f "$MARKUPSTART_TMP"
    rm -f "$MARKUPSTOP_TMP"
  else
    debug "Not removing the temporary markup files: '$MARKUPSTART_TMP'; '$MARKUPSTOP_TMP'."
  fi
  return 0
}

#Creates a comskip file for a recording or all recordings in a directory.
#Actual file generation is done by generate_comskip()
recreate_comskip(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [[ -f "$InputPath" && -L "$InputPath" ]]; then
    inform "Regenerating comskip file for $InputPath"
    InputFileBasename="$(basename "$InputPath")"
    get_mythtvdb_info_pythonbindings
    [[ "$?" != 0 ]] && return $?
    #TODO: Find the file that $InputPath points to or is pointed to by and use that for the move location below, otherwise we have to run full identification of Episode/etc.
    #[[ -L "$InputPath" ]] && movedrecordingname="$(readlink "$InputPath")"
    local movedrecordingname
    movedrecordingname="$(readlink "$InputPath")"
    #TODO: need to deal with link mode case, something like: movedrecordingname="$(find -L "$MoveDir/" -samefile "$InputPath")" #Actually, this form should work for both cases... with the problem that multiple links can be returned in link mode if there are multiple links...
    local ShowComSkip
    ShowComSkip="${movedrecordingname%.*}.txt"
    mv "$MARKUPFRAMES_TMP" "${ShowComSkip}" 2>&1 | err_pipe "${FUNCNAME[0]}(): "
    return "${PIPESTATUS[0]}"
  elif [[ -d "$InputPath" ]]; then
    local yesorno='no' #Default to safety, ie do nothing.
    #TODO: confirm InputPath doesn't end in a /
    warn "YOU ARE ABOUT TO SCAN THE DIRECTORY: $InputPath"
    warncont "AND REGENERATE COMSKIP FILES FOR ALL PREVIOUSLY MOVED RECORDINGS."
    read -r -n1 -p "  Do you want myth2kodi to regenerate comskip files? y/(n)>" yesorno
    printf '\n'
    #Default to safety, ie do nothing.
    if [ "$yesorno" = "y" ]; then
      local checkext scanpath
      checkext="mpg" #TODO: Make this user/caller specifiable
      scanpath="$InputPath"
      local COMSKIP_SCAN_FILE
      COMSKIP_SCAN_FILE="$(mktemp "$M2K_TMPDIR/m2k_comskip_scan_$FileNameNow"-XXXX)"
      [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
      debug "Created a temporary comskip_scan file: $COMSKIP_SCAN_FILE"
      ls -1 "$scanpath"/*."$checkext" > "$COMSKIP_SCAN_FILE"
      inform "Scanning $scanpath for already moved $checkext files"
      while read -r line ; do
        debug "Attempting to regenerate comskip file for $line"
        #TODO: This check is too strict, works in move mode but won't process for a recording where we used LINK mode
        #      just do [[ -f "$line" ]] then check dir exists for move of comskip and error if not, rather than creating a directory for a show that hasn't been processed already...
        if [[ -f "$line" && -L "$line" ]]; then
          myth2kodi --comskip "$line"
        else
          debug "Not a File and Link, so not moved with symlinking enabled... Not regenerating comskip. #TODO: HANDLE ALL MOVE MODES PROPERLY HERE."
        fi
      done < "$COMSKIP_SCAN_FILE"

      #If we're not in debug mode then remove the comskip scan file we just processed.
      if (( LOGLEVEL < 3 )); then
        rm -f "$COMSKIP_SCAN_FILE"
      else
        debug "Not removing the temporary comskip scan file: '$COMSKIP_SCAN_FILE'"
      fi
      return 0
    else
      inform "You must press 'y' to scan, aborting."
      return 0
    fi
  else
    [[ -f "$InputPath" && ! -L "$InputPath" ]] && err "#TODO: --comskip can't deal with link mode moving yet..."
    err "The argument '$InputPath' is neither an already moved recording nor a directory to scan for them."
    return 1
  fi
}

#####KODI COMMUNICATIONS#####
#Request Kodi remove any no-longer reachable files from its library.
kodi_cleanup(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "m2kScanMode: $m2kScanMode"
  debugcont "KODIClean: $KODIClean"
  debugcont "$( printf 'KODIIPs: %s' "${KODIIPs[*]/%/ ;}." )"
  if [[ "$m2kScanMode" != "True" ]] ; then
    if [[ "$KODIClean" = 'Enabled' ]] ; then
      local data=""
      local curlPOST=""
      curlPOST='curl --silent --max-time 8 --connect-timeout 5 -H "Content-Type: application/json;" --data-binary'
      data=\''{"jsonrpc": "2.0", "method": "VideoLibrary.Clean", "id": "myth2kodi"}'\'
      #Send VideoLibrary.Clean request to Kodi instances specified in user settings (KODIIPs).
      for KODIIP in "${KODIIPs[@]}" ; do
        inform "Sending VideoLibrary.Clean request to: $KODIIP"
        eval "$curlPOST $data http://$KODIIP/jsonrpc" > /dev/null 2>&1
      done
    else
      debug 'VideoLibrary.Clean request to Kodi disabled.'
    fi
  else
    debug 'Scan Mode: Skipping Kodi VideoLibrary.Clean request.'
  fi
  return 0
}

#Send a GUI notification to Kodi and request it update its library.
kodi_newshow(){
  #TODO: there must be a better way to do this neatly than using eval...
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "m2kScanMode: $m2kScanMode"
  debugcont "KODINotify: $KODINotify"
  debugcont "KODIUpdate: $KODIUpdate"
  debugcont "$( printf 'KODIIPs: %s' "${KODIIPs[*]/%/ ;}." )"
  debugcont "ShowName: $ShowName"
  local data=""
  local curlPOST=""
  #SEE: http://kodi.wiki/view/HOW-TO:Remotely_update_library and 'man curl'
  curlPOST='curl --silent --max-time 8 --connect-timeout 5 -H "Content-Type: application/json;" --data-binary'

  #Send notification to KODI
  if [[ "$KODINotify" = 'Enabled' ]]; then
    data=\''{"jsonrpc": "2.0",
             "method": "GUI.ShowNotification",
             "params": {"title": "myth2kodi added", "message": "'"$ShowName"'"},
             "id": "myth2kodi"}'\'
    for KODIIP in "${KODIIPs[@]}" ; do
      inform "Sending GUI.ShowNotification request to: $KODIIP"
      eval "$curlPOST $data http://$KODIIP/jsonrpc" > /dev/null 2>&1
      debug "SENT: GUI.ShowNotification for $ShowName"
    done
  else
    debug 'Kodi notification is disabled.'
  fi

  #Send Update Library request to KODI
  if [[ "$m2kScanMode" != 'True' ]] ; then
    if [[ "$KODIUpdate" = 'Enabled' ]]; then
      data=\''{"jsonrpc": "2.0", "method": "VideoLibrary.Scan", "id": "myth2kodi"}'\'
      for KODIIP in "${KODIIPs[@]}" ; do
        inform "Sending VideoLibrary.Scan request to: $KODIIP"
        eval "$curlPOST $data http://$KODIIP/jsonrpc" > /dev/null 2>&1
        debug 'SENT: VideoLibrary.Scan request.'
      done
    else
      debug 'Kodi library updates are disabled.'
    fi
  else
    debug 'Scan Mode: Skipping Kodi VideoLibrary.Scan request.'
  fi
  return 0
}

#Generate an RSS feed for processed recordings, Kodi can be set to view this feed.
generaterss(){
  #Big thanks to barney_1!
  #TODO: return codes from this function aren't captured...
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #user settings:
  #TODO: this probably should be a setting at the top of file...
  local rssDir='/var/www/myth2kodi-rss'
  ((RSSmaxItems == 0)) && RSSmaxItems=8 #maximum number of items to read into the feed

  #script settings
  local OLDrssFile='rss.xml'
  local TEMPrssFile='rss.temp'

  #HTML line break code for nice formatting
  local lineBreak='&lt;br /&gt;'

  #test if rssFile directory is writeable
  if [ ! -w "$rssDir" ]; then
    err "${FUNCNAME[0]}() RSS generation failed: Directory not writeable ($rssDir)"
    return 5
  fi

  #test if rssFile is writeable
  if [[ -e "$rssDir/$OLDrssFile" && ! -w "$rssDir/$OLDrssFile" ]]; then
    err "${FUNCNAME[0]}() RSS generation failed: File exists but is not writeable: $rssDir/$OLDrssFile"
    return 6
  fi

  #Setup the rss file
  {
    echo -e '<?xml version="1.0" encoding="ISO-8859-1" ?>'
    echo -e '<rss version="2.0">'
    echo -e '<channel>'
    echo -e '\t<title>Recently added by myth2kodi</title>'
    echo -e '\t<link>http://kodi.tv</link>'
    echo -e '\t<description>myth2kodi Daily Report Information</description>'
  } > "$rssDir/$TEMPrssFile"

  #TODO: Need to make the call to ifconfig more portable, maybe just revert to straight call and add /sbin to librarians path.
  #  The below assumed the first inet addr was the correct one, but that can lead to the loopback, using m2 and removing 127.0.0.1 avoids this problem,
  #  though it's probably better to just set myip in the configuration at top of file. #ifconfigpath="$(command -v ifconfig)"
  which /sbin/ifconfig >/dev/null && myip="$(/sbin/ifconfig | grep 'inet addr' -m2 | cut -d: -f2 | awk '{ print $1}' | grep -v "127.0.0.1")"
  rssEpisodeSubtitle="${EpisodeSubtitle//&/&amp;}"
  rssNewShowName="${NewShowName//&/&amp;}"
  rssPlot="${Plot//&/&amp;}"
  mythicalGUID="$(sed 's/(/%28/g' <<< "$CALLER@$myip$MoveDir/$ShowFileName.$OriginalExt" | sed 's/)/%29/g' | sed 's/ /%20/g')"

  #write current recording information to first item.
  {
    echo -e "\t\t<item>"
    echo -e "\t\t\t<title>$rssNewShowName $Sxx$Exx $rssEpisodeSubtitle</title>"
  } >> "$rssDir/$TEMPrssFile"
  if [ "$m2kProgramIDCheck" = "EP" ]; then
    echo -e "\t\t\t<link>http://www.thetvdb.com/?tab=series&amp;id=$SeriesID</link>" >> "$rssDir/$TEMPrssFile"
  elif [ "$m2kProgramIDCheck" = "MV" ]; then
    echo -e "\t\t\t<link>http://www.imdb.com/search/title?release_date=,$MovieAirDate&amp;title=$ShowName&amp;title_type=feature</link>" >> "$rssDir/$TEMPrssFile"
  else
    tvdotcomshowname="${ShowName// /%20}"
    echo -e "\t\t\t<link>http://www.tv.com/search.php?type=11&amp;stype=all&amp;tag=search%3Bfrontdoor&amp;qs=$tvdotcomshowname </link>" >> "$rssDir/$TEMPrssFile"
  fi
  {
    echo -e "\t\t\t<guid>sftp://$mythicalGUID</guid>"
    echo -e "\t\t\t<pubDate>$(date -R -d "$ShowStartTime")</pubDate>"
    echo -e "\t\t\t<description>"
    echo -e "\t\t\t\tEpisode Title: $rssEpisodeSubtitle$lineBreak"
    echo -e "\t\t\t\tProgram: $rssNewShowName$lineBreak"
    echo -e "\t\t\t\tSeason: $Sxx$lineBreak"
    echo -e "\t\t\t\tEpisode: $Exx$lineBreak$lineBreak"
    echo -e "\t\t\t\tPlot: $rssPlot"
    echo -e "\t\t\t</description>"
    echo -e "\t\t</item>"
  } >> "$rssDir/$TEMPrssFile"

  #If there is an old RSS file
  if [ -e "$rssDir/$OLDrssFile" ]; then
    #test for number of </item> tags using grep
    local RssItemCount itemLimit firstLine lastLine old_rss_data
    RssItemCount=$(grep -c "</item>" "$rssDir/$OLDrssFile")

    #if $RSSmaxItems is greater than this number
    if ((RSSmaxItems > RssItemCount)); then
      #set a variable to track this number + 1 for the new entry
      itemLimit=$((RssItemCount+1))
    else
      #set tracking variable to $RSSmaxItems
      itemLimit="$RSSmaxItems"
    fi

    #get the line number for the first <item> tag
    firstLine="$(grep -n -m 1 "<item>" "$rssDir/$OLDrssFile" | cut -d ":" -f 1)"
    #get the line number for our last </item> tag
    lastLine="$(grep -n -m $((itemLimit-1)) "</item>" "$rssDir/$OLDrssFile" | tail -n1 | cut -d ":" -f 1)"
    #set IFS to use line break as a delineator
    local IFS=$'\n'
    #Read in the old RSS file
    declare -a old_rss_data=( $(cat "$rssDir/$OLDrssFile") )
    #arrayLen=${#old_rss_data[@]}
    #iterate through the array
    for index in $(seq $((firstLine-1)) $((lastLine-1))) ; do
      echo "${old_rss_data[$index]}" >> "$rssDir/$TEMPrssFile"
    done
    #copy line from old to new
    #if copied line is </item>
      #increment counter
    #if counter is great than tracking variable
      #break
  fi

  #Write close of entry to the file.
  {
    echo -e '</channel>'
    echo -e '</rss>'
  } >> "$rssDir/$TEMPrssFile"

  #move fully formed temp file on top of the old file
  mv "$rssDir/$TEMPrssFile" "$rssDir/$OLDrssFile" 2>&1 | err_pipe "${FUNCNAME[0]}(): "
  inform "RSS ENTRY SUCCESSFULLY CREATED: $rssDir/$OLDrssFile"
  return 0
}

#Adds an entry to doover.sh for the current job.
add_doover(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "m2karg1: $m2karg1"
  debugcont "m2karg2: $m2karg2"
  debugcont "m2karg3: $m2karg3"
  debugcont "m2karg4: $m2karg4"
  debugcont "m2kdir: $m2kdir"
  debugcont "InputPath: $InputPath"
  debugcont "MoveDir: $MoveDir"
  debugcont "ShowFileName: $ShowFileName"
  debugcont "OriginalExt: $OriginalExt"
  debugcont "RequiresDoover: $RequiresDoover"
  debugcont "PROCESS_RECORDING_MODE: $PROCESS_RECORDING_MODE"
  debugcont "SYMLINK: $SYMLINK"

  #Create the doover.sh file if it doesn't already exist.
  if [[ ! -f "$m2kdir/doover.sh" ]]; then
    printf '%s\n' "rm -f '$m2kdir/doover.sh'" >> "$m2kdir/doover.sh"
    chmod 666 "$m2kdir/doover.sh"
  fi

  if [[ "$RequiresDoover" = "1" ]]; then
    inform "Writing job to doover queue: $m2kdir/doover.sh"
    if [[ "$PROCESS_RECORDING_MODE" = 'MOVE' && "$SYMLINK" = 'Enabled' ]]; then
      {
        #Write doover.sh line that removes link:
        printf '%s'    "test -f \"$MoveDir/$ShowFileName.$OriginalExt\" &&"
        printf ' %s'   "test -L \"$InputPath\" &&"
        printf ' %s'   "rm -f \"$InputPath\" &&"
        printf ' %s\n' "echo Moving \"$InputPath\" to original location"
        #Write doover.sh line that moves already-moved-file back to original location:
        printf '%s'    "test -f \"$MoveDir/$ShowFileName.$OriginalExt\" &&"
        printf ' %s\n' "mv \"$MoveDir/$ShowFileName.$OriginalExt\" '$InputPath'"
      } >> "$m2kdir/doover.sh"
    elif [[ "$PROCESS_RECORDING_MODE" = 'LINK' ]]; then
      {
        #Write doover.sh lines that removes a link to a recording:
        printf '%s'    "test -L \"$MoveDir/$ShowFileName.$OriginalExt\" &&"
        printf ' %s\n' "rm -f \"$MoveDir/$ShowFileName.$OriginalExt\""
      } >> "$m2kdir/doover.sh"
    else
      err "${FUNCNAME[0]}(): PROCESS_RECORDING_MODE not equal to 'LINK' or 'MOVE' with 'SYMLINK'ing 'Enabled'."
      return 1
    fi
    #Write doover.sh line that recalls myth2kodi in the same way it was originally called:
    printf '%s\n' "myth2kodi '$m2karg1' '$m2karg2' '$m2karg3' '$m2karg4'" >> "$m2kdir/doover.sh"
  else
    err "${FUNCNAME[0]}() should only be called if job requires doover."
    errcont "RequiresDoover: $RequiresDoover"
    return 1
  fi
}

#Adds an entry to undo.sh for the current job.
add_undo(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "m2kdir: $m2kdir"
  debugcont "InputPath: $InputPath"
  debugcont "MoveDir: $MoveDir"
  debugcont "ShowFileName: $ShowFileName"
  debugcont "OriginalExt: $OriginalExt"
  debugcont "PROCESS_RECORDING_MODE: $PROCESS_RECORDING_MODE"
  debugcont "SYMLINK: $SYMLINK"

  #Create the undo.sh file if it doesn't already exist.
  if [[ ! -f "$m2kdir/undo.sh" ]]; then
    printf '%s\n' "rm -f '$m2kdir/undo.sh'" >> "$m2kdir/undo.sh"
    chmod 666 "$m2kdir/undo.sh"
  fi

  if [[ "$PROCESS_RECORDING_MODE" = 'MOVE' && "$SYMLINK" = 'Enabled' ]]; then
    {
      #Write undo.sh line that removes link:
      printf '%s'    "test -L \"$InputPath\" &&"
      printf ' %s'   "rm -f \"$InputPath\" &&"
      printf ' %s\n' "echo removed \"$InputPath\""
      #Write undo.sh line that moves already-moved-file back to original location:
      printf '%s'    "test -f \"$MoveDir/$ShowFileName.$OriginalExt\" &&"
      printf ' %s'   "mv \"$MoveDir/$ShowFileName.$OriginalExt\" \"$InputPath\" &&"
      printf ' %s\n' "echo moved \"$MoveDir/$ShowFileName.$OriginalExt\" to \"$InputPath\""
    } >> "$m2kdir/undo.sh"
  elif [[ "$PROCESS_RECORDING_MODE" = 'LINK' ]]; then
    {
      #Write undo.sh line that removes link:
      printf '%s'    "test -L \"$MoveDir/$ShowFileName.$OriginalExt\" &&"
      printf ' %s\n' "rm -f \"$MoveDir/$ShowFileName.$OriginalExt\""
    } >> "$m2kdir/undo.sh"
  elif [[ "$PROCESS_RECORDING_MODE" = 'MOVE' && "$SYMLINK" = 'Disabled' && "$RequiresDoover" != "1" ]]; then
    debug "'MOVE' mode with SYMLINK=Disabled and doesn't require doover, so MythTV-DB info has been removed."
    inform "No undo.sh entry will be added for this recording:"
    informcont "File Name: $MoveDir/$ShowFileName.$OriginalExt"
  fi
}

failsafe(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  warn "FAILSAFE FLAG WAS SET CHECK PERMISSIONS AND FOLDERS"
  warn "PERMISSION ERROR OR DRIVE FULL OR OFFLINE."
  if [[ "$FailSafeMode" = 'Enabled' ]]; then
    warn "ATTEMPTING SYMLINK TO FAILSAFE DIR: $FailSafeDir"
    inform "FailSafe link name set as: $FailSafeDir/$ShowFileName.$OriginalExt"
    ln -s "$InputPath" "$FailSafeDir/$ShowFileName.$OriginalExt"
    if [ -f "$FailSafeDir/$ShowFileName.$OriginalExt" ]; then
      inform "FAILSAFE MODE COMPLETE: SYMLINK CREATED"
    else
      err "FAILSAFE MODE FAILURE CHECK PERMISSIONS AND FREE SPACE IN $FailSafeDir"
      return 1
    fi
  else
    inform "FailSafeMode Disabled, we won't try and make a link as a fallback."
    return 0
  fi
  EXIT_JOB_TYPE='FailSafeModeComplete'
  NOTIFY_MSG="FAILSAFE mode active See $LOGFILE for more information"
  return 0
}

dbselect(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "arg 1 = $1"
  mysql -u"$MySQLuser" -p"$MySQLpass" -e "USE $MySQLMythDb ; SELECT $1 FROM recorded WHERE basename LIKE '$InputFileBasename' ; "
}

#####ACCESS MythTV DATABASE#####
#Use mysql commands to get MythTV-DB entry for the current recording.
get_mythtvdb_info_mysql(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "m2kdir: $m2kdir"
  debugcont "InputFileBasename: $InputFileBasename"
  debugcont "MySQLMythDb: $MySQLMythDb"
  debugcont "MySQLuser: $MySQLuser"
  debugcont "MySQLpass: $MySQLpass"
  debugcont "InputTitle: $InputTitle"
  debugcont "InputSubtitle: $InputSubtitle"
  debugcont "InputSeasonNum: $InputSeasonNum"
  debugcont "InputEpisodeNum: $InputEpisodeNum"

  #Obtain MythTV Database Information
  inform "Accessing MythTV DataBase Using mysql Commands:"
  inform "Attempting to pull database information on $InputFileBasename"
  #NOTE: Previously the info retrieved from the MythTV-DB was also passed through additional sed commands
  #  where "/", the thing being selected (eg "title") and occasionally spaces were stripped. At least for
  #  mythtv 0.27.5 and "mysql Ver 15.1 Distrib 10.0.22-MariaDB, for Linux (x86_64) using readline 5.2",
  #  these seem to be redundant. In case there was an old DB schema or older mysql version that required
  #  this additional processing, if the below isn't working for you try adding the additional sed commands
  #  back in, something like:
  #    | sed s/"\/"/""/g | sed -n "2p" | sed 's/chanid//g' | tr -d ' '
  #  to replace the
  #    | sed -n "2p"
  #  found below. Finally, if any of the above processing turns out to be SchedulesDirect specific then it
  #  should be moved to process_mythtvdb_schedulesdirect().
  [[ -z "$InputTitle" ]]      && InputTitle="$(     dbselect title    | sed -n "2p")"
  [[ -z "$InputSubtitle" ]]   && InputSubtitle="$(  dbselect subtitle | sed -n "2p")"
  [[ -z "$InputSeasonNum" ]]  && InputSeasonNum="$( dbselect season   | sed -n "2p")"
  [[ -z "$InputEpisodeNum" ]] && InputEpisodeNum="$(dbselect episode  | sed -n "2p")"
  ChanID="$(         dbselect chanid          | sed -n "2p")"
  ProgramID="$(      dbselect programid       | sed -n "2p")"
  LocalSeriesID="$(  dbselect seriesid        | sed -n "2p")"
  Plot="$(           dbselect description     | sed -n "2p")"
  Stars="$(          dbselect stars           | sed -n "2p")"
  ShowStartTime="$(  dbselect starttime       | sed -n "2p")"
  [[ -z "$ShowCategory" ]] && ShowCategory="$(   dbselect category        | sed -n "2p")"
  StorageGroup="$(   dbselect storagegroup    | sed -n "2p")"
  OriginalAirDate="$(dbselect originalairdate | sed -n "2p")"
  [[ "$OriginalAirDate" = "0000-00-00" ]] && OriginalAirDate=''

  #TODO: Clean up all the following mysql commands, like we've done for the above.
  #get DataType
  XMLTVGrabber=$(mysql -u"$MySQLuser" -p"$MySQLpass" -e "USE $MySQLMythDb ; SELECT xmltvgrabber FROM videosource ; " | sed 's/xmltvgrabber//g' | tr -d '/' | sed -n "2p" | tr -d ' ')
  #get year for movies
  MovieAirDate=$(mysql -u"$MySQLuser" -p"$MySQLpass" -e "USE $MySQLMythDb ; SELECT airdate FROM recordedprogram WHERE programid LIKE '$ProgramID' AND chanid LIKE '$ChanID' ; " | tr -d '/' | sed 's/airdate//g' | sed -n "2p" | tr -d ' ')
  #Blank year if it is invalid
  if [ ! -z "$MovieAirDate" ] && (( MovieAirDate < 1900 )); then
    MovieAirDate=''
  fi

  #####COMSKIP DATA#####
  #Set up counter, remove old markup data and generate new markup file from markupstart and stop
  if [[ "$CommercialMarkup" = 'Enabled' ]]; then
    MARKUPSTART_TMP="$(mktemp "$M2K_TMPDIR/m2k_markupstart_$FileNameNow"-XXXX)"
    [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
    debug "Created a temporary comskip markupstart file: '$MARKUPSTART_TMP'"
    declare -gr MARKUPSTART_TMP

    MARKUPSTOP_TMP="$(mktemp "$M2K_TMPDIR/m2k_markupstop_$FileNameNow"-XXXX)"
    [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
    debug "Created a temporary comskip markupstop file: '$MARKUPSTOP_TMP'"
    declare -gr MARKUPSTOP_TMP

    #Remove old and generate a comskip Start list
    echo "" > "$MARKUPSTART_TMP" #TODO: Compare this against what's returned by the python bindings version.
    mysql -u"$MySQLuser" -p"$MySQLpass" -e "USE $MySQLMythDb ; SELECT mark FROM recordedmarkup WHERE starttime LIKE '$ShowStartTime' AND chanid LIKE '$ChanID' AND type LIKE 4 ; " | sed 's/mark//g' | tr -d ' ' >> "$MARKUPSTART_TMP"
    #Remove old and generate comskip Stop list
    echo "" > "$MARKUPSTOP_TMP"
    mysql -u"$MySQLuser" -p"$MySQLpass" -e "USE $MySQLMythDb ; SELECT mark FROM recordedmarkup WHERE starttime LIKE '$ShowStartTime' AND chanid LIKE '$ChanID' AND type LIKE 5 ; " | sed 's/mark//g' | tr -d ' ' >> "$MARKUPSTOP_TMP"
    #Combine commercial data into a single comskip file and remove the initial files
    generate_comskip
  fi
  return 0
}

#Use python bindings to get MythTV-DB entry for the current recording.
get_mythtvdb_info_pythonbindings(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "m2kdir: $m2kdir"
  debugcont "binpath: $binpath"
  debugcont "InputFileBasename: $InputFileBasename"
  debugcont "DBPin: $DBPin"
  debugcont "DBHostName: $DBHostName"
  debugcont "MySQLMythDb: $MySQLMythDb"
  debugcont "MySQLuser: $MySQLuser"
  debugcont "MySQLpass: $MySQLpass"
  debugcont "InputTitle: $InputTitle"
  debugcont "InputSubtitle: $InputSubtitle"
  debugcont "InputSeasonNum: $InputSeasonNum"
  debugcont "InputEpisodeNum: $InputEpisodeNum"
  inform "Accessing MythTV DataBase Using PythonBindings:"
  inform "Attempting to pull database information on $InputFileBasename"

  local pythonExitStatus
  local MTV_RECINFO_FILE
  MTV_RECINFO_FILE="$(mktemp "$M2K_TMPDIR/m2k_recinfo_$FileNameNow"-XXXX)"
  [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
  debug "Storing MythTV-DB info in temporary file: '$MTV_RECINFO_FILE'"

  #NOTE: the declare also makes them local, so we'd need to mark them global
  #      with -g to access them outside of the function.
  # declare -ga mdb_startdata
  # declare -ga mdb_stopdata
  # declare -g mdb_title
  # declare -g mdb_subtitle
  # declare -g mdb_season
  # declare -g mdb_episode
  # declare -g mdb_airdate
  # declare -g mdb_originalairdate
  # declare -g mdb_storagegroup
  # declare -g mdb_stars
  # declare -g mdb_description
  # declare -g mdb_seriesid
  # declare -g mdb_programid
  # declare -g mdb_chanid
  # declare -g mdb_starttime

  #Access MytTV-DB via the python bindings and output to a temporary file.
  "$binpath"/mythdb_access --verbosity="$((LOGLEVEL<3?LOGLEVEL:3))" \
                           --filename="$InputFileBasename"          \
                           --SecurityPin="$DBPin"                   \
                           --DBHostName="$DBHostName"               \
                           --DBName="$MySQLMythDb"                  \
                           --DBUserName="$MySQLuser"                \
                           --DBPassword="$MySQLpass"                \
                           --output="$MTV_RECINFO_FILE"             \
                           --writeFile 2>&1 | err_pipe "mythdb_access: "

  pythonExitStatus="${PIPESTATUS[0]}"
  if [ "$pythonExitStatus" != "0" ] ; then
    err "${FUNCNAME[0]}() DATABASE ACCESS ERROR: COULD NOT OBTAIN INFORMATION"
    debug 'Check DBInfo in mythicalSetup, verify file is MythTV file.'
    return 1
  fi

  #read values from named pipe, remove quotes and declare $Variable=$Value
  debug "Guide data as extracted by: ${FUNCNAME[0]}()"
  while read -r var equals value ; do
    value="$(tr -d \" <<< "$value")"
    #[[ "$equals" = "=" ]] && "mdb_$var=$value" && debugcont "mdb_$var$equals$value"
    #declare -r "mdb_$var"
    [[ "$equals" = "=" ]] && declare "$var=$value" && debugcont "$var$equals$value"
  done < "$MTV_RECINFO_FILE"

  if [[ "$CommercialMarkup" = 'Enabled' ]]; then
    MARKUPSTART_TMP="$(mktemp "$M2K_TMPDIR/m2k_markupstart_$FileNameNow"-XXXX)"
    [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
    debug "Created a temporary comskip markupstart file: '$MARKUPSTART_TMP'"
    declare -gr MARKUPSTART_TMP

    MARKUPSTOP_TMP="$(mktemp "$M2K_TMPDIR/m2k_markupstop_$FileNameNow"-XXXX)"
    [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
    debug "Created a temporary comskip markupstop file: '$MARKUPSTOP_TMP'"
    declare -gr MARKUPSTOP_TMP

    #Output commercial data to initial files
    printf '%s\n' "${startdata[@]}" > "$MARKUPSTART_TMP"
    printf '%s\n' "${stopdata[@]}"  > "$MARKUPSTOP_TMP"
    #Combine commercial data into a single comskip file and remove the initial files
    generate_comskip
  fi

  #TODO: Consider making all the vars set here readonly "declare -r ", even if that means renaming
  #  and tracking down the various inconsistent uses... NOTE: must do in non-python GetMythTV... as well.
  #GuideTitle InputTitle => Title #Can be Series or Movie or ...
  #GuideSubtitle InputSubtitle ExtractPlotSubtitle SxxExxSubtitle FuzzyPlotSubtitle nlpPlotSubtitle => EpisodeTitle
  #GuideSeasonNum InputSeasonNum LogicSubtitleSeasonNum FuzzySubtitleSeasonNum FuzzyPlotSeasonNum nlpPlotSeasonNum => EpisodeSeasonNum
  #GuideEpisodeNum InputEpisodeNum LogicSubtitleEpisodeNum FuzzySubtitleEpisodeNum FuzzyPlotEpisodeNum nlpPlotEpisodeNum => EpisodeEpisodeNum

  debug 'Setting the following variables based on MythTV-DB guide data:'
  #Import mythtv values into myth2kodi values, don't clobber myth2kodi args title, subtitle, season-number, or episode-number.
  [[ -z "$InputTitle" ]]      && InputTitle="$title"        && debugcont "InputTitle=$title"
  [[ -z "$InputSubtitle" ]]   && InputSubtitle="$subtitle"  && debugcont "InputSubtitle=$subtitle"
  [[ -z "$InputSeasonNum" ]]  && InputSeasonNum="$season"   && debugcont "InputSeasonNum=$season"
  [[ -z "$InputEpisodeNum" ]] && InputEpisodeNum="$episode" && debugcont "InputEpisodeNum=$episode"
  #Support for the --movie flag
  [[ -z "$ShowCategory" ]]    && ShowCategory="$category"   && debugcont "ShowCategory=$category"

  #redefine database var names into myth2kodi var names
  MovieAirDate="$airdate"            && debugcont "MovieAirDate=$airdate"
  OriginalAirDate="$originalairdate" && debugcont "OriginalAirDate=$originalairdate"
  StorageGroup="$storagegroup"       && debugcont "StorageGroup=$storagegroup"
  Stars="$stars"                     && debugcont "Stars=$stars"
  Plot="$description"                && debugcont "Plot=$description"
  LocalSeriesID="$seriesid"          && debugcont "LocalSeriesID=$seriesid"
  ProgramID="$programid"             && debugcont "ProgramID=$programid"
  ChanID="$chanid"                   && debugcont "ChanID=$chanid"
  ShowStartTime="$starttime"         && debugcont "ShowStartTime=$starttime"
  XMLTVGrabber="$xmltvgrabber"       && debugcont "XMLTVGrabber=$xmltvgrabber"

  #If we're not in debug mode then clean-up the file written by mythdb_access
  if (( LOGLEVEL < 3 )) ; then
    rm -f "$MTV_RECINFO_FILE"
  else
    debug "Not removing the temporary MythTV-DB info file: '$MTV_RECINFO_FILE'"
  fi
}

#####PROCESS MythTV DATABASE INFORMATION#####

#Gather information from the MythTV database based on user settings.
process_mythtvdb(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"

  if [[ "$Database" = 'Enabled' ]]; then
    #Access the database entry using the requested grabber
    case "$DATABASE_ACCESS" in
      MySQL)
        get_mythtvdb_info_mysql
        ;;
      PythonBindings)
        get_mythtvdb_info_pythonbindings
        returnstatus="$?"
        if [[ "$returnstatus" != 0 ]]; then
          NOTIFY_MSG="Call to MythTV-DB Python bindings failed."
          EXIT_JOB_TYPE='MythTVdatabaseFailure'
          return 1
        fi
        ;;
      *)
        NOTIFY_MSG="DATABASE_ACCESS incorrectly specified."
        err "${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
        EXIT_JOB_TYPE='UserSettingError'
        return 1
        ;;
    esac

    #Do appropriate, guide-data specific, processing.
    case "$GuideDataType" in
      SchedulesDirect)
        process_mythtvdb_schedulesdirect
        ;;
      NoLookup)
        process_mythtvdb_nolookup
        ;;
      SydFTA)
        process_mythtvdb_sydfta
        ;;
      *)
        warn "GuideDataType incorrectly specified, processing MythTV database info assuming SchedulesDirect."
        process_mythtvdb_schedulesdirect
        ;;
    esac
    if [[ -z "$InputTitle" ]]; then
      NOTIFY_MSG="Failed to determine InputTitle from MythTV-DB, and none provided."
      err "${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
      EXIT_JOB_TYPE='NameCouldNotBeAssigned'
      return 1
    fi
  else
    if [[ -z "$InputTitle" ]]; then
      NOTIFY_MSG="Database disabled and no InputTitle provided on command line."
      err "${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
      EXIT_JOB_TYPE='InsufficientInformationProvided'
      return 1
    fi
  fi
  return 0
}

#Processes Zap2it/SchedulesDirect/Tribune data for use in the program
process_mythtvdb_schedulesdirect(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform "Processing MythTV database info as SchedulesDirect."
  #Check for database permissions
  [[ "$ChanID" = "" ]] && err "%%%% NO DATABASE INFORMATION. CHECK LOGIN/PASS OR FILE %%%%"
  #disqualify invalid movie airdates
  [[ ! -z "$MovieAirDate" ]] && ((MovieAirDate < 1900 )) && MovieAirDate=''

  [[ "$OriginalAirDate" = "None" ]] && OriginalAirDate=""
  [[ "$OriginalAirDate" = "none" ]] && OriginalAirDate=""

  #Get rating from Stars
  rating=$(printf "%0.f" "$Stars")
  [[ "$rating" != "" ]] && let rating=$rating*2
  [[ "$rating" = "" ]] && rating=1

  #Create MV/EP/SH Identification Type from ProgramID
  m2kProgramIDCheck="${ProgramID:0:2}"

  #Extrapolate data from Programid
  test "$m2kProgramIDCheck" = "SH" && ProgramIDType="Generic Episode With No Data"
  test "$m2kProgramIDCheck" = "MV" && ProgramIDType="Movie"
  test "$m2kProgramIDCheck" = "EP" && ProgramIDType="Series With Episode Data"
  test "$m2kProgramIDCheck" = "SP" && ProgramIDType="Sports Programming" && m2kProgramIDCheck=SH

  #account for .0123's in EITonly data type
  ProgramID="$(cut -f1 -d"." <<< "$ProgramID")"

  #Check if database contains enough information to put into doover que
  GoForDoover=0
  test "${x:0:2}" = "EP" && echo woot
  test "$EpisodeSubtitle" != "" && GoForDoover=1

  #Get barebones zap2it series id.
  Zap2itSeriesID=$(echo "$ProgramID" | tr -d MVSHEP | sed 's/0*//' | sed 's/.\{4\}$//')

  #strip needless chars from date
  datehour=$(echo "$ShowStartTime" | tr ":" "." | tr " " "@")
  #get 4 digit year
  seasonyear="${ShowStartTime:0:4}"

  #predefined naming conventions
  if [[ "$ShowCategory" =~ ^('Sports event'|'News'|'Newsmagazine')$ ]]; then
    NamingConvention="$ShowCategory"
  fi

  #If news, bypass Categoric naming convention 1
  test NamingConvention="News" && UseMethod2=1

  return 0
}

#Use regex to check for and make use of SxxExx info in Plot.
get_sxxexx_from_plot(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "SeasonEpisode: $SeasonEpisode"
  debugcont "InputSeasonNum: $InputSeasonNum"
  debugcont "InputEpisodeNum: $InputEpisodeNum"
  debugcont "Plot: $Plot"
  #TODO: Maybe add warning in the case of 4x4 in case it's not actually an SxxExx
  #If available use the season and episode fields from MythTV database, otherwise,
  #use or attempt to determine $SeasonEpisode
  #extract a season number Sxx and episode number Exx
  #Assumes season and episode numbers in range 1-99
  if [[ -z "$SeasonEpisode" && -z "$InputSeasonNum" && -z "$InputEpisodeNum" ]]; then
    debug 'Searching Plot for season & episode information.'
    #Check the Plot field for the SeasonEpisode info, SBS is big on
    #including it in the plot/description field instead of where it belongs
    #The below should work for any of the following forms:
    #S01E42 | (01x42) | s01e42 | 1X2 | S1E4 | (S01Ep42) | (S1Ep42) | 42x1 | (S.01Ep.42) | (S.01,Ep.42) | S1 E42
    SeasonEpisode="$(grep -E -i --only-matching '(s\.?[0-9]?[0-9]\,?\s?(e|ep)\.?[0-9][0-9]?)|([0-9]?[0-9]x[0-9][0-9]?)' <<< "$Plot")"
  fi
  if [[ -n "$InputSeasonNum" && -n "$InputEpisodeNum" ]]; then
    debug 'Using season & episode information from MythTV-DB season & episode fields.'
    Sxx="$InputSeasonNum"
    Exx="$InputEpisodeNum"
  elif [[ -n "$SeasonEpisode" ]]; then
    debug 'Extracted season & episode information from Plot.'
    Sxx="$(echo "$SeasonEpisode" | grep -E -i --only-matching '(s\.?[0-9]?[0-9])|([0-9]?[0-9]x)' | sed 's/s\.\?\|x//I')"
    Exx="$(echo "$SeasonEpisode" | grep -E -i --only-matching '((e|ep)\.?[0-9][0-9]?)|(x[0-9][0-9]?)' | sed 's/\(E\.\?\|Ep\.\?\)\|x//I')"
    #Strip leading zero
    Sxx="${Sxx#0}"
    Exx="${Exx#0}"
  else
    debug "${FUNCNAME[0]}() No Season & Episode number information is available."
    return 1
  fi
  #Single digit episode and show names are not allowed Ex and Sx replaced with Sxx Exx
  if (( Sxx < 10 )); then Sxx="S0$Sxx"; else Sxx="S$Sxx"; fi
  if (( Exx < 10 )); then Exx="E0$Exx"; else Exx="E$Exx"; fi
  inform "Found Season ($Sxx) & Episode ($Exx) information."
  return 0
}

#If we already have season and episode info, remove it from the Plot field.
remove_sxxexx_from_plot(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [[ -n "$SeasonEpisode" ]]; then
    #Check if it's in the leading position and if so, remove it

    # local SEregex
    # local SEstring
    # SEregex="'(\(?s\.?[0-9]?[0-9]\,?\s?(e|ep)\.?[0-9][0-9]?\)?)\s*|(\(?[0-9]?[0-9]x[0-9][0-9]?\)?)\s*'"
    # SEstring="$(grep -E -i --only-matching "$SEregex" <<< "$Plot")"

    local SEstring
    SEstring="$(grep -E -i --only-matching '(\(?s\.?[0-9]?[0-9]\,?\s?(e|ep)\.?[0-9][0-9]?\)?)\s*|(\(?[0-9]?[0-9]x[0-9][0-9]?\)?)\s*' <<< "$Plot")"
    if [[ -n "$SEstring" ]]; then
      warn "${FUNCNAME[0]}() SeasonEpisode found in Plot, removing it to simplify processing."
      Plot="${Plot/$SEstring/}"
      #Also remove any left over leading hyphen, colon, or space
      Plot="$(sed s/^"\s*[-|:]\?\s*"// <<< "$Plot")"
      #Remove any trailing space from the Plot
      Plot="${Plot%%*([[:space:]])}"
    fi
  else
    debug "SeasonEpisode isn't currently set:"
    debugcont "So, either it's not there or we haven't extracted it yet, not discarding from Plot field."
  fi
}

#Try to extract a subtitle from the plot field (Luv Ya SBS)
get_subtitle_from_plot(){
  #This function works under the assumption that a Subtitle (EpisodeTitle) is prepended to
  #the Plot field of the guide data and that it is separated from the actual plot by either
  #' -' or ':'. This is often the case for FTA guide data from SBS Australia, and occasionally
  #for other Australian stations as well.
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: Allowing for a colon as well as the hyphen here causes problems for the various "NCIS: some other place"
  #TODO: Probably should do things conditionally based on whether or not we actually managed
  #  to extract a Subtitle. And maybe return failure state.
  InputSubtitle="$(grep -E --only-matching '^((((\w+)(.?\s*))|(\&\s*)){1,7})( -|\:)' <<< "$Plot")"
  #if [[ -n "$InputSubtitle" ]]; then
  #Clean off the trailing " -" or ":" that we're using to identify it
  InputSubtitle="$(grep -E --only-matching '(((\w+)(.?\s*))|(\&\s*)){,7}(\w+)' <<< "$InputSubtitle")"
  debug "Attempt to extract Subtitle from Plot field gave '$InputSubtitle'"
  #TODO: consider calling remove_subtitle_from_plot() from here, instead of return 1 below.
  return 0
  #else
    #inform "No Subtitle extracted from Plot field.
    #return 1
  #fi
}

#Called after get_subtitle_from_plot(), it uses the same logic to...
remove_subtitle_from_plot(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: If we extracted a subtitle from Plot variable then remove that text from Plot.
  if [[ -n "$InputSubtitle" ]]; then
    local STstring
    STstring="$(grep -E --only-matching '^((((\w+)(.?\s*))|(\&\s*)){1,7})( -|\:)\s*' <<< "$Plot")"
    if [[ -n "$STstring" ]]; then
      warn "${FUNCNAME[0]}() Episode subtitle was in the Plot field, removing it to simplify subsequent processing."
      Plot="${Plot/$STstring/}"
    fi
  else
    debug "InputSubtitle isn't currently set, so not going to discard it from Plot field."
  fi
}

#Some Australian channels (ABC, I'm looking at you), put cast info at the end of the Plot.
remove_cast_from_plot(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local CastString
  CastString="$(grep -iE --only-matching '\. CAST: ((\w+)(.?\s*)){1,8}$' <<< "$Plot")"
  if [[ -n "$CastString" ]]; then
    warn "${FUNCNAME[0]}() Plot field appears to contain Cast information, removing it to simplify subsequent processing."
    debug "Removing: '$CastString' from Plot."
    debugcont "Plot:$Plot"
    Plot="${Plot/$CastString/.}"
    debugcont "New Plot:$Plot"
  fi
}

#A Process function compatible with Sydney over the air data...
process_mythtvdb_sydfta(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform 'Processing MythTV database info as SydFTA.'
  #Check for database permissions
  [[ -z "$ChanID" ]] && err "IN: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(). NO DATABASE INFORMATION. CHECK LOGIN/PASS OR FILE"
  #disqualify invalid movie airdates
  [[ -n "$MovieAirDate" ]] && (( MovieAirDate < 1900 )) && MovieAirDate=''

  #We don't use these, but if they're "none" we still want them changed to ""
  [[ "${OriginalAirDate,,}" = 'none' ]] && OriginalAirDate=""

  #TODO:#NOTE: Stars field in SydFTA data tends to be empty, consider what to do here.
  #Get rating from Stars
  rating=$(printf "%0.f" "$Stars")
  [[ -n "$rating" ]] && let rating=$rating*2
  [[ -z "$rating" ]] && rating=1

  #TODO: Does this need to be more general, accounting for 00 | S0 | S00 | etc
  #  On the other hand, if it's reliably 0, then remove this and just
  #  change the conditionals to check for 0
  #  ((InputSeasonNum == 0))
  #Default value for season and episode numbers is 0, not $null or ""
  test "$InputSeasonNum" = 0 && InputSeasonNum=''
  test "$InputEpisodeNum" = 0 && InputEpisodeNum=''

  #Current (2016-08) issue from 7flix: description in Subtitle field, all-caps cast in Plot...
  #Longest actual subtitle I've seen so far is 84 characters. Rather than assuming Plot field
  #is garbage, we'll append the InputSubtitle field to the Plot -- this will almost certainly
  #prevent full Plot fuzzy match from succeeding but chunked match should still match effectively.
  if (( $(wc --chars <<< "$InputSubtitle") > 88 )) ; then #Probably not a subtitle.
    local PossiblePlot
    PossiblePlot="$InputSubtitle"
    warn "${FUNCNAME[0]}() InputSubtitle field from MythTV-DB appears to contain Plot information."
    debug "Plot: $Plot"
    debug "PossiblePlot: $PossiblePlot"
    warn "Resetting InputSubtitle to ''"
    InputSubtitle=''
    warn "Appending PossiblePlot to Plot."
    Plot="$Plot $PossiblePlot"
    debug "Plot: $Plot"
    debug "Full Plot match will almost certainly fail, though chunked match should still work."
  fi

  #The ProgramID field from FTA EPG data in Sydney?Australia? doesn't specify MV/EP/SH,
  #the Movie specification is "almost-always" found in the Category field of
  #the MythTV database. So, we'll use that.
  if [ "$ShowCategory" = "Movie" ]; then
    inform "Guide data for $InputTitle indicates a Movie."
    m2kProgramIDCheck="MV"
    if [[ -n "$InputSubtitle" ]]; then
      warn "${FUNCNAME[0]}() Guide data indicates that $InputTitle is a Movie, but has an InputSubtitle: $InputSubtitle"
      warn "Resetting InputSubtitle to ''"
      InputSubtitle=''
    fi
  else #For now assume that if it's not a Movie it's an episode of a series
    #TODO: For now we mainly/only record Movies and Episodes of TV series,
    #  so, this is an ok approximation, but should look through more EPG data
    #  and determine whether the Category field reliably distinguishes things
    #  like news, sport, etc
    m2kProgramIDCheck="EP"
  fi

  #TODO: Check the SeriesID field in MythTV-DB & see if we can make more
  #  sensible use of whatever it contains...

  #If the information is already available, set the Sxx & Exx variables
  if [ "$m2kProgramIDCheck" = "EP" ]; then
    debug "The MythTV Guide data Plot before we messed with it:"
    debugcont "Plot:$Plot"
    get_sxxexx_from_plot
    remove_sxxexx_from_plot
    #If we haven't set a Subtitle yet, try and get one from $Plot
    if [[ -z "$InputSubtitle" ]]; then
      get_subtitle_from_plot
      #TODO: Only makes sense to call remove_subtitle_from_plot if get_subtitle_from_plot found one.
      remove_subtitle_from_plot
    fi
    debug "The MythTV Guide data Plot after we messed with it:"
    debugcont "Plot:$Plot"
  fi

  #Remove hashtag reference/s from the Plot field #TODO: Will probably need to check and extend this.
  Plot="$(sed 's/\s#\w\{2,16\}//g' <<< "$Plot")"
  #And @mentions, at least SBS2 does this '@SBS2'
  Plot="$(sed 's/\s@\w\{2,16\}//g' <<< "$Plot")"
  #Some channels, particularly ABC, put cast info in the end of the plot field which can mess up fuzzy Plot matching
  remove_cast_from_plot

  #Only keep Alpha-numeric characters, space and the four chars & , . -
  Plot="$(sed -r 's/[^[:alnum:] &,.-]//g' <<< "$Plot")"

  #Strip the Movie: tag that some stations very helpfully put in the title field...
  if [ "$m2kProgramIDCheck" = "MV" ]; then
    InputTitle="$(sed 's/Movie:\s*//I' <<< "$InputTitle")"
  fi

  #TODO: If it's a movie, check Title and Plot for a release year, assuming format (YYYY) seems reasonable.
  #  If we find it, check its between 1942 & ThisYear, then store it and remove it from where we found it,
  #  especially important to remove from Title -- to avoid repetition in NewFileName if we use it to generate that name.

  #Extrapolate data from m2kProgramIDCheck
  test "$m2kProgramIDCheck" = "SH" && ProgramIDType="Generic Episode With No Data"
  test "$m2kProgramIDCheck" = "MV" && ProgramIDType="Movie"
  test "$m2kProgramIDCheck" = "EP" && ProgramIDType="Series With Episode Data"
  test "$m2kProgramIDCheck" = "SP" && ProgramIDType="Sports Programming" && m2kProgramIDCheck=SH

  #FTA stations providing a ProgramID use CRID: https://en.wikipedia.org/wiki/Crid
  #Remove the leading CRID://
  ProgramID="$(sed 's#crid://##I' <<< "$ProgramID")"
  #Extract the Authority, ie the station broadcasting the show
  ProgramAuthority="$(cut -f1 -d"/" <<< "$ProgramID")"
  #Extract the show specific information, removing the leading /
  ProgramData="$(sed "s#$ProgramAuthority/##" <<< "$ProgramID")"
  #Populate the ProgramID variable with the ProgramData field of CRID
  ProgramID="$ProgramData"
  #TODO: figure out if anything useful can actually be done with this ProgramID.

  #strip needless chars from date
  datehour="$(echo "$ShowStartTime" | tr ":" "." | tr " " "@")" #TODO: Consider getting rid of the @ from this, as it's used in file naming... Maybe _ instead

  #predefined naming conventions
  [[ "$ShowCategory" =~ ^(Sports event|News|Newsmagazine)$ ]] && NamingConvention="$ShowCategory"

  #If news, bypass Categoric naming convention 1
  test NamingConvention="News" && UseMethod2=1

  return 0
}

#NoLookup is an alternate mode where TheTVDB is not used for lookups
process_mythtvdb_nolookup(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform "Processing MythTV database info as NoLookup."
  #Check for database permissions
  test "$ChanID" = "" && err "%%%% NO DATABASE INFORMATION. CHECK LOGIN/PASS OR FILE %%%%"
  #disqualify invalid movie airdates
  [[ -n "$MovieAirDate" ]] && (( MovieAirDate < 1900 )) && MovieAirDate=''

  #Get rating from Stars
  rating=$(printf "%0.f" "$Stars")
  test "$rating" != "" && let rating=$rating*2
  test "$rating" = "" && rating=1

  #Create MV/EP/SH Identification Type from ProgramID
  m2kProgramIDCheck="${ProgramID:0:2}"

  #Spoof show as episode to avoid programid
  test "$m2kProgramIDCheck" = "EP" && ProgramIDType="Generic Episode With No Data" && m2kProgramIDCheck="SH"
  #Extrapolate data from Programid
  test "$m2kProgramIDCheck" = "SH" && ProgramIDType="Generic Episode With No Data"
  test "$m2kProgramIDCheck" = "MV" && ProgramIDType="Movie"
  test "$m2kProgramIDCheck" = "SP" && ProgramIDType="Sports Programming" && m2kProgramIDCheck=SH

  #account for .0123's in EITonly data type
  ProgramID=$(cut -f1 -d"." <<< "$ProgramID")

  #This probably isn't necessary, but adding it for the time-being match previous state. #SAK
  Zap2itSeriesID="$LocalSeriesID"

  #strip needless chars from date
  datehour=$(echo "$ShowStartTime" | tr ":" "." | tr " " "@")
  #get 4 digit year
  seasonyear="${ShowStartTime:0:4}"

  #predefined naming conventions
  [[ "$ShowCategory" =~ ^(Sports event|News|Newsmagazine)$ ]] && NamingConvention="$ShowCategory"

  #If news, bypass Categoric naming convention 1
  test NamingConvention="News" && UseMethod2=1

  return 0
}

#Remove recording's pictures and database entries from MythTV-DB.
#Thanks to barney_1.
delete_mythtv_database_entry(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debug "InputPath: $InputPath"
  debug "InputFileBasename: $InputFileBasename"
  debug "MySQLuser: $MySQLuser"
  debug "MySQLpass: $MySQLpass"
  debug "MySQLMythDb: $MySQLMythDb"
  #Make sure we got input arguments and file is valid
  if [ ! -e "$InputPath" ]; then
    #Remove recording entry from mysql database
    inform "${FUNCNAME[0]}() REMOVING: $InputFileBasename; THUMBNAILS; DATABASE ENTRIES."
    mysql -u"$MySQLuser" -p"$MySQLpass" -e "USE $MySQLMythDb ; DELETE FROM recorded WHERE basename LIKE '$InputFileBasename' ; "
    if [[ "$?" != 0 ]]; then
      err "${FUNCNAME[0]}(): Failed to delete DB entry for: $InputFileBasename"
      return 1
    fi
    #Remove thumbnails
    rm -f "$InputPath".*
  else
    warn "File still exists: $InputPath"
    warncont "Not removing MythTV-DB information."
    return 1
  fi
  return 0
}

#Use AbsoluteEpisodeNumber to set Sxx and Exx
set_sxxexx_absolute_episode_number(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #if line match is obtained, then gather new episode name, Sxx and Exx
  EpisodeSubtitle="$(sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir/$NewShowName/$NewShowName.actualEname.txt")"

  #gather series and episode names from files created earlier.
  Exx="$(sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir/$NewShowName/$NewShowName.E.txt")"
  Sxx="$(sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir/$NewShowName/$NewShowName.S.txt")"
  [[ -n "$Sxx" ]] && SeasonNumber="$Sxx"

  #Single digit episode and show names are not allowed Ex and Sx replaced with Exx Sxx
  if ((Exx < 10)); then Exx="E0$Exx"; else Exx="E$Exx"; fi
  if ((Sxx < 10)); then Sxx="S0$Sxx"; else Sxx="S$Sxx"; fi
  inform "EPISODE:$EpisodeSubtitle EPISODE NUMBER:$AbsoluteEpisodeNumber $Sxx$Exx WITH CONFIDENCE: $EpisodeConfidenceRating"
}

#Check whether TheTVDB has updated information relative to myth2kodi's DB.
check_m2k_database_up_to_date(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Return state = 1 means the local database should be updated from TheTVDB
  #Return state = 0 means the local database is up to date with TheTVDB
  local updates_site='http://www.thetvdb.com/api/Updates.php'
  local dbdir="$m2kdir/$NewShowName"

  #Get current server time
  curl -L -s -m"$Timeout" "${updates_site}?type=none" > "$dbdir/TheTVDB_current.time"

  #Get the time from the file
  CurrentTimeTVDB=$(grep '<Time>' "$dbdir/TheTVDB_current.time" | sed -r 's#</?Time>##g')
  #if time server is down, then just update #TODO: If the Updates part of the api isn't working we probably shouldn't expect the rest to...
  [[ -z "$CurrentTimeTVDB" ]] && warn "${FUNCNAME[0]}() TheTVDB TIME SERVER WAS DOWN" && return 1

  #If file exist for last updated time, then get value
  if [ -f "$dbdir/lastupdated.time" ]; then
    LastUpdatedTVDB=$(cat "$dbdir/lastupdated.time")
  else #no last updated time, so assign a never updated value and update now.
    inform "Seems we've never updated $NewShowName from TheTVDB -- no lastupdated.time file."
    LastUpdatedTVDB=42 #A meaningless low number to start from...
    return 1
  fi

  #Apply Database Update interval to last update time LastUpdatedTVDB = NextUpdated
  local -i NextUpdate=0
  NextUpdate=$((LastUpdatedTVDB + UpdateDatabase))

  #if episode information is out of date or not created
  if ((CurrentTimeTVDB > NextUpdate)); then
    #TODO: the Updates part of TheTVDb v1 api is deprecated, for that matter so is
    #      the v1 api... Need to implement access to the new JSON based v2 api...
    #      See:
    #          https://api.thetvdb.com/swagger
    warn "Bypassing TheTVDB LatUpdated checks... Forcing update. See #TODO: Line $LINENO"
    return 1
    ##########################################################################
    curl -L -s -m"$Timeout" "${updates_site}?type=all&time=$LastUpdatedTVDB" > "$dbdir/UpdatesList.txt"
    if grep -q "$SeriesID" "$dbdir/UpdatesList.txt" ; then
      inform "DATABASE OUT OF DATE. Next update: $NextUpdate. Current: $CurrentTimeTVDB"
      return 1
    else
      debug "TheTVDB doesn't appear to have any updates for $NewShowName."
      #TODO: SeriesID isn't being found in UpdatesList for Grey's Anatomy, Marvel's Agents of S.H.I.E.L.D., and possibly others, so the the local data isn't being updated
      #inform "DATABASE DOESN'T APPEAR TO BE OUT OF DATE. BUT UNFORTUNATELY WE CURRENTLY HAVE A BUG HERE SO ARE FORCING UPDATE ANYWAY..."
      #return 1 #TODO: This is a current work around for some Series not being found in the UpdatesList from thetvdb, even though updated data is available...
      return 0
    fi
  #Send report to the log if database was not updated.
  elif ((CurrentTimeTVDB <= NextUpdate)); then
    inform "DATABASE MAINTAINED. Current: $CurrentTimeTVDB. Next update: $NextUpdate."
    return 0
  fi
  #some other condition was present. update anyways.
  return 1
}

#Download series information from TheTVDB and tvmaze servers for the
#currently matched series, then use that information to generate
#myth2kodi's internal database files for the series.
download_series_info(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform "Downloading Series: $SeriesID"
  local -i GotNewInformation=0
  local -i ProcessingSuccesful=0
  local dbdir="$m2kdir/$NewShowName"
  local TheTVDBShowXML="http://www.thetvdb.com/api/$APIkey/series/$SeriesID/all/$Language.xml"
  local FieldsWeWant="(</?Series>|</?seriesid>|</?Status>|</?lastupdated>|</?Episode>|</?SeasonNumber>|</?EpisodeNumber>|</?EpisodeName>|</?Overview>|</?FirstAired>)"
  curl -L -s -m"$Timeout" "$TheTVDBShowXML" | grep -E "$FieldsWeWant" > "$dbdir/$NewShowName.xmlTest"
  [[ $? != 0 ]] && warn "Issue accessing: $TheTVDBShowXML"

  local -i tvmaze_id
  tvmaze_id=$(curl -L -s -m"$Timeout" http://api.tvmaze.com/lookup/shows?thetvdb="$SeriesID" | jq '.id')
  local tvmazeJsonFile="$dbdir/${NewShowName}_tvmaze.json"
  # to get the matching tvmaze id, then
  if ((tvmaze_id != 0)) ; then
    debug "Found matchiong tvmaze id: $tvmaze_id"
    local tvmazeShowJson="http://api.tvmaze.com/shows/$tvmaze_id/episodes"
    [[ -f "$tvmazeJsonFile" ]] && mv "$tvmazeJsonFile" "$dbdir/${Today}_${NewShowName}_tvmaze.json"
    debug "Getting new tvmaze show info from: $tvmazeShowJson"
    curl -L -s -m"$Timeout" "$tvmazeShowJson" > "$tvmazeJsonFile"
  fi

  #Validate that the show has at least one EpisodeName tag and is a valid download before clobbering our old download.
  if grep -q "EpisodeName" "$dbdir/$NewShowName.xmlTest"; then
    printf '%s\n' "$(date +%s)" > "$dbdir/lastupdated.time" && chmod 666 "$dbdir/lastupdated.time"
    #Check the new info is actually new, if there was no old info then it must be new.
    if [ -f "$dbdir/$NewShowName.xml" ] ; then
      diff "$dbdir/$NewShowName.xmlTest" "$dbdir/$NewShowName.xml" &> /dev/null
      GotNewInformation="$?" #NOTE: No-diff = 0; diff = 1; error = 2
    else
      GotNewInformation=1
    fi
    if [ "$GotNewInformation" = "1" ] ; then
      #Clear out the old
      inform "Downloaded new information for $NewShowName"
      inform 'Cleaning up old information before processing.'
      test -f "$dbdir/$NewShowName.xml" && mv "$dbdir/$NewShowName.xml" "$dbdir/${Today}_$NewShowName.xml"
      mv "$dbdir/$NewShowName.xmlTest" "$dbdir/$NewShowName.xml"
      test -f "$dbdir/$NewShowName.actualEname.txt" && rm -f "$dbdir/$NewShowName.actualEname.txt"
      test -f "$dbdir/$NewShowName.Ename.txt"       && rm -f "$dbdir/$NewShowName.Ename.txt"
      test -f "$dbdir/$NewShowName.FAired.txt"      && rm -f "$dbdir/$NewShowName.FAired.txt"
      test -f "$dbdir/$NewShowName.S.txt"           && rm -f "$dbdir/$NewShowName.S.txt"
      test -f "$dbdir/$NewShowName.E.txt"           && rm -f "$dbdir/$NewShowName.E.txt"
      test -f "$dbdir/$NewShowName.Plot.txt"        && rm -f "$dbdir/$NewShowName.Plot.txt"

      #create a folder/file "database" Strip XML tags. Series, Exx and Sxx are separated into different files
      local Ename=""
      local actualEname=""
      local FAired=""
      local SeasonNr=""
      local EpisodeNr=""
      local EpisodeOverview=""
      local -i recordNumber=-1
      inform "Parsing Downloaded information from TheTVDB: $NewShowName.xml"
      while read -r line ; do
        if ((recordNumber < 0)); then
          #TODO: Grab the Series description and first aired date, either here or in download_series_identification(), for use in series NFO
          #TODO:Check for a Status line and if it exists and says Ended then touch
          #  a file called Status.Ended in the $m2kdir/$NewShowName/
          #  directory, then add a check for this before we bother trying to
          #  download information again. Also, use the lastupdated field if present.
          #Skip lines until the end series block tag is found, then start processing the episode info
          [[ "$line" == "</Series>" ]] && recordNumber=0
        elif [[ "$line" == "</Episode>" ]]; then
          (( ++recordNumber ))
          #Write Episode info to files
          debug "Building Record:$recordNumber -${actualEname}-"
          printf '%s\n' "$actualEname"     >> "$dbdir/$NewShowName.actualEname.txt"
          printf '%s\n' "$Ename"           >> "$dbdir/$NewShowName.Ename.txt"
          printf '%s\n' "$FAired"          >> "$dbdir/$NewShowName.FAired.txt"
          printf '%s\n' "$SeasonNr"        >> "$dbdir/$NewShowName.S.txt"
          printf '%s\n' "$EpisodeNr"       >> "$dbdir/$NewShowName.E.txt"
          printf '%s\n' "$EpisodeOverview" >> "$dbdir/$NewShowName.Plot.txt"
        #Get actual show name
        elif [[ "$line" == "<EpisodeName>"* ]]; then
          line="${line/"</EpisodeName>"/}"
          line="${line/<EpisodeName>/}"
          line="${line//&lt;/}"
          line="${line//&gt;/}"
          line="${line//&quot;/}"
          line="${line//&amp;/&}"
          line="${line//&ndash;/-}"
          actualEname="${line}"
          #Only keep Alpha-numeric characters, space, parenthesis and the four chars & , . -
          actualEname="$(sed -r 's/[^[:alnum:] &,.)(-]//g' <<< "$actualEname")"
          Ename="${actualEname/;*/}" #TODO: This strips everything following the first ";" (semi-colon). Is that intentional because there are sometimes multiple EpisodeNames separated by semi-colons???
          #Only keep Alpha-numeric characters, space, parenthesis and the four chars & , . -
          Ename="$(sed -r 's/[^[:alnum:] &,.)(-]//g' <<< "$Ename")"
        #Get OriginalAirDate
        elif [[ "$line" == "<FirstAired>"* ]]; then
          line="${line/"</FirstAired>"/}"
          line="${line/<FirstAired>/}"
          FAired="$line"
        #Get Season number
        elif [[ "$line" == "<SeasonNumber>"* ]]; then
          line="${line/"</SeasonNumber>"/}"
          line="${line/<SeasonNumber>/}"
          SeasonNr="$line"
        #Get Episode number
        elif [[ "$line" == "<EpisodeNumber>"* ]]; then
          line="${line/"</EpisodeNumber>"/}"
          line="${line/<EpisodeNumber>/}"
          EpisodeNr="$line"
        #Get Episode Overview
        elif [[ "$line" == "<Overview>"* ]]; then
          line="${line/"</Overview>"/}"
          line="${line/<Overview>/}"
          line="${line//&lt;/}"
          line="${line//&gt;/}"
          line="${line//&quot;/}"
          line="${line//&amp;/&}"
          line="${line//&ndash;/-}"
          #Convert any unprintable (space, tab, newline) to space.
          line="${line//[[:space:]]/ }"
          #Only keep Alpha-numeric characters, space and the four chars & , . -
          line="$(sed -r 's/[^[:alnum:] &,.-]//g' <<< "$line")"
          line="$(tr -s ' ' <<< "$line")"
          #Remove any trailing space
          line="${line%%*([[:space:]])}"
          EpisodeOverview="$line"
        fi
      done < "$dbdir/$NewShowName.xml"

      #If we also have a json file from tvmaze, then append that info
      if [[ -f "$tvmazeJsonFile" ]] ; then
        jq -r '.[] | .name'   "$tvmazeJsonFile" >> "$dbdir/$NewShowName.actualEname.txt"
        jq -r '.[] | .name'   "$tvmazeJsonFile" >> "$dbdir/$NewShowName.Ename.txt"
        jq -r '.[] | .season' "$tvmazeJsonFile" >> "$dbdir/$NewShowName.S.txt"
        jq -r '.[] | .number' "$tvmazeJsonFile" >> "$dbdir/$NewShowName.E.txt"
        local -i EpisodeCount
        EpisodeCount=$(jq -r '.[] | .name' "$tvmazeJsonFile" | wc -l)
        for i in $(seq 0 $((EpisodeCount-1))); do
          jq -r ".[$i] | .summary" "$tvmazeJsonFile" \
              | tr -d "\n"                           \
              | sed -r 's#</?p>##g'                  \
              | sed -r 's/[^[:alnum:] &,.-]//g'      \
              | tr -s ' ' >> "$dbdir/$NewShowName.Plot.txt"
          printf '\n' >> "$dbdir/$NewShowName.Plot.txt"
        done
      fi

      chmod 666 "$dbdir/$NewShowName.actualEname.txt"
      chmod 666 "$dbdir/$NewShowName.Ename.txt"
      chmod 666 "$dbdir/$NewShowName.FAired.txt"
      chmod 666 "$dbdir/$NewShowName.S.txt"
      chmod 666 "$dbdir/$NewShowName.E.txt"
      chmod 666 "$dbdir/$NewShowName.Plot.txt"
      ProcessingSuccesful=1

    elif [ "$GotNewInformation" = "2" ]; then
      err "${FUNCNAME[0]}() UNEXPECTED ERROR comparing new to old information for $NewShowName"
      return 1
    elif [ "$GotNewInformation" = "0" ]; then
      inform "TheTVDB information for $NewShowName hasn't changed since last download."
      return 0
    fi
  else
    warn "${FUNCNAME[0]}() COULD NOT DOWNLOAD: $TheTVDBShowXML"
  fi
  #check if files were created and generate message
  if ((ProcessingSuccesful == 1)) ; then
    inform "LOCAL DATABASE UPDATED: $dbdir"
    return 0
  elif [ ! -f "$dbdir/$NewShowName.Ename.txt" ]; then
    err "${FUNCNAME[0]}() PERMISSION ERROR for $dbdir"
    return 1
  fi
  return 1
}

#Set the serieslinenumber by matching the Zap2itSeriesID from MythTV-DB
#against the zap2it ids returned by querying TheTVDB.
get_serieslinenumber_zap2itid(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local Zap2ItTest
  serieslinenumber=0
  #loop through all show names received by TheTVDB and match Zap2it ID.
  while read -r line ; do
    (( ++serieslinenumber ))
    debug "TESTING FOR ZAP2ITID MATCH:$line $(sed -n "$serieslinenumber"'p' "$TMP_SHN_FILE")"
    Zap2ItTest="$(echo "$line" | tr -d MVSHEP | sed 's/0*//')"
    if [[ "$Zap2ItTest" = "$Zap2itSeriesID" ]]; then
      inform "Found ZAP2ITID match: $line $(sed -n "$serieslinenumber"'p' "$TMP_SHN_FILE")"
      return 0
    fi
  done < "$TMP_ZAP2IT_FILE"
  warn "${FUNCNAME[0]}() couldn't find serieslinenumber with Zap2itSeriesID"
  serieslinenumber=0
  return 1
}

#Set the serieslinenumber by fuzzy logic matching the current ShowName
#variable against show names returned by querying TheTVDB.
get_serieslinenumber_showname_fuzzy(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: Why the restriction to the first 27 characters for matching here???
  serieslinenumber=$(agrep -Byn "${ShowName:0:27}" "$TMP_SHN_FILE" | sed 's/:.*//' | grep -m1 ^)
  #Correct for serieslinenumber = ""
  [[ -z "$serieslinenumber" ]] && serieslinenumber=0

  #Get the seriesid based on the showname
  if ((serieslinenumber > 0)); then
    debug "Determined serieslinenumber for ShowName: $ShowName"
    return 0
  fi
  err "${FUNCNAME[0]}() FAILED to determine serieslinenumber for ShowName: $ShowName"
  return 1
}

#Set the serieslinenumber by matching the current ShowName variable
#against show names returned by querying TheTVDB.
get_serieslinenumber_showname(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  serieslinenumber="$(grep -nix "$ShowName" "$TMP_SHN_FILE" | sed 's/:.*//' | grep -m1 ^)"

  #Correct for serieslinenumber = ""
  [[ -z "$serieslinenumber" ]] && serieslinenumber=0
  #Get the seriesid based on the showname
  if ((serieslinenumber >= 1)); then return 0; else return 1; fi
}

#Resolve multiple matches on the same airdate, the conflict is
#resolved by matching the airdate by title.
resolve_multiple_matches_airdate(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local NewShowBasename="$m2kdir/$NewShowName/$NewShowName"
  #Cleanup from last instance match if required
  ConfidenceReasoning="$ConfidenceReasoning Conflict; Multiple Airdates Detected- Parsed results; Attempted to resolve conflict with Standard Logic:"
  test -f "$NewShowBasename.InstanceEnames.txt"            && rm "$NewShowBasename.InstanceEnames.txt"
  test -f "$NewShowBasename.InstanceFAiredLineNumbers.txt" && rm "$NewShowBasename.InstanceFAiredLineNumbers.txt"
  test -f "$NewShowBasename.InstanceLineNumbers.txt"       && rm "$NewShowBasename.InstanceLineNumbers.txt"
  #Create a list of line numbers which match original airdate
  grep -n "$OriginalAirDate" "$NewShowBasename.FAired.txt" | sed 's/:.*//'>>"$NewShowBasename.InstanceFAiredLineNumbers.txt"
  #Loop through list and create instance matching files
  while read -r line ; do
    echo "$line" >>"$NewShowBasename.InstanceLineNumbers.txt"
    sed -n "$line"'p' "$NewShowBasename.Ename.txt" >> "$NewShowBasename.InstanceEnames.txt"
  done < "$NewShowBasename.InstanceFAiredLineNumbers.txt"

  #get instance line number
  IntermediateEpisodeNumber=$(grep -ni "$EpisodeSubtitle" "$NewShowBasename.InstanceEnames.txt" | grep -m1 ^ | sed 's/:.*//')
  #translate instance line number to actual line number
  if [[ -n "$IntermediateEpisodeNumber" ]]; then
    AbsoluteEpisodeNumber=$(sed -n "$IntermediateEpisodeNumber"'p' "$NewShowBasename.InstanceLineNumbers.txt")
  fi
  if [[ -n "$AbsoluteEpisodeNumber" ]]; then
    ConfidenceReasoning="$ConfidenceReasoning Successful;"
    return 0
  else
    ConfidenceReasoning="$ConfidenceReasoning Failed; Attempted to resolve conflict with Fuzzy Logic:"
    #get instance line number
    IntermediateEpisodeNumber=$(agrep -Byn "${EpisodeSubtitle:0:29}" "$NewShowBasename.InstanceEnames.txt" | grep -m1 ^ | sed 's/:.*//')
    #translate instance line number to actual line number
    if [[ -n "$IntermediateEpisodeNumber" ]]; then
      AbsoluteEpisodeNumber=$(sed -n "$IntermediateEpisodeNumber"'p' "$NewShowBasename.InstanceLineNumbers.txt")
    fi
    if [[ -n "$AbsoluteEpisodeNumber" ]]; then
      ConfidenceReasoning="$ConfidenceReasoning Successful;"
      return 0
    else
      ConfidenceReasoning="$ConfidenceReasoning Failed;"
      return 1
    fi
  fi
  return 1
}

#Create myth2kodi's internal database directory for the current show.
make_m2k_database_dir(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [ ! -d "$m2kdir/$NewShowName" ]; then
    mkdir "$m2kdir/$NewShowName"
    chmod 777 "$m2kdir/$NewShowName" #TODO: consider chmod 755
    inform "Created myth2kodi Database Folder: $m2kdir/$NewShowName"
  fi
}

#Sets the SeriesID and NewShowName variables based on serieslinenumber.
set_seriesid_newshowname_from_serieslinenumber(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Get the seriesid based on the showname
  SeriesID="$(sed -n "$serieslinenumber"'p' "$TMP_SID_FILE" | grep -m1 ^)"
  NewShowName="$(sed -n "$serieslinenumber"'p' "$TMP_SHN_FILE" | grep -m1 ^)"
  NewShowName="${NewShowName//&amp;/&}"

  #If we're not in debug mode then cleanup show identification files.
  [[ -f "$TMP_SID_FILE" ]] && (( LOGLEVEL < 3 )) && rm -f "$TMP_SID_FILE"
  [[ -f "$TMP_SHN_FILE" ]] && (( LOGLEVEL < 3 )) && rm -f "$TMP_SHN_FILE"
}

#Sets the AbsoluteEpisodeNumber variable by comparing OriginalAirDate
#against the first aired information in myth2kodi's local database.
set_absolute_episode_number_by_airdate(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  AbsoluteEpisodeNumber=""
  if [[ -n "$OriginalAirDate" ]]; then
    AbsoluteEpisodeNumber="$(grep -n "$OriginalAirDate" "$m2kdir/$NewShowName/$NewShowName.FAired.txt" | grep -m1 ^ | sed 's/:.*//')"
  fi
  #Account for original series airdate
  if [[ -n "$AbsoluteEpisodeNumber" ]] && ((AbsoluteEpisodeNumber > 0)); then
    local NumberOriginalAirdates
    #Account for original show airdate = first air date
    NumberOriginalAirdates=$(grep --count "$OriginalAirDate" "$m2kdir/$NewShowName/$NewShowName.FAired.txt")
    ((NumberOriginalAirdates > 1)) && return 1
    inform "Absolute Exx NR:$AbsoluteEpisodeNumber BASED ON AIRDATE:$OriginalAirDate"
    return 0
  fi
  return 2
}

#Set the AbsoluteEpisodeNumber by comparing Sxx and Exx against the
#series and episode number information in myth2kodi's local database.
set_absolute_episode_number_by_sxxexx(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber"
  debugcont "NewShowName: $NewShowName"
  debugcont "Sxx: $Sxx"
  debugcont "Exx: $Exx"

  AbsoluteEpisodeNumber=""
  local -a AENs
  #Strip the leading "S" and any leading "0" from Sxx
  local Snum=${Sxx#S} ; Snum=${Snum#0}
  #Strip the leading "E" and any leading "0" from Exx
  local Enum=${Exx#E} ; Enum=${Enum#0}
  local SxxAENs
  local ExxAENs
  SxxAENs=$(grep -nix "$Snum" "$m2kdir/$NewShowName/$NewShowName.S.txt" | sed 's/:.*//') #TODO: As far as I can tell we don't ever get ':' in season number, etc, yet these sed 's/:.*//' are everywhere???
  ExxAENs=$(grep -nix "$Enum" "$m2kdir/$NewShowName/$NewShowName.E.txt" | sed 's/:.*//')
  #With multiple data sources we can get multiple AENs, just take the first data source:
  AENs=($(sort --numeric-sort <<< "$(comm -12 <(sort <<< "$SxxAENs") <(sort <<< "$ExxAENs"))"))
  AbsoluteEpisodeNumber="${AENs[0]}"
  if [[ -n "$AbsoluteEpisodeNumber" ]] && ((AbsoluteEpisodeNumber > 0)); then
    inform "Using SxxExx, determined AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber"
    return 0
  fi
  warn "${FUNCNAME[0]}() Failed to determine AbsoluteEpisodeNumber"
  return 1
}

#Identify episode by fuzzy matching MythTV-DB Plot against Plots in myth2kodi-DB.
getAbsoluteEpisodeNumberWithFuzzyPlotMatch(){
  #TODO: Need to clean up redundancy or otherwise refactor this function to make it cleaner...
  #      Maybe fuzzy_plot_match(); chunked_fuzzy_plot_match(); multi_match_check(); then get_absolute_episode_number_fuzzy_plot() uses them...
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber"
  debugcont "NewShowName: $NewShowName"
  debugcont "Plot: $Plot"

  if [[ ! -f "$m2kdir/$NewShowName/$NewShowName.Plot.txt" ]]; then
    err "Myth2kodi's internal database contains no Plot information for $NewShowName."
    errcont "This probably means we failed to identify a SeriesID. Either you need"
    errcont "to add a showTranslation entry, we've mistaken a Movie for an Episode,"
    errcont "or this is a one off showing like news or a sports event."
   return 1
 fi

  AbsoluteEpisodeNumber=""
  #set IFS to use line break as a delineator -- necessary for separating multiple agrep matches below.
  local IFS=$'\n'
  local -i PlotLength
  local -a FuzzyPlot=()
  local -a AENguess=()
  local -a cost=()
  #Length of the plot we're trying to match
  PlotLength=$(wc --chars <<< "$Plot")
  debugcont "PlotLength: $PlotLength"
  #If Plot length is short this really won't work well, so give up #TODO: figure out what length is genuinely too short...
  ((PlotLength<42)) && warn "${FUNCNAME[0]}() - Plot is too short to attempt fuzzy guess." && return 1
  #Fuzzy guess at plot, prepended with: "AbsoluteEpisodeNumber:cost:"
  FuzzyPlot=($(agrep -ikByns "$Plot" "$m2kdir/$NewShowName/$NewShowName.Plot.txt"))
  [[ -z "${FuzzyPlot[0]}" ]] && warn "${FUNCNAME[0]}() - No fuzzy match on Plot" && return 1
  #Extract our guessed AbsoluteEpisodeNumber
  AENguess=($(cut -f1 -d":" <<< "$(printf '%s\n' "${FuzzyPlot[@]}")"))
  debugcont "$( IFS=','; printf '%s' "AbsoluteEpisodeNumber guess: ${AENguess[*]}." )"
  cost=($(cut -f2 -d":" <<< "$(printf '%s\n' "${FuzzyPlot[@]}")"))
  debugcont "$( IFS=','; printf '%s' "Cost: ${cost[*]}." )"
  local -a MatchedPlot=()
  for (( i = 0; i < ${#AENguess[@]}; i++ )) ; do
    MatchedPlot[i]="$(sed -n "${AENguess[i]}"'p' "$m2kdir/$NewShowName/$NewShowName.Plot.txt")"
    (( $(wc --chars <<< "${MatchedPlot[i]}") < PlotLength )) && warn "MatchedPlot $i shorter than Plot."
    debugcont "MatchedPlot $i: ${MatchedPlot[i]}"
  done
  #TODO: Should check that MatchedPlot is longer than PlotLength, which is essentially what we're assuming below.
  #If the cost is greater than a 1/3 of characters in the plot we're trying to match #TODO: figure out the critical ratio here.
  if (( cost[0] > (PlotLength / 3) )) ; then
    warn "${FUNCNAME[0]}() - AbsoluteEpisodeNumber guess from full Plot too fuzzy, trying chunked match."
    #Some Plots miss on match simply because the text is reordered or the middle is chopped out,
    #something as simple as chopping up the Plot into 8 word blocks, overlapping by 2-4, and testing
    #the agrep cost for each chunk, if at least a couple of the chunks match with a cost < say 10%
    #then we could be fairly confident that it's actually a matching Plot.
    local -i PlotWords
    PlotWords=$(wc --words <<< "$Plot")
    local chunk=""
    local -i chunck_size=8
    local -i chunk_overlap=4
    local -i numchunks
    numchunks=$((PlotWords/(chunck_size-chunk_overlap)))
    local -i len10per=0
    local -a fuzzychunk=()
    local -a FuzzyChunks=()
    local -a ChunkGuesses=()
    local -a ChunkCosts=()
    local -a ChunkLengths=()
    local -a GoodChunkGuesses=()
    debug "Attempting chunked fuzzy match."
    debugcont "PlotWords=$PlotWords"
    debugcont "chunck_size=$chunck_size"
    debugcont "chunk_overlap=$chunk_overlap"
    debugcont "numchunks=$numchunks"
    local -i Counter=0
    for (( i = 0; i < numchunks; i++ )) ; do
      debugcont "i=$i"
      n=$(((i)*(chunck_size-chunk_overlap)+1))
      debugcont "n=$n"
      m=$((n+chunck_size-1))
      debugcont "m=$m"
      chunk="$(cut -d" " -f$n-$m <<< "$Plot")"
      debugcont "chunk=$chunk"
      ChunkLengths[i]=$(wc --chars <<< "$chunk")
      debugcont "ChunkLengths[$i]=${ChunkLengths[i]}"
      len10per=$(( ChunkLengths[i] / 10 ))
      fuzzychunk=($(agrep -ikByns "$chunk" "$m2kdir/$NewShowName/$NewShowName.Plot.txt"))
      FuzzyChunks[i]="${fuzzychunk[0]}"
      debugcont "FuzzyChunks[$i]=${FuzzyChunks[i]}"
      ChunkGuesses[i]=$(cut -f1 -d":" <<< "${FuzzyChunks[i]}")
      debugcont "ChunkGuesses[$i]=${ChunkGuesses[i]}"
      ChunkCosts[i]=$(cut -f2 -d":" <<< "${FuzzyChunks[i]}")
      debugcont "ChunkCosts[$i]=${ChunkCosts[i]}"
      ((ChunkCosts[i] <= len10per)) && GoodChunkGuesses[Counter]=${ChunkGuesses[i]} && ((++Counter))
    done
    debug "$( IFS=','; printf '%s' "${FUNCNAME[0]}() - GoodChunkGuesses ${#GoodChunkGuesses[@]}: ${GoodChunkGuesses[*]}." )"
    #TODO: This needs to be changed to actually check that they refer to the same episode,
    #      with multiple data sources the current test is still sufficient but not necessary...
    #If all ChunkGuess with ChunkCost < 10% are the same Absolute Episode Number
    AENguess=($(printf '%s\n' "${GoodChunkGuesses[@]}" | sort -u))
    if (( ${#AENguess[@]} == 1 )) ; then
      AbsoluteEpisodeNumber="${AENguess[0]}"
      inform "${FUNCNAME[0]}() - Identified AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber using chunked Plot."
      return 0
    elif (( ${#AENguess[@]} > 1 )); then
      debug "Multiple AbsoluteEpisodeNumber guesses matched plot, confirming they're the same episode before using."
      #If we've identified multiple AbsoluteEpisodeNumbers make sure they refer to the same episode.
      local -a SxxGuesses=()
      local -a ExxGuesses=()
      for (( i = 0; i < ${#AENguess[@]}; i++ )) ; do
        #gather series and episode numbers for each AENguess.
        ExxGuesses[i]="$(sed -n "${AENguess[i]}"'p' "$m2kdir/$NewShowName/$NewShowName.E.txt")"
        SxxGuesses[i]="$(sed -n "${AENguess[i]}"'p' "$m2kdir/$NewShowName/$NewShowName.S.txt")"
      done
      local -i uniqExxcount
      local -i uniqSxxcount
      uniqExxcount=$(printf '%s\n' "${ExxGuesses[@]}" | uniq | wc -l)
      uniqSxxcount=$(printf '%s\n' "${SxxGuesses[@]}" | uniq | wc -l)
      if (( uniqSxxcount == 1 )) && (( uniqExxcount == 1 )); then
        #With multiple data sources we can get multiple AENs for the same episode, just take the first:
        AbsoluteEpisodeNumber=$(cut -f1 -d" " <<< "${AENguess[0]}")
        inform "${FUNCNAME[0]}() - Identified AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber using chunked Plot."
        debug "$( IFS=','; printf '%s' "${FUNCNAME[0]}() - The following ${#AENguess[@]} AENguesses were identified as the same episode: ${AENguess[*]}." )"
        return 0
      else
        debug "The AbsoluteEpisodeNumber guesses were different:"
        debugcont "AENguess = SxxGuesses, ExxGuesses"
        for (( i = 0; i < ${#AENguess[@]}; i++ )) ; do
          debugcont "${AENguess[i]} = ${SxxGuesses[i]}, ${ExxGuesses[i]}"
        done
      fi
    fi

    warn "${FUNCNAME[0]}() - Chunked Plot match is still too fuzzy, failed to guess AbsoluteEpisodeNumber."
    return 1
  fi

  #Guess at fuzzy Plot match is probably ok, we'll use it, but first need to confirm multiple results
  if (( ${#AENguess[@]} > 1 )); then
    #If we've identified multiple AbsoluteEpisodeNumbers make sure they refer to the same episode.
    local -a SxxGuesses=()
    local -a ExxGuesses=()
    for (( i = 0; i < ${#AENguess[@]}; i++ )) ; do
      #gather series and episode numbers for each AENguess.
      ExxGuesses[i]="$(sed -n "${AENguess[i]}"'p' "$m2kdir/$NewShowName/$NewShowName.E.txt")"
      SxxGuesses[i]="$(sed -n "${AENguess[i]}"'p' "$m2kdir/$NewShowName/$NewShowName.S.txt")"
    done
    local -i uniqExxcount
    local -i uniqSxxcount
    uniqExxcount=$(printf '%s\n' "${ExxGuesses[@]}" | uniq | wc -l)
    uniqSxxcount=$(printf '%s\n' "${SxxGuesses[@]}" | uniq | wc -l)
    if (( uniqSxxcount == 1 )) && (( uniqExxcount == 1 )); then
      #With multiple data sources we can get multiple AENs for the same episode, just take the first:
      AbsoluteEpisodeNumber=$(cut -f1 -d" " <<< "${AENguess[0]}")
      inform "${FUNCNAME[0]}() - Identified AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber using full Plot."
      debug "$( IFS=','; printf '%s' "${FUNCNAME[0]}() - The following ${#AENguess[@]} AENguesses were identified as the same episode: ${AENguess[*]}." )"
      return 0
    else
      warn "${FUNCNAME[0]}() - Fuzzy Plot match is too fuzzy, as we matched two or more different episodes."
      err "${FUNCNAME[0]}() - This function needs review as bad match on full plot should lead to chunked plot attempt."
      debug "$( IFS=','; printf '%s' "${FUNCNAME[0]}() - The following ${#AENguess[@]} AENguesses were identified: ${AENguess[*]}." )"
      return 1
    fi
  fi
  AbsoluteEpisodeNumber="${AENguess[0]}"
  inform "${FUNCNAME[0]}() - Identified AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber using full Plot."
  return 0
}

#Set the AbsoluteEpisodeNumber by matching EpisodeSubtitle against
#the episode names (Ename) in myth2kodi's local database.
set_absolute_episode_number_by_ename(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  AbsoluteEpisodeNumber=""
  AbsoluteEpisodeNumber=$(grep -nix "$EpisodeSubtitle" "$m2kdir/$NewShowName/$NewShowName.Ename.txt" | grep -m1 ^ | sed 's/:.*//')
  if [[ -n "$AbsoluteEpisodeNumber" ]] && ((AbsoluteEpisodeNumber > 0)); then
    return 0
  fi
  return 1
}

#Set the AbsoluteEpisodeNumber by fuzzy matching EpisodeSubtitle
#against the episode names (Ename) in myth2kodi's local database.
set_absolute_episode_number_by_ename_fuzzy(){
  #TODO: we need some sort of regex to account for matches like
  #    'The Office' 'The Delivery, Part Two' -guide data
  #    'The Office' 'The Delivery (2)'       -TvDb data
  #  currently, the former would be associated with 'The Delivery (1)'
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  AbsoluteEpisodeNumber=""
  AbsoluteEpisodeNumber=$(agrep -Byn "${EpisodeSubtitle:0:29}" "$m2kdir/$NewShowName/$NewShowName.Ename.txt" | grep -m1 ^ | sed 's/:.*//')
  if [[ -n "$AbsoluteEpisodeNumber" ]] && ((AbsoluteEpisodeNumber > 0)); then
    return 0
  fi
  return 1
}

#Search TheTVDB for this recording's show name, then use the response
#to generate temporary text files for subsequent show identification.
download_series_identification(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local -i NextShow=0
  inform "SEARCHING www.TheTVDB.com FOR $tvdbshowname"

  #Create temporary file to hold the show data from TheTVDB
  local WORKING_FILE
  WORKING_FILE="$(mktemp "$M2K_TMPDIR/m2k_working_$FileNameNow"-XXXX)"
  [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }

  #Search TheTVDB and return an XML file with results
  curl -L -s -m"$Timeout" "www.thetvdb.com/api/GetSeries.php?seriesname=$tvdbshowname" > "$WORKING_FILE"

  if (( $(wc --bytes < "$WORKING_FILE") == 0 )); then
    err "FUNCNAME[0]}(): Couldn't access info from TheTVDB."
    errcont "Check your internet connection."
    errcont "Check www.thetvdb.com for '$tvdbshowname'."
    return 1
  fi

  #Create temporary files to hold the show ID and show name
  TMP_SID_FILE="$(mktemp "$M2K_TMPDIR/m2k_sid_$FileNameNow"-XXXX)"
  [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
  TMP_SHN_FILE="$(mktemp "$M2K_TMPDIR/m2k_shn_$FileNameNow"-XXXX)"
  [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
  declare -gr TMP_SID_FILE TMP_SHN_FILE

  #Separate the XML into textual DBs containing SeriesID, ShowName and Zap2it IDs
  grep "<seriesid>" "$WORKING_FILE" | sed -e 's#</\?seriesid>##g' \
                                          -e 's/&quot;/"/g'       \
                                          -e 's/&amp;/\&/g'       \
                                          -e 's/&ndash;/-/g'      \
                                          -e 's/&lt;/</g'         \
                                          -e 's/&gt;/>/g' > "$TMP_SID_FILE"
  grep "<SeriesName>" "$WORKING_FILE" | sed -e 's#</\?SeriesName>##g' \
                                            -e 's/&quot;/"/g'         \
                                            -e 's/&amp;/\&/g'         \
                                            -e 's/&ndash;/-/g'        \
                                            -e 's/&lt;/</g'           \
                                            -e 's/&gt;/>/g' > "$TMP_SHN_FILE"

  #Create a temporary file to contain zap2it info
  TMP_ZAP2IT_FILE="$(mktemp "$M2K_TMPDIR/m2k_zap2it_$FileNameNow"-XXXX)"
  [[ "$?" != 0 ]] && { err "Failed to create temporary zap2it file." ; return 1 ; }
  declare -gr TMP_ZAP2IT_FILE
  debug "Created a temporary zap2it file: '$TMP_ZAP2IT_FILE'"

  #parse the XML for shows with Zap2ItIDs
  while read -r line ; do
    test "$line" = "<Series>" && NextShow=1
    if [[ "$line" = "</Series>" ]] && ((NextShow==1)); then
      printf '\n' >> "$TMP_ZAP2IT_FILE"
      NextShow=0
    fi

    if [[ "$line" =~ '<zap2it_id>'* ]] ; then
      echo "$line" | sed -e 's#</\?zap2it_id>##g' \
                         -e 's/&quot;/"/g'        \
                         -e 's/&amp;/\&/g'        \
                         -e 's/&ndash;/-/g'       \
                         -e 's/&lt;/</g'          \
                         -e 's/&gt;/>/g' >> "$TMP_ZAP2IT_FILE"
      NextShow=0
    fi
  done < "$WORKING_FILE"
  #If we're not in debug mode, remove the working file.
  if (( LOGLEVEL < 3 )); then
    rm -f "$WORKING_FILE"
  else
    debug "Not removing the temporary working file: '$WORKING_FILE'"
  fi
  return 0
}

#A special exit point for when we're processing testfile.ext
testfile_exit(){
  #TODO: Review this function
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  [[ "$Exx" != "E07" ]] && err 'FUZZY FAILURE' && exit 1
  [[ -d ./Episodes ]] && [[ ! "$(ls -A ./Episodes)" ]] && rmdir ./Episodes
  [[ -d ./Movies ]]   && [[ ! "$(ls -A ./Movies)" ]]   && rmdir ./Movies
  [[ -d ./Showings ]] && [[ ! "$(ls -A ./Showings)" ]] && rmdir ./Showings
  exit 0
}

#Increment the number contained in "$m2kdir/FuzzyLogicError.log"
increment_fuzzy_logic_error_count(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Initialise the total match count to zero if the file doesn't exist.
  if [[ ! -f "$m2kdir/FuzzyLogicError.log" ]]; then
    printf '%s\n' '0' > "$m2kdir/FuzzyLogicError.log"
  fi
  declare -gi FuzzyLogicError
  FuzzyLogicError="$(<"$m2kdir/FuzzyLogicError.log")"
  (( ++FuzzyLogicError ))
  printf '%s\n' "$FuzzyLogicError" > "$m2kdir/FuzzyLogicError.log"
}

#Increment the number contained in "$m2kdir/TotalEpisodeMatches.log"
increment_total_matches(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Initialise the total match count to zero if the file doesn't exist.
  if [[ ! -f "$m2kdir/TotalEpisodeMatches.log" ]]; then
    printf '%s\n' '0' > "$m2kdir/TotalEpisodeMatches.log"
  fi
  declare -gi FuzzyLogicMatches
  FuzzyLogicMatches="$(<"$m2kdir/TotalEpisodeMatches.log")"
  (( ++FuzzyLogicMatches ))
  printf '%s\n' "$FuzzyLogicMatches" > "$m2kdir/TotalEpisodeMatches.log"
}

#Check to see if a path/file is owned by $Librarian or at least that $Librarian
#has sufficient read-write permissions. If not, exit with a descriptive message.
check_path_permission(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "arg 1 = $1"
  (( "$#" > 1 )) && err "${FUNCNAME[0]}() only takes one arg."
  local PATH_TO_CHECK
  local PATH_OWNER
  local PATH_GROUP
  PATH_TO_CHECK="$1"
  inform "Checking permissions for: $PATH_TO_CHECK"

  #First check that the file or path actually exists
  if [[ ! -e "$PATH_TO_CHECK" ]]; then
    NOTIFY_MSG="Path or file doesn't exist: $PATH_TO_CHECK"
    err "${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    EXIT_JOB_TYPE='FileOrPathDoesNotExist'
    return 1
  fi
  PATH_OWNER="$(find "$PATH_TO_CHECK" -maxdepth 0 -printf %u)"
  PATH_GROUP="$(find "$PATH_TO_CHECK" -maxdepth 0 -printf %g)"

  #Log some ownership related info
  if [[ "$PATH_OWNER" = "$Librarian" ]]; then
    debug "Good start: $Librarian owns it."
  elif id -nG "$Librarian" | grep -qw "$PATH_GROUP"; then
    debug "May be ok: $Librarian is at least a member of the same group."
  else
    warn "$Librarian neither owns nor is a member of the group for $PATH_TO_CHECK."
  fi

  #At the least we'll need to be able to read the path or file
  if [[ ! -r "$PATH_TO_CHECK" ]]; then
    NOTIFY_MSG="Can't read: $PATH_TO_CHECK"
    err "${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    EXIT_JOB_TYPE='PermissionError'
    return 1
  fi

  #If we're moving the file we'll need write permission
  if [[ "$PROCESS_RECORDING_MODE" = "MOVE" ]]; then
    if [[ ! -w "$PATH_TO_CHECK" ]]; then
      NOTIFY_MSG="Can't write: $PATH_TO_CHECK"
      err "${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
      errcont "USER NAME:$CALLER ATTEMPTED TO MODIFY A $PATH_OWNER OWNED FILE."
      errcont "To preserve file permissions this has been prevented."
      EXIT_JOB_TYPE='PermissionError'
      return 1
    fi
  fi
  debug "Permissions ok for: $PATH_TO_CHECK"
  return 0
}

#An error message when we were called as a MythTV userjob from outside
#MythTV, then exit.
msg_userjob_outside_mythtv_error(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  NOTIFY_MSG="Called as MythTV user job outside of MythTV."
  err "${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
  errcont "MythTV User Job is only valid when run as a user job by MythTV."
  errcont "When outside MythTV call the file directly, see."
  errcont "  myth2kodi --usage"
  EXIT_JOB_TYPE='InvalidCall'
  return 1
}

#TODO: review this message function...
#A warning message for when m2kProgramIDCheck="SH"
msg_show_warning(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform     "Recording was tagged as a show, ie, not a movie or a."
  informcont "recognised episode of a series."
  informcont "TYPE: $ProgramIDType- $InputTitle, $InputSubtitle"
  warn "m2kProgramIDCheck='SH', this can occur due to incomplete guide data."
}

#A message for when we've successfully moved a recording.
msg_completed_move(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform "Move completed."
  informcont "Moved: $InputPath"
  informcont "To: $MoveDir/$ShowFileName.$OriginalExt"
  if [[ "$SYMLINK" != 'Disabled' ]]; then
    informcont "Added symbolic link from: $InputPath"
    informcont "To: $MoveDir/$ShowFileName.$OriginalExt"
  fi
  NOTIFY_MSG="myth2kodi Success $ShowFileName moved to $MoveDir"
  return 0
}

#A warning message for when a recording was thought to be an episode but
#no episode information could be obtained.
msg_epishow(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  warn     "SHOW WAS CONSIDERED AN EPISODE BUT INFORMAITON WAS NOT OBTAINABLE"
  warncont "%%%% Please consider helping out and adding to TheTVDB %%%%"
  warncont "HANDLING EPISODE AS GENERAL SHOWING & DUMPING INTO --doover USER JOB"
}

#A warning message for when a fuzzy match on episode name isn't consistent
#with an airdate match.
msg_fuzzy_logic_warning(){
  #TODO: review this message
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  warn     "%%%% AIRDATE MATCH AND FUZZY LOGIC ARE IN DISAGREEMENT %%%%"
  warncont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
  warncont "%%%%%%%%%% GUIDE DATA AND TVDB DATA DO NOT MATCH %%%%%%%%%%"
  warncont "%%%% Possible causes: small variations in episode name %%%%"
  warncont "%%%%%%%%%%%%%%%%%%%%% bad guide data %%%%%%%%%%%%%%%%%%%%%%"
  warncont "%%%%%%%%%%%%%%%%%%%%% bad tvdb airdate %%%%%%%%%%%%%%%%%%%%"
  warncont "%%%%%%%%%%%%%%%%%%%%% bad tvdb episode name %%%%%%%%%%%%%%%"
  warncont "%%%%%%%%%%%%%%%%%%%%% bad tvdb zap2it id %%%%%%%%%%%%%%%%%%"
  warncont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
  inform "Setting LOGLEVEL=3 (debug) DUE TO AIRDATE/FUZZY-LOGIC DISAGREEMENT."
  LOGLEVEL=3 #Enable debug level logging
}

#A warning message for when a match on episode name isn't consistent
#with an airdate match.
msg_standard_logic_warning(){
  #TODO: review this message
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  warn     "%% AIRDATE MATCH AND STANDARD LOGIC ARE IN DISAGREEMENT. %%"
  warncont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
  warncont "%%%%%%%%%%% GUIDE DATA AND TVDB DATA DO NOT MATCH %%%%%%%%%"
  warncont "%%%% Possible causes: small variations in episode name %%%%"
  warncont "%%%%%%%%%%%%%%%%%%%%% bad guide data %%%%%%%%%%%%%%%%%%%%%%"
  warncont "%%%%%%%%%%%%%%%%%%%%% bad tvdb airdate %%%%%%%%%%%%%%%%%%%%"
  warncont "%%%%%%%%%%%%%%%%%%%%% bad tvdb episode name %%%%%%%%%%%%%%%"
  warncont "%%%%%%%%%%%%%%%%%%%%% bad tvdb zap2it id %%%%%%%%%%%%%%%%%%"
  warncont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
  inform "Setting LOGLEVEL=3 (debug) DUE TO AIRDATE/STANDARD-LOGIC DISAGREEMENT."
  LOGLEVEL=3 #Enable debug level logging
}

#An error message for when the path/file we've been asked to process doesn't exist
msg_invalid_path_error(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local PATH_TO_CHECK="$1"
  err     "OPERATION FAILED, PATH OR FILE DOES NOT EXIST, CHECK NAME AND PERMISSIONS:"
  errcont "'$PATH_TO_CHECK'"
}

#An error message for when information can't be obtained from TheTVDB.
msg_tvdb_incomplete(){
  #TODO: review this message, see new msg_unable_to_identify_recording function below.
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  err     "%% OPERATION FAILED, INFORMATION COULD NOT BE OBTAINED %%"
  errcont "%% TheTVDB information is incomplete for $InputTitle, ${InputSubtitle}."
  errcont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
  errcont "%% Please consider helping out and adding to TheTVDB %%"
  errcont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
  errcont "TO PROCESS THIS FILE & PREVENT THIS ERROR IN THE FUTURE, ENABLE HANDLING OF UNRECOGNIZED SHOWS."
  NOTIFY_MSG="Could not obtain information from server about: $InputTitle. TheTVDB is incomplete"

}

# msg_unable_to_identify_recording(){
#   debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
#   err "Operation failed, unable to identify recording: $InputPath"
#   informcont "This means that insufficient information was provided to myth2kodi"
#   informcont "and the missing information couldn't be determined by other means."
#   informcont "If you know the correct information, provide it at the command line,"
#   informcont "see myth2kodi --usage"
#   informcont "Normally myth2kodi can determine this information from:"
#   informcont "    your MythTV-DB; TheTVDB; or tvmaze."
#   informcont "Check that information on www.TheTVDB.com is complete for this series."
#   informcont "If not, Please consider helping out and adding to TheTVDB."
#   [[ -n "$SeriesID" ]] && informcont "http://www.thetvdb.com/?tab=series&amp;id=$SeriesID"
#   informcont "To force processing of unrecognised recordings, disable ShowStopper."
#   msg_tvdb_incomplete
#   NOTIFY_MSG="Could not fully identify: $InputTitle."
# }

#An error message for when the moved file has zero length (either the
#original had zero length or we failed to move it).
msg_wrote_zero_length_file(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  NOTIFY_MSG="$ShowFileName.$OriginalExt could not be moved to $MoveDir"
  err "${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
  EXIT_JOB_TYPE='ZeroLengthFile'
}

#An error message for when issues are encountered during moving
msg_permission_error_while_moving(){
  #TODO: review this message, see also check_path_permission()
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  NOTIFY_MSG="MOVE FAILED: $ShowFileName could not be moved to $MoveDir"
  err "${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
  errcont "Possible permission error while moving $ShowFileName"
  EXIT_JOB_TYPE='MoveFailed'
}

#An error message for when we've failed to create a symlink
msg_symlink_not_created(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  NOTIFY_MSG="SYMLINKING FAILED: Failure while creating link. Check permissions."
  err "${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
  errcont " Possible permission error while linking $ShowFileName"
  errcont "Check that file system supports symlinks: $MoveDir"
  EXIT_JOB_TYPE='LinkingFailed'
}

#This function provides an error message on generic errors
msg_generic_unspecified_error(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  err  "%%%% OPERATION FAILED: GenericUnspecifiedError %%%%"
  errcont "NO MATCH FOUND. TROUBLESHOOTING: Check TheTVDB TO SEE IF $InputTitle EXISTS."
  errcont "CHECK EPISODE NAME $InputSubtitle. CHECK INTERNET CONNECTION. CHECK API KEY."
  errcont "NOT ENOUGH INFORMATION PULLED FROM DATABASE TO IDENTIFY FILE AS MOVIE OR EPISODE"
  errcont "CHECK www.TheTVDB.com RUN myth2kodi LINK COMMAND PROMPT."
  errcont "FOR MORE INFORMATION SEE http://kodi.wiki/index.php?title=mythicalLibrarian" #TODO: If I ever make this public, remember to make a thread.
  errcont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
}

#--recording-info
msg_recording_info(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  printf '\n%s\n\n' "MythTV-DB information for: $InputFileBasename"
  printf '%s\n' "  Title='$InputTitle'"
  printf '%s\n' "  Subtitle='$InputSubtitle'"
  printf '%s\n' "  Season='$InputSeasonNum'"
  printf '%s\n' "  Episode='$InputEpisodeNum'"
  printf '%s\n' "  Airdate='$MovieAirDate'"
  printf '%s\n' "  Originalairdate='$OriginalAirDate'"
  printf '%s\n' "  Category='$ShowCategory'"
  printf '%s\n' "  Storagegroup='$StorageGroup'"
  printf '%s\n' "  Stars='$Stars'"
  printf '%s\n' "  Description='$Plot'"
  printf '%s\n' "  Seriesid='$SeriesID'"
  printf '%s\n' "  Programid='$ProgramID'"
  printf '%s\n' "  Chanid='$ChanID'"
  printf '%s\n' "  Starttime='$ShowStartTime'"
  if [[ "$CommercialMarkup" = "Created" ]]; then
    printf '\n%s\n' "Commercial Skip Info"
    tail -n +2 "$MARKUPFRAMES_TMP"
    printf '\n'
  fi
}

#Report the combination of command line input and MythTV-DB data.
msg_merged_input_mythtvdb(){
  debug "Input and MythTV-DB guide data for $InputFileBasename"
  [[ "$Database" = 'Enabled' ]] && debugcont "RECSTART:$ShowStartTime"
  [[ "$Database" = 'Enabled' ]] && debugcont "DATE:$MovieAirDate $OriginalAirDate"
  [[ "$Database" = 'Enabled' ]] && debugcont "PROGRAMID:$ProgramID"
  [[ "$Database" = 'Enabled' ]] && debugcont "ShowCategory:$ShowCategory"
  if [[ -n "$InputTitle" ]]; then
    debugcont "InputTitle:$InputTitle"
  else
    debugcont "InputTitle: UNKNOWN"
  fi
  if [[ -n "$InputSubtitle" ]]; then
    debugcont "InputSubtitle:$InputSubtitle"
  else
    debugcont "InputSubtitle: UNKNOWN"
  fi
  if [[ -n "$Sxx" ]]; then debugcont "Sxx:$Sxx"; else debugcont "Sxx: UNKNOWN"; fi
  if [[ -n "$Exx" ]]; then debugcont "Exx:$Exx"; else debugcont "Exx: UNKNOWN"; fi
  [[ "$Database" = 'Enabled' ]] && debugcont "PLOT: $Plot"
}

#A warning message about performing maintenance that waits on user input
#before proceeding
maintenance_warning(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local yesorno=""
  warn "  --You have entered Maintenance mode."
  warncont "  myth2kodi will perform maintenance on it's records."
  warncont "  Please ensure that All network attached storage and removable"
  warncont "  storage drives are connected and mounted properly before continuing"
  read -r -n1 -p "Do you want myth2kodi to perform maintenance? y/(n)>" yesorno
  printf '\n'
  if [ "$yesorno" != "y" ]; then
    inform "You must press 'y' to continue"
    return 1
  fi
  return 0
}

cleanse_warning(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local yesorno=""
  inform "  --You have requested myth2kodi's working directory to be cleansed."
  informcont "  myth2kodi will PERMANENTLY REMOVE archived log files, myth2kodi"
  informcont "  database files, and daily report files older than specified by"
  informcont "  the user settings: LOG_LIFE; M2K_DB_LIFE; and DAILYREPORT_LIFE."
  read -r -n1 -p "Do you want myth2kodi to cleanse it's working directory? y/(n)>" yesorno
  printf '\n'
  if [ "$yesorno" != "y" ]; then
    inform "You must press 'y' to continue"
    return 1
  fi
  return 0
}

#Set the move location for the current recording, using Alternate directories
#when main directories unavailable, in worst case set FailSafe flag.
set_move_location(){
  #TODO: No point setting failsafe state when original dir isn't writeable... add checks. see also, set_target_dir_as_input_path_dir()
  #      also, need to make sure doover is set when FailSafeState=1
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Command line, no database Episodes: Determine where File will fit
  FailSafeState=0
  [[ -z "$m2kProgramIDCheck" && "$MoveDirWritable" != "0" ]] && MoveDir="$AlternateMoveDir"
  [[ -z "$m2kProgramIDCheck" && "$MoveDirWritable" != "0" && "$AltMoveDirWritable" != "0" ]] && FailSafeState=1

  #Episode handling: Determine where File will fit
  [[ "$m2kProgramIDCheck" = "EP" && "$MoveDirWritable" != "0" ]] && MoveDir="$AlternateMoveDir"
  [[ "$m2kProgramIDCheck" = "EP" && "$MoveDirWritable" != "0" && "$AltMoveDirWritable" != "0" ]] && FailSafeState=1

  #Movie handling: Determine where file will fit
  [[ "$m2kProgramIDCheck" = "MV" && "$MovieDirWritable" != "0" ]] && PrimaryMovieDir="$AlternateMoveDir"
  [[ "$m2kProgramIDCheck" = "MV" && "$MovieDirWritable" != "0" && "$AltMovieDirWritable" != "0" ]] && FailSafeState=1

  #Show Handling: Determining Where File will fit
  [[ "$m2kProgramIDCheck" = "SH" && "$ShowDirWritable" != "0" ]] && PrimaryShowDir="$AlternateShowDir"
  [[ "$m2kProgramIDCheck" = "SH" && "$ShowDirWritable" != "0" && "$AltShowDirWritable" != "0" ]] && FailSafeState=1
}

#Make the directory we'll move recording to if it doesn't already exist.
make_show_dir(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "NewShowName: $NewShowName"
  debugcont "MoveDir: $MoveDir"
  debugcont "SeasonNumber: $SeasonNumber"
  debugcont "Notify: $Notify"
  debugcont "NotifyUserName: $NotifyUserName"
  debugcont "FailSafeDir: $FailSafeDir"

  #If specified, make $MoveDir = $MoveDir/show name
  if [[ -n "$NewShowName" ]]; then
    MoveDir="$MoveDir/$NewShowName"
    if [ ! -d "$MoveDir" ]; then
      inform "CREATING SERIES FOLDER: $MoveDir"
      [[ "$TRACKING" = 'Enabled' ]] && printf '%s\n' "$MoveDir" >> "$m2kdir/dir.tracking"
      mkdir "$MoveDir"
      chmod 775 "$MoveDir"
      [[ "$RequiresNFO" = "1" ]] && generate_series_nfo
    fi

    #Make the Season folder if it is applicable and does not exist
    if [[ -n "$SeasonNumber" ]]; then
      MoveDir="$MoveDir/Season $SeasonNumber"
      if [ ! -d "$MoveDir" ]; then
        inform "CREATING SEASON FOLDER: $MoveDir"
        mkdir "$MoveDir"
        chmod 775 "$MoveDir"
        [[ "$TRACKING" = 'Enabled' ]] && printf '%s\n' "$MoveDir" >> "$m2kdir/dir.tracking"
      fi
    fi
  fi

  #Error message if folder was not created
  if [ ! -d "$MoveDir" ]; then
    NOTIFY_MSG="COULD NOT CREATE $MoveDir - failsafe mode activated."
    EXIT_JOB_TYPE='PermissionError'
    err "${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    PROCESS_RECORDING_MODE='LINK'
    SYMLINK='Enabled'
    MoveDir="$FailSafeDir"
    FailSafeState=1
    warn "Recordings processed in FAILSAFE MODE will be added to the doover queue."
    RequiresDoover=1
    inform "FailSafe MOVE DIRECTORY SET AS: $MoveDir"
    return 1
  else
    inform "MOVE DIRECTORY SET AS: $MoveDir"
    return 0
  fi
}

#If TargetPathIsInputPath is set, then this changes MoveDir to original dir.
set_target_dir_as_input_path_dir(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #For directory names: No trailing / is accepted eg. "~/videos" not "~/videos/"
  #MoveDir is the folder which myth2kodi will move the file.
  MoveDir="$originaldirname/Episodes"
  test ! -d "$MoveDir" && mkdir "$MoveDir"
  #AlternateMoveDir will act as a secondary MoveDir if the primary MoveDir fails.
  AlternateMoveDir="$originaldirname/Episodes"
  test ! -d "$AlternateMoveDir" && mkdir "$AlternateMoveDir"
  #Primary Movie Dir. myth2kodi will attempt to move to this dir first.
  PrimaryMovieDir="$originaldirname/Movies"
  test ! -d "$PrimaryMovieDir" && mkdir "$PrimaryMovieDir"
  #AlternateMovieDir will act as a Secondary move dir if the primary move dir fails.
  AlternateMovieDir="$originaldirname/Movies"
  test ! -d "$AlternateMovieDir" && mkdir "$AlternateMovieDir"
  #PrimaryShowDir is where generic episodes will be placed.
  PrimaryShowDir="$originaldirname/Showings"
  test ! -d "$PrimaryShowDir" && mkdir "$PrimaryShowDir"
  #AlternateShowDir will act as a Secondary Show Dir if the primary show dir fails.
  AlternateShowDir="$originaldirname/Showings"
  test ! -d "$AlternateShowDir" && mkdir "$AlternateShowDir"
}

#Create a series NFO file based on information we have for the current series
generate_series_nfo(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  {
    printf '%s\n' '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>'
    printf '%s\n' "<tvshow>"
    printf '%b\n' "\t<title>$NewShowName</title>"
    #printf '%b\n' "\t<plot>$SeriesPlot</plot>" #TODO: for when we've extracted the series description...
    #printf '%b\n' "\t<status>$SeriesStatus</status>" #TODO: for when we've extracted the series status
    printf '%b\n' "\t<episodeguide>"
  } > "$MoveDir/tvshow.nfo"

  if [[ -n "$SeriesID" ]]; then
    local webaddrs
    webaddrs="http://www.thetvdb.com/api/$APIkey/series/$SeriesID/all/$Language.zip"
    printf '%b\n' "\t\t<url cache=\"$SeriesID.xml\">$webaddrs</url>" >> "$MoveDir/tvshow.nfo"
  fi

  {
    printf '%b\n' "\t</episodeguide>"
    [[ -n "$SeriesID" ]] && printf '%b\n' "\t<id>$SeriesID</id>"
    printf '%b\n' "\t<dateadded>$(date --rfc-3339=seconds)</dateadded>"
    #printf '%b\n' "\t<premiered>$SeriesFirstAired</premiered>" #TODO: for when we've extracted the series first aired field.
    printf '%s\n' "</tvshow>"
  } >> "$MoveDir/tvshow.nfo"
  inform "Generated series NFO file: $MoveDir/tvshow.nfo"
  return 0
}

#Create an episode NFO file based on information we have for the current episode
generate_episode_nfo(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  {
    printf '%s\n' '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
    printf '%s\n' '<episodedetails>'
  } > "$MoveDir/$ShowFileName.nfo"
  local basetitle="<title>$EpisodeSubtitle Recorded $datehour"
  if [[ -z "$NamingConvention" ]]; then
    if [ "$GoForDoover" = "1" ]; then
      printf '%b\n' "\t$basetitle -Episode in --doover Que</title>" >> "$MoveDir/$ShowFileName.nfo"
    else
      printf '%b\n' "\t$basetitle -Showing</title>" >> "$MoveDir/$ShowFileName.nfo"
    fi
  else
    printf '%b\n' "\t$basetitle -Categoric</title>" >> "$MoveDir/$ShowFileName.nfo"
  fi

  if [ "$HasSxxExx" = "1" ] ; then
    {
      printf '%b\n' "\t<season>$Sxx</season>"
      printf '%b\n' "\t<episode>$Exx</episode>"
    } >> "$MoveDir/$ShowFileName.nfo"
  else
    {
      printf '%b\n' "\t<season>0</season>"
      printf '%b\n' "\t<episode>0</episode>"
    } >> "$MoveDir/$ShowFileName.nfo"
  fi

  {
    printf '%b\n' "\t<rating>$rating</rating>"
    printf '%b\n' "\t<plot>$Plot</plot>"
    printf '%b\n' "\t<genre>$ShowCategory</genre>"
    printf '%b\n' "\t<aired>${ShowStartTime%% *}</aired>"
    printf '%b\n' "\t<dateadded>$(date --rfc-3339=seconds)</dateadded>"
    printf '%s\n' "</episodedetails>"
  } >> "$MoveDir/$ShowFileName.nfo"

  if [[ "$TRACKING" = 'Enabled' ]]; then
    printf '%s\n' "'$MoveDir/$ShowFileName.nfo' '$MoveDir/$ShowFileName.$OriginalExt'" >> "$m2kdir/created.tracking"
  fi
  inform "Generated episode NFO file: $MoveDir/$ShowFileName.nfo"
  return 0
}

#Processes the title and categoric ignore lists
process_ignore_lists(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local ignoreTest=""
  #Test if the title is in the titleIgnore file
  if [ -f "$m2kdir/titleIgnore" ]; then
    ignoreTest="$(grep "$InputTitle" "$m2kdir/titleIgnore")"
    if [ "$InputTitle" = "$ignoreTest" ]; then
      EXIT_JOB_TYPE='titleIgnore'
      return 1
    fi
  fi
  #Test if the Category is in the categoricIgnore file
  if [ -f "$m2kdir/categoricIgnore" ]; then
    ignoreTest="$(grep "$ShowCategory" "$m2kdir/categoricIgnore")"
    if [ "$ShowCategory" = "$ignoreTest" ]; then
      EXIT_JOB_TYPE='categoricIgnore'
      return 1
    fi
  fi
  return 0
}

#Get show translations if the $m2kdir/showTranslations file exists.
#The show title will be replaced by the one in the user created showTranslations file
show_translation(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [[ -f "$m2kdir/showTranslations" && -n "$ShowName" ]]; then
    showtranslation="$(grep "$ShowName = " "$m2kdir/showTranslations" | sed "s/$ShowName = //g")"
    if [[ -n "$showtranslation" ]]; then
      ShowName="$showtranslation"
      inform "USER TRANSLATION: $InputTitle = $ShowName"
    elif [[ -z "$showtranslation" ]]; then
      showtranslation="Inactive"
    fi
  fi
  return 0
}

#Process a list of archived files and remove those older than a specified age.
process_cleanup_file(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "Called with $# arguments"
  local -i i=0; local var; for var in "$@"; do ((++i)); debugcont "arg $i = ${var}"; done
  local CLEANUP_FILE
  local -i ARCHIVE_LIFE
  local ARCHIVE_DATE
  local -i EXPIRE_OLDER_THAN
  CLEANUP_FILE="$1"
  [[ ! -f "$CLEANUP_FILE" ]] && err "Not a file: $CLEANUP_FILE" && return 1
  ARCHIVE_LIFE="$2"
  EXPIRE_OLDER_THAN="$(date -d "-$ARCHIVE_LIFE months" '+%Y%m%d')"

  inform "Removing files created more than $ARCHIVE_LIFE months ago."
  while read -r line ; do
    #Extract the creation date of the archived file
    ARCHIVE_DATE="$(grep --only-matching '20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]' <<< "$line")"
    #Convert it to an integer
    ARCHIVE_DATE="$(date -d "$ARCHIVE_DATE" +"%Y%m%d")"
    if ((ARCHIVE_DATE < EXPIRE_OLDER_THAN)); then
      debug "Removing old archive file: $line"
      rm -f "$line"
    fi
  done < "$CLEANUP_FILE"

  #If we're not in debug mode then remove the clean-up file we just processed.
  if (( LOGLEVEL < 3 )); then
    rm -f "$CLEANUP_FILE"
  else
    debug "Not removing temporary clean-up file: '$CLEANUP_FILE'"
  fi
}

#Clean-up old files we don't need any more: log files; m2k database files; etc.
m2k_cleanse(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: Consider making the cleanup_logs file more modular, so we can set different
  #      lifetimes for the archived main logs, doover scripts, undo scripts, etc.
  #      Maybe make an archived_logs directory with sub directories: main; diagnostics; etc.

  #Create cleanup files for archived logs, myth2kodi database, and daily report files.
  local CLEANUP_LOGS CLEANUP_M2K_DB CLEANUP_DAILYREPORT
  CLEANUP_LOGS="$(mktemp "$M2K_TMPDIR/m2k_cleanup_logs_$FileNameNow"-XXXX)"
  [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
  CLEANUP_M2K_DB="$(mktemp "$M2K_TMPDIR/m2k_cleanup_m2k_db_$FileNameNow"-XXXX)"
  [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
  CLEANUP_DAILYREPORT="$(mktemp "$M2K_TMPDIR/m2k_cleanup_dailyreport_$FileNameNow"-XXXX)"
  [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
  find "$m2kdir" -maxdepth 1 -type f -name '*20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]*' > "$CLEANUP_LOGS"
  find "$m2kdir" -mindepth 2 -type f ! -path "*DailyReport*" -name '*20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]*' > "$CLEANUP_M2K_DB"
  find "$m2kdir/DailyReport" -type f -name '*20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]*' > "$CLEANUP_DAILYREPORT"

  inform "Processing log clean-up file: $CLEANUP_LOGS"
  process_cleanup_file "$CLEANUP_LOGS" "$LOG_LIFE"

  inform "Processing myth2kodi database clean-up file: $CLEANUP_M2K_DB"
  process_cleanup_file "$CLEANUP_M2K_DB" "$M2K_DB_LIFE"

  inform "Processing daily report clean-up file: $CLEANUP_DAILYREPORT"
  process_cleanup_file "$CLEANUP_DAILYREPORT" "$DAILYREPORT_LIFE"

  #Clean-up temporary files we leave around when running with debug logging.
  #NOTE: While this could be 'rm -f "$M2K_TMPDIR/m2k_"*', this way we know
  #      what it is we're expecting to clean-up...
  rm -f "$M2K_TMPDIR/m2k_cleanup_logs_"*
  rm -f "$M2K_TMPDIR/m2k_cleanup_m2k_db_"*
  rm -f "$M2K_TMPDIR/m2k_cleanup_dailyreport_"*
  rm -f "$M2K_TMPDIR/m2k_comskip_scan_"*
  rm -f "$M2K_TMPDIR/m2k_scan_"*
  rm -f "$M2K_TMPDIR/m2k_recinfo_"*
  rm -f "$M2K_TMPDIR/m2k_shn_"*
  rm -f "$M2K_TMPDIR/m2k_sid_"*
  rm -f "$M2K_TMPDIR/m2k_working_"*
  rm -f "$M2K_TMPDIR/m2k_markupframes_"*
  rm -f "$M2K_TMPDIR/m2k_markupstart_"*
  rm -f "$M2K_TMPDIR/m2k_markupstop_"*
  rm -f "$M2K_TMPDIR/m2k_zap2it_"*
  rm -f "$M2K_TMPDIR/m2k_sorted_dir_tracking-"*
  rm -f "$M2K_TMPDIR/m2k_logfilelist-"*
  rm -f "$M2K_TMPDIR/m2k_templog-"*

  #Archive our duplicates.log.
  if [[ -f "$DuplicatesFile" ]]; then
    debug "Moving $DuplicatesFile to ${DuplicatesFile%.*}_${FileNameNow}.log."
    mv "$DuplicatesFile" "${DuplicatesFile%.*}_${FileNameNow}.log"
  fi
}

#Loops through tracked files and directories deleting them if they've been orphaned.
m2k_maintenance(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform "PERFORMING MAINTENANCE ROUTINE..."

  #Check for comskip (.txt) and .nfo files listed in created.tracking and
  #remove them if their associated "main" file (.mpg) is missing.
  if [[ "$CommercialMarkupCleanup" = 'Enabled' && -f "$m2kdir/created.tracking" ]]; then
    local -i Counter=0
    inform "PERFORMING CLEANUP OF ORPHANED SUPPORT FILES."
    local SupportFile=""
    local MainFile=""
    while read -r line ; do
      (( ++Counter ))
      SupportFile="$(cut -d"'" -f2 <<< "$line")"
      debug "Support file (record $Counter): ${SupportFile}"
      MainFile="$(cut -d"'" -f4 <<< "$line")"
      debug "Main file (record $Counter): ${MainFile}"
      #TODO: Why the ls rather than [[ ! -e "$MainFile" ]]
      ls "$MainFile" > /dev/null 2>&1
      if [ "$?" != "0" ]; then
        if [ -d "$(dirname "$SupportFile")" ]; then
          inform "REMOVING ORPHAN FILE: $SupportFile"
          rm -f "$SupportFile"
          printf '%s\n' "$line" >> "$m2kdir/created.tracking.old"
        else
          warn "${FUNCNAME[0]}() FOLDER DISCONNECTED: $SupportFile"
          if (( removedead != 1 )); then
            printf '%s\n' "$line" >> "$m2kdir/created.tracking2"
          else
            inform "REMOVING FROM FUTURE SEARCHES: $line"
            printf '%s\n' "$line" >> "$m2kdir/created.tracking.old"
          fi
        fi
      else
        #If the MainFile is actually the original MythTV recording file (it was
        #processed in LINK mode) and the SupportFile no longer exists, then
        #'[0-9]{4}_20[0-9]{2}[0-1][0-9][0-3][0-9][0-2][0-9][0-5][0-9]{3}'
        if grep -q -E '[0-9]{4}_20[0-9]{12}' <<< "$MainFile" ; then
          debug "Identified as LINK mode created.tracking entry."
          if [[ -f "$SupportFile" ]]; then
            debug "Link still present, continuing to track."
            printf '%s\n' "$line" >> "$m2kdir/created.tracking2"
          else
            inform "Link no longer exists, removing from created.tracking."
            printf '%s\n' "$line" >> "$m2kdir/created.tracking.old"
          fi
        else
          #Not LINK mode and main file still exists, so continue to track
          printf '%s\n' "$line" >> "$m2kdir/created.tracking2"
        fi
      fi
    done < "$m2kdir/created.tracking"
    [[ -f "$m2kdir/created.tracking" ]] && rm -f "$m2kdir/created.tracking"
    [[ -f "$m2kdir/created.tracking2" ]] && mv "$m2kdir/created.tracking2" "$m2kdir/created.tracking"
  fi

  #Check if folders are empty and remove dir if needed and it was created by myth2kodi
  if [[ "$DirTracking" = 'Enabled' && -f "$m2kdir/dir.tracking" ]]; then
    inform "PERFORMING CLEANUP OF EMPTY DIRECTORIES."
    local SORTED_DIR_TRACKING_FILE
    SORTED_DIR_TRACKING_FILE="$(mktemp "$M2K_TMPDIR"/m2k_sorted_dir_tracking-XXXX)"
    [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
    debug "Created a temporary sorted dir,tracking file: $SORTED_DIR_TRACKING_FILE"
    #Reverse dictionary sort the tracked dirs, should have the effect of depth first.
    sort -dr "$m2kdir/dir.tracking" > "$SORTED_DIR_TRACKING_FILE"
    local CONTAINS
    while read -r dirtocheck ; do
      (( ++Counter ))
      debug "Folder record $Counter: $dirtocheck"
      if [[ -d "$dirtocheck" ]]; then
        #Is there something in the directory other than 'tvshow.nfo'
        CONTAINS="$(find "$dirtocheck" -mindepth 1 ! -name 'tvshow.nfo' -print -quit)"
        if [[ -z "$CONTAINS" ]]; then
          inform "REMOVING ORPHAN FOLDER: $dirtocheck"
          [[ -f "$dirtocheck/tvshow.nfo" ]] && rm -f "$dirtocheck/tvshow.nfo"
          rmdir "$dirtocheck"
          printf '%s\n' "$dirtocheck" >> "$m2kdir/dir.tracking.old"
        else
          debugcont "Continuing to track folder record $Counter, it contains, at least: $CONTAINS"
          printf '%s\n' "$dirtocheck" >> "$m2kdir/dir.tracking2"
        fi
      else
        warn "Tracked directory doesn't seem to be a directory. Continuing to track, just in case."
        printf '%s\n' "$dirtocheck" >> "$m2kdir/dir.tracking2"
      fi
    done < "$SORTED_DIR_TRACKING_FILE"
    [[ -f "$m2kdir/dir.tracking" ]] && rm -f "$m2kdir/dir.tracking"
    [[ -f "$SORTED_DIR_TRACKING_FILE" ]] && rm -f "$SORTED_DIR_TRACKING_FILE"
    [[ -f "$m2kdir/dir.tracking2" ]] && mv "$m2kdir/dir.tracking2" "$m2kdir/dir.tracking"
  fi

  #When the dir.tracking.old exceeds 512kB compress it and start a fresh one.
  log_rotation "$m2kdir/dir.tracking.old" "$m2kdir/dir.tracking.old_${FileNameNow}" '512000'

  #When the created.tracking.old exceeds 512kB compress it and start a fresh one.
  log_rotation "$m2kdir/created.tracking.old" "$m2kdir/created.tracking.old_${FileNameNow}" '512000'

  #This isn't super fast, so only cleanse the working when called from --maintenance mode.
  if (( removedead == 1 )); then
    inform "Cleaning up old archived logs, myth2kodi database files, and daily report files."
    m2k_cleanse
  fi
  inform "MAINTENANCE ROUTINE COMPLETE."
  return 0
}

#An error message for failure to call --scan correctly
#A single input arg, specifying the type of error, is prepended to the message.
msg_scan_usage(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Log the input arg ($1) as an ERROR message and append usage for --scan to the log.
  err "$1."
  errcont '  usage: myth2kodi --scan "ext" "/path/to/folder"'
  errcont '  example: myth2kodi --scan "mpg" "/home/mythtv/videos"'
}

#This function will scan a folder and process the entire library
m2k_scan(){
  #TODO: Need to go through this function line-by-line and make sure it can be run without causing damage.
  [[ "$LOGTYPE" = "logfile" ]] && printf '%s\n' "WARNING: Recommend setting LOGTYPE='both', before proceeding.."
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local yesorno=""
  local dooverstatus
  #Map myth2kodi input variables to local variables for our current purpose.
  local checkext="$m2karg2"
  local scanpath="$m2karg3"
  debug "Running ${FUNCNAME[0]}() on $checkext files in $scanpath"

  check_path_permission "$scanpath"
  checkpermissionstatus="$?"
  [[ "$checkpermissionstatus" != 0 ]] && return "$checkpermissionstatus"

  #Do some basic checks before we get started.
  if [[ -z "$checkext" ]]; then
    NOTIFY_MSG='Cannot process blank file extensions'
    msg_scan_usage "$NOTIFY_MSG"
    EXIT_JOB_TYPE='InvalidCall'
    return 1
  elif [ "${checkext:0:1}" = "." ]; then
    NOTIFY_MSG='Please do not prepend a "." to the file extension'
    msg_scan_usage "$NOTIFY_MSG"
    EXIT_JOB_TYPE='InvalidCall'
    return 1
  elif [[ -z "$scanpath" ]]; then
    NOTIFY_MSG='Please supply a path'
    msg_scan_usage "$NOTIFY_MSG"
    EXIT_JOB_TYPE='InvalidCall'
    return 1
  elif [ ! -d "$scanpath" ]; then
    NOTIFY_MSG="This folder does not exist: $scanpath"
    msg_scan_usage "$NOTIFY_MSG"
    EXIT_JOB_TYPE='FileOrPathDoesNotExist'
    return 1
  elif [ "${scanpath:0:1}" != "/" ]; then
    NOTIFY_MSG='Please specify the full path to the file'
    msg_scan_usage "$NOTIFY_MSG"
    EXIT_JOB_TYPE='InvalidCall'
    return 1
  fi

  warn "--You have entered scan Mode."
  warncont "myth2kodi will conduct a scan of the folder:"
  warncont "  $scanpath"
  warncont "searching for file types: $checkext. Each file will be processed"
  warncont "through myth2kodi. This mode will only work when database access"
  warncont "is functional."
  warncont "Please scan a single file to test myth2kodi before running in"
  warncont "scan mode. That is, use the following form to test operation:"
  warncont "  myth2kodi '/path/to/file.ext'"
  warncont "In scan mode, myth2kodi will first run the doovers to prevent"
  warncont "clobbering and creation of unnecessary links."
  warncont "All myth2kodi operations can be reversed using the following command:"
  warncont "  myth2kodi --undo"
  warn "Data loss can occur if this operation is interrupted."
  debug "WARNING: RUNNING A SCAN WITH DEBUG LEVEL LOGGING. CONSIDER USING Info(2) LEVEL."
  read -r -n1 -p "  Would you like myth2kodi to conduct a scan? y/(n)>" yesorno
  printf '\n'
  #Default to safety, ie do nothing.
  [[ -z "$yesorno" ]] && yesorno="n"
  if [ "$yesorno" = "y" ]; then
    #check for interrupted undo jobs
    [[ -f "$m2kdir/undo.lock" && ! -f "$m2kdir/undo.sh" ]] && mv "$m2kdir/undo.lock" "$m2kdir/undo.sh"
    #Explicitly call m2k_maintenance() here as it's blocked in subsequent calls to myth2kodi from scan mode.
    m2k_maintenance
    myth2kodi --doover
    dooverstatus="$?" #TODO: This only catches the exit state of the final myth2kodi call... Need to review doover.
    if [[ "$dooverstatus" != 0 ]]; then
      err "Doover failed or was aborted by user, not continuing with scan."
      #TODO: Temp hack: return status can be non-zero when it's not a problem,
      #                 eg, all processed correctly, but it's a duplicate. Need to review doover generally and myth2kodi exit status...
      read -r -n1 -p "  ERROR DURING DOOVER: Continue with the scan? y/(n)>" yesorno
      printf '\n' ; [[ -z "$yesorno" ]] && yesorno="n"
      [[ "$yesorno" != "y" ]] && return "$dooverstatus"
    fi
    local SCAN_FILE
    SCAN_FILE="$(mktemp "$M2K_TMPDIR/m2k_scan_$FileNameNow"-XXXX)"
    [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
    debug "Created a temporary scan file: '$SCAN_FILE'"
    ls -1 "$scanpath"/*."$checkext" > "$SCAN_FILE"
    inform "Scanning $scanpath for $checkext files."
    while read -r line ; do
      debug "Attempting to envoke myth2kodi on $line"
      if [[ ! -L "$line" && ! -S "$line" && ! -d "$line" ]]; then
        myth2kodi "$line"
      else
        debug "Either we've already moved that or it's a directory. Either way, moving on."
      fi
    done < "$SCAN_FILE"
    inform "Completed scan of $scanpath for $checkext files."
    #If we're not in debug mode then remove the scan file we just processed.
    if (( LOGLEVEL < 3 )); then
      rm -f "$SCAN_FILE"
    else
      debug "Not removing the temporary scan file: '$SCAN_FILE'"
    fi
    return 0
  else
    inform "You must press 'y' to scan, aborting."
    return 0
  fi
  return 1
}

#Called when SYMLINK is Disabled, adds read and write permission for the group
set_group_permission(){
  #TODO: review... Why?
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Add read and write permissions for the group to the moved recording.
  chmod g=rw "$MoveDir/$ShowFileName.$OriginalExt"
  #TODO:#NOTE: the above command is slightly inconsistent with the comment as = also implies removal of any unmentioned attributes.
}

#Prints a table summarising the status of important directories.
msg_dir_summary(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  informcont "A summary table of writeable directories: 0='WRITEABLE' ; 1='NOT WRITEABLE'"
  informcont "$(printf '%-18s|%-5s|%-12s|%s\n'     "USER SETTING"      "FLAG"                 "Free Space"               "Folder name"       )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "m2kdir"            "$WorkingDirWritable"  "$WorkingDirFreeSpace MB"  "$m2kdir"           )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "originaldirname"   "$OriginalDirWritable" "$OriginalDirFreeSpace MB" "$originaldirname"  )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "MoveDir"           "$MoveDirWritable"     "$MoveDirFreeSpace MB"     "$MoveDir"          )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "AlternateMoveDir"  "$AltMoveDirWritable"  "$AltMoveDirFreeSpace MB"  "$AlternateMoveDir" )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "PrimaryMovieDir"   "$MovieDirWritable"    "$MovieDirFreeSpace MB"    "$PrimaryMovieDir"  )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "AlternateMovieDir" "$AltMovieDirWritable" "$AltMovieDirFreeSpace MB" "$AlternateMovieDir")"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "PrimaryShowDir"    "$ShowDirWritable"     "$ShowDirFreeSpace MB"     "$PrimaryShowDir"   )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "AlternateShowDir"  "$AltShowDirWritable"  "$AltShowDirFreeSpace MB"  "$AlternateShowDir" )"
}

#A message summarizing myth2kodi's operation
msg_operation_summary(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform "################ OPERATION SUMMARY ################"
  informcont "JOB: myth2kodi '$m2karg1' '$m2karg2' '$m2karg3' '$m2karg4'"
  debugcont  "m2kVersion=$m2kVersion-"
  informcont "CALLER=$CALLER-"
  debugcont  "m2kdir=$m2kdir-"
  debugcont  "Timeout=$Timeout-"
  debugcont  "APIkey=$APIkey-"
  informcont "PROCESS_RECORDING_MODE=$PROCESS_RECORDING_MODE-"
  informcont "SYMLINK=$SYMLINK-"
  informcont "TargetPathIsInputPath=$TargetPathIsInputPath-"
  informcont "FailSafeMode=$FailSafeMode-"
  debugcont  "FailSafeDir=$FailSafeDir-"
  debugcont  "Notify=$Notify-"

  #Print a summary table of writeable directories.
  msg_dir_summary

  informcont "InputPath=$InputPath-"
  informcont "InputTitle=$InputTitle-"
  informcont "InputSubtitle=$InputSubtitle-"
  informcont "showtranslation=$showtranslation-"
  informcont "ShowName=$ShowName-"
  debugcont  "LastUpdatedTVDB=$LastUpdatedTVDB-"
  debugcont  "CurrentTimeTVDB=$CurrentTimeTVDB-"
  informcont "SeriesID=$SeriesID-"
  informcont "NewShowName=$NewShowName-"
  debugcont  "AbsoluteEpisodeNumber=$AbsoluteEpisodeNumber-"
  informcont "EpisodeSubtitle=$EpisodeSubtitle-"
  informcont "Sxx=$Sxx- Exx=$Exx-"
  informcont "MoveFileSize=$MoveFileSize MB"
  informcont "ConfidenceRating=$ConfidenceRating-"
  informcont "ConfidenceReasoning=$ConfidenceReasoning-"
  if [ "$Database" = 'Enabled' ]; then
    debugcont  "XMLTVGrabber=$XMLTVGrabber-"
    informcont "ShowStartTime=$ShowStartTime-"
    debugcont  "MovieAirDate=$MovieAirDate-"
    debugcont  "OriginalAirDate=$OriginalAirDate-"
    informcont "ProgramID=$ProgramID-"
    informcont "ChanID=$ChanID-"
    informcont "StorageGroup=$StorageGroup-"
    informcont "ShowCategory=$ShowCategory-"
    debugcont  "GoForDoover=$GoForDoover-"
    informcont "ProgramIDType=$ProgramIDType-"
    debugcont  "rating=$rating-"
    informcont "Zap2itSeriesID=$Zap2itSeriesID-"
    debugcont  "LocalSeriesID=$LocalSeriesID-"
    informcont "InputSeasonNum=$InputSeasonNum-"
    informcont "InputEpisodeNum=$InputEpisodeNum-"
    informcont "Plot=$Plot-"
    if [[ -n "$AbsoluteEpisodeNumber" ]]; then
      informcont "Matched Plot=$(sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir/$NewShowName/$NewShowName.Plot.txt")-"
    fi
  fi
  inform "################ END OF OPERATION SUMMARY ################"
}

check_filesystem(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Get file size for the recording we are processing.
  if [[ -f "$InputPath" ]]; then
    MoveFileSize=$(wc --bytes < "$InputPath")
  else
    MoveFileSize=1000000000 #default to ~1GB for diagnostics.
  fi
  MoveFileSize=$((MoveFileSize/1048576)) #Convert from Bytes to MB

  #Determine the free space available in all the directories we might use.
  WorkingDirFreeSpace=$(df -P "$m2kdir"             | sed -n 2p | awk '{print $4}') || WorkingDirFreeSpace=0
  OriginalDirFreeSpace=$(df -P "$originaldirname"   | sed -n 2p | awk '{print $4}') || OriginalDirFreeSpace=0
  MoveDirFreeSpace=$(df -P "$MoveDir"               | sed -n 2p | awk '{print $4}') || MoveDirFreeSpace=0
  AltMoveDirFreeSpace=$(df -P "$AlternateMoveDir"   | sed -n 2p | awk '{print $4}') || AltMoveDirFreeSpace=0
  MovieDirFreeSpace=$(df -P "$PrimaryMovieDir"      | sed -n 2p | awk '{print $4}') || MovieDirFreeSpace=0
  AltMovieDirFreeSpace=$(df -P "$AlternateMovieDir" | sed -n 2p | awk '{print $4}') || AltMovieDirFreeSpace=0
  ShowDirFreeSpace=$(df -P "$PrimaryShowDir"        | sed -n 2p | awk '{print $4}') || ShowDirFreeSpace=0
  AltShowDirFreeSpace=$(df -P "$AlternateShowDir"   | sed -n 2p | awk '{print $4}') || AltShowDirFreeSpace=0

  #Convert from kB to MB
  WorkingDirFreeSpace="$((WorkingDirFreeSpace/1024))"
  OriginalDirFreeSpace="$((OriginalDirFreeSpace/1024))"
  MoveDirFreeSpace="$((MoveDirFreeSpace/1024))"
  AltMoveDirFreeSpace="$((AltMoveDirFreeSpace/1024))"
  MovieDirFreeSpace="$((MovieDirFreeSpace/1024))"
  AltMovieDirFreeSpace="$((AltMovieDirFreeSpace/1024))"
  ShowDirFreeSpace="$((ShowDirFreeSpace/1024))"
  AltShowDirFreeSpace="$((AltShowDirFreeSpace/1024))"

  #Check write permissions and sufficiency of free space.
  check_write "$MoveFileSize" "$MoveDirFreeSpace"     "$MoveDir"
  MoveDirWritable="$?"
  check_write "$MoveFileSize" "$AltMoveDirFreeSpace"  "$AlternateMoveDir"
  AltMoveDirWritable="$?"
  check_write "$MoveFileSize" "$MovieDirFreeSpace"    "$PrimaryMovieDir"
  MovieDirWritable="$?"
  check_write "$MoveFileSize" "$AltMovieDirFreeSpace" "$AlternateMovieDir"
  AltMovieDirWritable="$?"
  check_write "$MoveFileSize" "$ShowDirFreeSpace"     "$PrimaryShowDir"
  ShowDirWritable="$?"
  check_write "$MoveFileSize" "$AltShowDirFreeSpace"  "$AlternateShowDir"
  AltShowDirWritable="$?"
  check_write "1"             "$OriginalDirFreeSpace" "$originaldirname"
  OriginalDirWritable="$?"
  check_write "5"             "$WorkingDirFreeSpace"  "$m2kdir"
  WorkingDirWritable="$?"
}

#This function provides basic testing of myth2kodi's functionality.
m2k_diagnostics(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Move any existing diagnostics file to diagnostics_<Date&Time script was launched>.log
  [[ -f "$DiagnosticsFile" ]] && mv "$DiagnosticsFile" "$m2kdir/diagnostics_${FileNameNow}.log"
  local PKGNAME_LIBMYTH_PYTHON=''
  local PKGNAME_PYTHON_LXML=''
  local PKGNAME_CURL=''
  local PKGNAME_AGREP=''
  local PKGNAME_LIBNOTIFY=''
  local PKGNAME_PYTHON=''
  local PKGNAME_JQ=''
  local PKGPATH_CURL=''
  local PKGPATH_AGREP=''
  local PKGPATH_LIBNOTIFY=''
  local PKGPATH_JQ=''
  local PKGPATH_PYTHON=''
  local python_version="" #Python Version information
  local pyver=0 #An integer representing first 2 points of python version, ie 2.6.3 => 26
  local packagecheck=""
  local DBTest=""
  local notifytest=""
  local PythonBindingsCheck=""
  local exitstatus
  inform "Diagnostic mode entered: $(date)"
  inform "myth2kodi will now conduct a series of tests."
  read -r -n1 -p "press any key to verify installed packages..."
  printf '\n'

  local -i bashlogging_file=0
  local -i mythdb_access_file=0
  local -i mythdb_access_exec=0
  local -i m2k_notify_file=0
  local -i m2k_notify_exec=0
  local -i our_scripts=0
  #Test if our own scripts are where they need to be and, if necessary, executable.
  if [[ -f "$binpath/bashlogging" ]]; then
    inform "Found: $binpath/bashlogging"
  else
    err "Can't Find: $binpath/bashlogging"
    bashlogging_file=1
  fi
  if [[ -f "$binpath/mythdb_access" ]]; then
    inform "Found: $binpath/mythdb_access"
    [[ -x "$binpath/mythdb_access" ]] || mythdb_access_exec=1
    if ((mythdb_access_exec==0)); then
      inform "Executable: $binpath/mythdb_access"
    else
      err "Not Executable: $binpath/mythdb_access"
    fi
  else
    err "Can't Find: $binpath/mythdb_access"
    mythdb_access_file=1
    mythdb_access_exec=1
  fi
  if [[ -f "$binpath/m2k_notify" ]]; then
    inform "Found: $binpath/m2k_notify"
    [[ -x "$binpath/m2k_notify" ]] || m2k_notify_exec=1
    if ((m2k_notify_exec==0)); then
      inform "Executable: $binpath/m2k_notify"
    else
      err "Not Executable: $binpath/m2k_notify"
    fi
  else
    err "Can't Find: $binpath/m2k_notify"
    m2k_notify_file=1
    m2k_notify_exec=1
  fi

  our_scripts=$((bashlogging_file+mythdb_access_file+mythdb_access_exec+m2k_notify_file+m2k_notify_exec))
  ((our_scripts!=0)) && err "Checks for our own scripts ***FAILED***"

  #Test if required packages are installed and accessible to caller.
  PKGPATH_CURL=$(command -v curl)             || PKGNAME_CURL="curl"
  PKGPATH_AGREP=$(command -v agrep)           || PKGNAME_AGREP="agrep or tre-agrep"
  PKGPATH_LIBNOTIFY=$(command -v notify-send) || PKGNAME_LIBNOTIFY="libnotify-bin"
  PKGPATH_JQ=$(command -v jq)                 || PKGNAME_JQ="jq"
  if [ "$DATABASE_ACCESS" = "PythonBindings" ]; then
    PKGPATH_PYTHON=$(command -v python) || PKGNAME_PYTHON="python"
    if [[ -z "$PKGNAME_PYTHON" ]]; then
      python_version="$(python --version 2>&1)"  #Python returns version info to stderr
      pyver="$(echo "$python_version" | sed 's/python\s*//I' | cut -f1-2 -d"." | tr -d '.')"
      python -c "from MythTV import MythDB ; exit()" &> /dev/null
      test "$?" != "0" && PKGNAME_LIBMYTH_PYTHON="libmyth-python"
      python -c "import lxml ; exit()" &> /dev/null
      test "$?" != "0" && PKGNAME_PYTHON_LXML="python-lxml"
    fi
  fi

  #Provide feedback on package checks
  packagecheck="$PKGNAME_CURL$PKGNAME_AGREP$PKGNAME_LIBNOTIFY$PKGNAME_JQ"
  printf '\n' | tee -a "$DiagnosticsFile"
  [[ -n "$PKGPATH_CURL" ]]      && inform "package 'curl' found: $PKGPATH_CURL"
  [[ -n "$PKGPATH_AGREP" ]]     && inform "package 'agrep' or 'tre-agrep' found: $PKGPATH_AGREP"
  [[ -n "$PKGPATH_LIBNOTIFY" ]] && inform "package 'libnotify-bin' found: $PKGPATH_LIBNOTIFY"
  [[ -n "$PKGPATH_JQ" ]]        && inform "package 'jq' found: $PKGPATH_JQ"
  if [ "$DATABASE_ACCESS" = "PythonBindings" ]; then
    packagecheck="$packagecheck$PKGNAME_PYTHON$PKGNAME_LIBMYTH_PYTHON$PKGNAME_PYTHON_LXML"
    [[ -n "$PKGPATH_PYTHON" ]] && inform "package 'python' found: $PKGPATH_PYTHON"
    if [[ -z "$PKGNAME_PYTHON" ]] && ((pyver < 27 || pyver >= 30)); then
      warn "Python 3 and Python older than 2.7 aren't supported."
      warncont "You'll need to set: DATABASE_ACCESS='MySQL' in user settings."
    fi
    [[ -z "$PKGNAME_LIBMYTH_PYTHON" ]] && inform "package 'libmyth-python' found."
    [[ -z "$PKGNAME_PYTHON_LXML" ]] && inform "package 'python-lxml' found."
  fi
  if [[ -n "$packagecheck" ]] ; then
    packagecheck="***FAILED***"
    err "Installed packages check ***FAILED***"
    errcont "Missing packages are: $PKGNAME_CURL $PKGNAME_AGREP $PKGNAME_LIBNOTIFY $PKGNAME_JQ $PKGNAME_PYTHON $PKGNAME_LIBMYTH_PYTHON $PKGNAME_PYTHON_LXML"
    errcont "If packages are already installed, check your path settings."
    if [ "$m2kPlatform" != "Darwin" ] ; then
      errcont "Please run 'apt-get install $PKGNAME_CURL $PKGNAME_AGREP $PKGNAME_LIBNOTIFY $PKGNAME_JQ $PKGNAME_PYTHON $PKGNAME_LIBMYTH_PYTHON $PKGNAME_PYTHON_LXML' or equivalent."
    else
      errcont "Please obtain MacPorts and install $PKGNAME_CURL $PKGNAME_AGREP $PKGNAME_LIBNOTIFY $PKGNAME_JQ $PKGNAME_LIBMYTH_PYTHON $PKGNAME_PYTHON_LXML"
      [[ -n "$PKGNAME_PYTHON" ]] && errcont "Python is missing, please install Python, or make sure it's in your path."
    fi
  else
    packagecheck="***PASSED***"
    inform "Installed packages check ***PASSED***"
  fi

  #If we're not on Mac OS X, check that user notification is working.
  if [ "$m2kPlatform" != "Darwin" ]; then
    read -r -n1 -p "Press any key to perform Desktop Message test..."
    printf '\n'
    inform "Performing m2k_notify test"
    informcont "This test verifies that the message was sent to the DBUS."
    informcont "This test does not verify the user has a valid desktop open."
    sudo -u "$NotifyUserName" "$binpath/m2k_notify" "myth2kodi test" "Testing Desktop Communications" "info"
    if [ "$?" = "0" ] ; then
      notifytest="***PASSED***"
      inform "Desktop Notifications test $notifytest"
    else
      notifytest="***FAILED***"
      warn "Desktop Notifications test $notifytest"
    fi
  else
    notifytest="   N/A"
  fi

  #If we'll be using MythTV python bindings, check that they're functioning.
  if [ "$DATABASE_ACCESS" = "PythonBindings" ]; then
    read -r -n1 -p "Press any key to perform a test of the MythTV Database python bindings..."
    printf '\n'
    inform "Performing MythTV Python Bindings database test."
    if [[ -z "$PKGNAME_PYTHON" ]]; then
      inform "Python: $PKGPATH_PYTHON"
      inform "Version: $python_version"
    fi

    #If checks above found python-lxml & libmyth-python, do a more thorough testing of MythTV python bindings
    if [[ -z "$PKGNAME_PYTHON$PKGNAME_LIBMYTH_PYTHON$PKGNAME_PYTHON_LXML" ]]; then
      #Use mythdb_access's internal diagnostics function
      "$binpath"/mythdb_access --verbosity="$((LOGLEVEL<3?LOGLEVEL:3))" \
                               --Diagnostic                             \
                               --DBHostName="$DBHostName"               \
                               --DBName="$MySQLMythDb"                  \
                               --DBUserName="$MySQLuser"                \
                               --DBPassword="$MySQLpass"                \
                               --SecurityPin="$DBPin" 2>&1 | err_pipe "mythdb_access: "
      if [[ "${PIPESTATUS[0]}" = "0" ]]; then
        PythonBindingsCheck="OK"
      else
        PythonBindingsCheck="FAILED"
      fi
      if [ "$PythonBindingsCheck" = "OK" ]; then
        inform "MythTV Python Bindings are installed properly."
        DBTest="***PASSED***"
        inform "MythTV Database Test $DBTest"
      else
        err "MythTV PythonBindings are not installed properly"
        errcont "there was a problem connecting to the database, check MythDatabase package."
        DBTest="***FAILED***"
        err "MythTV Database Test $DBTest"
      fi
    else
      DBTest="COULD NOT COMPLETE, SEE MISSING PACKAGES MENTIONED ABOVE."
      err "MythTV Database Test $DBTest"
    fi
  fi

  #Test communication with Kodi
  read -r -n1 -p "Press any key to perform KODI Notification test..."
  printf '\n'
  local curlPOST
  local KODINotifyTestMessage
  local data
  local KODIresp
  local -i KODI_COMM_FAILURES=0
  local GOOD_KODI_RESPONSE
  GOOD_KODI_RESPONSE='{"id":"myth2kodi","jsonrpc":"2.0","result":"OK"}'
  curlPOST='curl --silent --max-time 8 --connect-timeout 5 -H "Content-Type:application/json;" --data-binary'
  KODINotifyTestMessage="KODI Notification test..."
  data=\''{"jsonrpc": "2.0",
           "method": "GUI.ShowNotification",
           "params": {"title": "myth2kodi Test", "message": "'"$KODINotifyTestMessage"'"},
           "id": "myth2kodi"}'\'

  inform "Performing KODI Notification tests..."
  for KODIIP in "${KODIIPs[@]}" ; do
    inform "SENDING REQUESTED COMMANDS TO: $KODIIP"
    #SEE: http://kodi.wiki/view/HOW-TO:Remotely_update_library and 'man curl'
    KODIresp=$( eval "$curlPOST $data http://$KODIIP/jsonrpc" 2>&1 )
    debugcont "RESPONSE: $KODIresp"
    if [[ -n "$KODIresp" ]]; then
      if [[ "$(printf '%s' "$KODIresp")" = "$GOOD_KODI_RESPONSE" ]]; then
        inform "KODI Communications ***PASSED***"
      else
        err "KODI Communications ***FAILED***"
        errcont "Expected response: '$GOOD_KODI_RESPONSE'"
        errcont "Got response: '$KODIresp'"
        ((++KODI_COMM_FAILURES))
      fi
    else
      err "COMMUNICATIONS NOT ESTABLISHED: $KODIIP"
      errcont "This may just mean that the Kodi instance isn't running."
      ((++KODI_COMM_FAILURES))
    fi
  done
  if ((KODI_COMM_FAILURES==0)); then
    KODIcomm="***PASSED***"
  else
    KODIcomm="***FAILED***"
    err "Communication failed for $KODI_COMM_FAILURES of ${#KODIIPs[@]} Kodi instances."
  fi

  #Check filesystem permissions
  read -r -n1 -p "Press any key to test file system permissions..."
  printf '\n'
  inform "Testing file system permissions"

  #Set originaldir name if none was supplied
  [[ "$originaldirname" =~ ^('./'|'.'|'')$ ]] && originaldirname="$(pwd)"
  if [[ "$TargetPathIsInputPath" = 'Enabled' ]]; then
    inform "TargetPathIsInputPath is selected. Testing with current folder"
    set_target_dir_as_input_path_dir
  fi

  #Check write permissions and free space for Move and Working directories.
  check_filesystem

  #Print a summary table of writeable directories.
  msg_dir_summary

  if ((MoveDirWritable + AltMoveDirWritable + WorkingDirWritable == 0)) ; then
    folderchecks="***PASSED***"
    inform "Critical Filesystem checks $folderchecks"
  else
    folderchecks="***FAILED***"
    err "Critical Filesystem checks $folderchecks"
  fi
  if [ "$packagecheck" = "***PASSED***" ] && [ "$folderchecks" = "***PASSED***" ] ; then
    overallchecks="***PASSED***"
  else
    overallchecks="***FAILED***"
  fi
  if [ "$overallchecks" = "***PASSED***" ]; then
    read -r -n1 -p "press any key to test myth2kodi..."
    printf '\n'
    inform "Recordings Database is not used for testing."
    informcont "Performing fuzzy logic lookup on database file. Please wait."
    informcont "It may take a moment to build the myth2kodi database files."
    informcont "Executing: myth2kodi 'testfile.ext' 'mister rogers' 'show 1332'"
    informcont "Testing exit status..."

    myth2kodi 'testfile.ext' 'mister rogers' 'show 1332'
    exitstatus="$?"
    informcont  "exited with status $exitstatus"
    if [ "$exitstatus" = "0" ]; then
      mythicaltest="***PASSED***"
    else
      err "OVERALL FAILURE -- checks passed, but test run failed."
      mythicaltest="COULD NOT COMPLETE"
      overallchecks="***FAILED***"
    fi
  else
    err "OVERALL FAILURE"
    mythicaltest="COULD NOT COMPLETE"
  fi
  read -r -n1 -p "press any key to continue on to the final results..."
  printf '\n'
  inform "RESULTS SUMMARY:"
  [[ "$DATABASE_ACCESS" = "PythonBindings" ]] && informcont "MythTV Database Test: $DBTest"
  informcont "Installed Packages:   $packagecheck $PKGNAME_LIBMYTH_PYTHON $PKGNAME_PYTHON_LXML $PKGNAME_CURL $PKGNAME_AGREP $PKGNAME_LIBNOTIFY $PKGNAME_JQ"
  informcont "Notifications Test:   $notifytest"
  informcont "KODI Communications:  $KODIcomm"
  informcont "File System Checks:   $folderchecks"
  informcont "myth2kodi Testing:    $mythicaltest"

  informcont "Overall Readiness:    $overallchecks"
  informcont "-----End of diagnostics-----"
  printf '\n' | tee -a "$DiagnosticsFile"

  #Logging for failure messages
  if [ "$DBTest" = "***FAILED***" ]; then
    err "Database tests failed"
    errcont "When interfacing MythTV/0.24, myth2kodi uses MythTV's Python"
    errcont "Bindings. These must be configured and working for proper access"
    errcont "to data required by myth2kodi."
    errcont "Could not connect to the database. Check username and password."
    printf '\n' | tee -a "$DiagnosticsFile"
  #TODO: add more information on how to install
  fi

  if [ "$notifytest" = "***FAILED***" ]; then
    err "Notify tests failed"
    errcont "Notifications to the DBUS have failed. myth2kodi relies upon"
    errcont "m2k_notify and package lib-notify to display messages on"
    errcont "GNOME desktop interface. These messages will not be displayed. "
    printf '\n' | tee -a "$DiagnosticsFile"
  fi
  if [ "$KODIcomm" = "***FAILED***" ]; then
    err "Kodi communication tests failed: $KODI_COMM_FAILURES of ${#KODIIPs[@]}."
    errcont "This will not prevent myth2kodi from functioning, it just means"
    errcont "that myth2kodi can not send messages or library update requests"
    errcont "to Kodi. There are a few possible causes for this problem:"
    errcont "    1. One or more of the Kodi instances you specified in KODIIPs"
    errcont "       is not currently running. Start Kodi."
    errcont "    2. One or more of the Kodi instances is not configured to accept"
    errcont "       external network commands. See,"
    errcont "         Kodi->System->Settings->Services->Remote Control."
    errcont "         Kodi->System->Settings->Services->Web Server."
    errcont "    3. The settings you provided in KODIIPs are incorrect. Check"
    errcont "       that the IP addresses are correct. If you've set a user and"
    errcont "       password for http access in Kodi, make sure that you've also"
    errcont "       prepended them to the ip addresses in KODIIPs"
    errcont "         user:password@192..."
    errcont ""
    printf '\n' | tee -a "$DiagnosticsFile"
  fi
  if [ "$folderchecks" = "***FAILED***" ]; then
    err "The filesystem checks failed."
    errcont "First check that the Librarian user setting is correct, and that"
    errcont "you're running myth2kodi as that user. Currently Librarian='$Librarian'."
    errcont "The user '$Librarian' will need permission to read and write to all"
    errcont "relevant directories. If Librarian is the same user running MythTV, try:"
    errcont "  sudo chown -R $Librarian /Name/of/My_failed_folder"
    errcont "  chmod -R u+rw /Name/of/My_failed_folder"
    printf '\n' | tee -a "$DiagnosticsFile"
    errcont "If you've set the myth2kodi Librarian to a different user than the one"
    errcont "running MythTV then, while the above will work for myth2kodi specific"
    errcont "directories, for MythTV recording directories you'll need to add the"
    errcont "appropriate group to your myth2kodi Librarian and enable read/write."
    printf '\n' | tee -a "$DiagnosticsFile"
    errcont "It's also possible that the directory does not exist, in that case try:"
    errcont "  mkdir /Name/of/My_failed_folder"
    printf '\n' | tee -a "$DiagnosticsFile"
  fi
  if [ "$mythicaltest" != "***PASSED***" ]; then
    err "Test run of myth2kodi failed."
    errcont "myth2kodi has encountered an error. This may be due to a"
    errcont "lack of network connection. If the problem persists, try"
    errcont "reading then asking at: http://forum.kodi.tv/showthread.php?tid=65644" #TODO: If make public, change to new thread that I should've started.
    printf '\n' | tee -a "$DiagnosticsFile"
  fi
  if [ "$overallchecks" = "***FAILED***" ]; then
    inform "The issues mentioned above must be corrected for myth2kodi to perform correctly."
  fi

  inform "Diagnostic mode completed: $(date)"
  inform "A diagnostics log file was written to: $LOGFILE"

  test "$overallchecks" = "***FAILED***" && return 1

  return 0
}

#This function provides an easy way to redo failed jobs.
m2k_doover(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  [[ "$LOGTYPE" = "logfile" ]] && printf '%s\n' "WARNING: Recommend setting LOGTYPE='both', before proceeding.."
  local yesorno=""
  local dooverstatus

  warn "--You have entered doover mode."
  warncont "In this mode of operation, myth2kodi will be rerun against all"
  warncont "files which were moved in the past despite having low confidence."
  warncont "It is important that this process isn't interrupted or data loss may occur."
  ((DoOverBypass != 1)) && read -r -n1 -p "  Doover requested -- 'y' to continue, 'n' to exit... y/(n):>" yesorno && printf '\n'
  ((DoOverBypass == 1)) && yesorno="y"

  if [ "$yesorno" = "y" ] && [ -f "$m2kdir/doover.sh" ]; then
    debug "Running doover.sh"
    #NOTE: The first command in doover.sh is to delete the file doover.sh.
    cp "$m2kdir/doover.sh" "$m2kdir/doover_${FileNameNow}.sh"
    chmod +x "$m2kdir/doover.sh"
    "$m2kdir/doover.sh" 2>&1 | err_pipe "doover: "
    dooverstatus="${PIPESTATUS[0]}"
    #TODO: The dooverstatus is most likely the myth2kodi exit status for the
    #      last recording processed by doover.sh...
    if [[ "$dooverstatus" != 0 ]]; then
      err "${FUNCNAME[0]}(): Doover failed or was aborted by user."
    else
      inform "Finished running doover.sh."
      kodi_cleanup
    fi
    return "$dooverstatus"
  else
    if [[ -f "$m2kdir/doover.sh" ]]; then
      inform "You must press y to execute Doover."
      return 1
    else
      inform "No Doover jobs exist."
      return 0
    fi
  fi
  return 1
}

#This function provides an easy way to undo all myth2kodi jobs
m2k_undo_all(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  [[ "$LOGTYPE" = "logfile" ]] && printf '%s\n' "WARNING: Recommend setting LOGTYPE='both', before proceeding..."
  #TODO: Add permission checking.
  warn "--You have entered undo mode."
  warncont " In this mode of operation, myth2kodi will reverse"
  warncont " file changes created by the current user while running."
  warncont " myth2kodi. It is important that this process is not"
  warncont " interrupted or data loss may occur."
  local yesorno=""
  read -r -n1 -p "  Press 'y' to continue or 'n' to exit..... y/(n):>" yesorno
  printf '\n'
  if [ "$yesorno" = "y" ]; then
    local undostatus
    warn "Running undo.sh DO NOT INTERRUPT THIS PROCESS OR DATA LOSS MAY OCCUR."
    cp "$m2kdir/undo.sh" "$m2kdir/undo.lock"
    if [[ -f "$m2kdir/undo.sh" ]]; then
      cp "$m2kdir/undo.sh" "$m2kdir/undo_${FileNameNow}.sh"
      chmod +x "$m2kdir/undo.sh"
      "$m2kdir/undo.sh" 2>&1 | err_pipe "undo: "
      undostatus="${PIPESTATUS[0]}"
      if [[ "$undostatus" != 0 ]]; then
        err "undo failed or was aborted by user."
        return "$undostatus"
      else
        inform "Finished running undo.sh."
      fi
    fi
    rm -f "$m2kdir/undo.lock"

    #If we've undone everything then our doover.sh is no longer valid.
    if [[ -f "$m2kdir/doover.sh" ]]; then
      debug "Moving doover.sh to doover_${FileNameNow}.sh."
      mv "$m2kdir/doover.sh" "$m2kdir/doover_${FileNameNow}.sh"
    fi

    #If all processing was successfully undone, then calling the maintenance
    #routine should clean-up all files and dirs we were tracking.
    myth2kodi --maintenance

    #Our Kodi instances will still show entries their video libraries for all
    #the shows we just 'unmoved', so request them to perform cleanup.
    kodi_cleanup

    return 0
  else
    inform "You must press y to execute undo"
    return 0
  fi
  return 1
}

#This function provides the mechanism to undo a specified myth2kodi jobs
m2k_undo_all(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"

  #Check the provided file has been processed by myth2kodi.
  #Check that our MythTV-DB still contains entry for the recording.
  #Try and extract the undo entry from undo.sh
  #  ?Or, failing that, generate an undo command for this recording?
  #undo the myth2kodi processing
  #return status
}

##### HELP MESSAGES #####
#A message about what myth2kodi is, including current version and authors.
msg_about(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  printf ' %s\n\n' "$m2kVersion"
  printf ' %s\n' "myth2kodi automates the mapping of MythTV recordings to a Kodi library."
  printf ' %s\n\n' "It is a modified version of mythicalLibrarian."
  printf ' %s\n' "mythicalLibrarian Author: Adam Outler adamoutler(at)gmail.com"
  printf ' %s\n\n' "myth2kodi Author: Stuart Knock"
}

#A message describing the basic call patterns.
msg_usage(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  printf '\n %s\n' "myth2kodi usage:"
  printf '   %s\n' "myth2kodi 'path/to/file' ['title'] ['subtitle']"
  printf '   %s\n' "myth2kodi --mode [parameter] [parameter]"
  printf ' %s\n\n' "items in brackets are [context sensitive]."
  printf ' %s\n' "Before first use, check that myth2kodi's settings are"
  printf ' %s\n' "configured correctly for your system and be sure to run:"
  printf '   %s\n' "myth2kodi --diagnostics"
  printf ' %s\n\n' "before running in --scan mode or as a MythTV UserJob."
  printf ' %s\n' "For more information type:"
  [[ "$m2karg1" =~ ^('-h'|'-?'|'--help')$ ]] || printf '   %s\n' "myth2kodi --help"
  printf '   %s\n' "myth2kodi --config-help"
  printf '   %s\n\n' "myth2kodi --confidence"
}

#A message listing all the --option flags.
msg_options(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: Consider creating more detailed help messages for individual options,
  #      so that they can be called something like:
  #      myth2kodi --help maintenance
  printf '%s\n'   "myth2kodi mode flags:"
  printf '\n%s\n' "  --diagnostics"
  printf '%s\n'   "    Tests the functionality of myth2kodi"
  printf '%s\n'   "    eg. myth2kodi --diagnostics"
  printf '\n%s\n' "  --scan filetype /path/to/folder"
  printf '%s\n'   "    Creates a Kodi library from an entire folder"
  printf '%s\n'   "    eg. myth2kodi --scan mpg /home/mythtv/videos"
  printf '\n%s\n' "  --maintenance"
  printf '%s\n'   "    Removes any orphaned support files or empty directories"
  printf '%s\n'   "    we created for any previously processed recordings."
  printf '%s\n'   "    Also cleans-up myth2kodi's working directory."
  printf '%s\n'   "    eg. myth2kodi --maintenance"
  printf '\n%s\n' "  --doover"
  printf '%s\n'   "    Reruns previously run jobs for which we successfully moved"
  printf '%s\n'   "    and/or linked a recording despite a lack of confidence."
  printf '%s\n'   "    eg. myth2kodi --doover"
  printf '\n%s\n' "  --unmanned_doover"
  printf '%s\n'   "    Same as --doover but for use without human intervention"
  printf '%s\n'   "    eg. myth2kodi --unmanned_doover"
  printf '\n%s\n' "  --undo"
  printf '%s\n'   "    Returns all processed recordings to their original state."
  printf '%s\n'   "    There is an exception for recordings successfully processed"
  printf '%s\n'   "    with SYMLINK='Disabled', as MythTV-DB info has been deleted,"
  printf '%s\n'   "    these can not be undone. Also,recordings that have been"
  printf '%s\n'   "    deleted or disconnected cannot be undone."
  printf '%s\n'   "    eg. myth2kodi --undo"
  printf '\n%s\n' "  --series-info 'Series Name'"
  printf '%s\n'   "    Updates our local database tables for a specified series,"
  printf '%s\n'   "    ignoring lastupdated.time. Information is obtained from"
  printf '%s\n'   "    TheTVDB and tvmaze."
  printf '%s\n'   "    eg. myth2kodi --series-info 'Black Books'"
  printf '\n%s\n' "  --recording-info 'filename'"
  printf '%s\n'   "    Print the MythTV database information for the specified"
  printf '%s\n'   "    recording. "
  printf '%s\n'   "    eg. myth2kodi --recording-info '1099_20151210093000.mpg'"
  printf '\n%s\n' "  --movie 'filename'"
  printf '%s\n'   "    Specifies that the recording being processed is a movie."
  printf '%s\n'   "    eg. myth2kodi --movie '1099_20151210093000.mpg'"
  printf '\n%s\n' "  --delete '/path/to/file'"
  printf '%s\n'   "    Delete the file, any links to it and the associated database entry."
  printf '%s\n'   "    eg. myth2kodi --delete '/home/mythtv/recordings/1099_20151210093000.mpg'"
  printf '\n%s\n' "  --disconnect '/path/to/file'"
  printf '%s\n'   "    removes file & links from undo, doover, created.tracking,"
  printf '%s\n'   "    removes links from mythtv filename to moved filename, or"
  printf '%s\n'   "    if only 'moved' in LINK mode then actually move"
  printf '%s\n'   "    remove database entry"
  printf '%s\n'   "    eg. myth2kodi --disconnect '/home/mythtv/recordings/1099_20151210093000.mpg'"
  printf '\n%s\n' "  --log 'filename'"
  printf '%s\n'   "    Identify and display the log entries for the recording."
  printf '%s\n'   "    eg. myth2kodi --log '1099_20151210093000.mpg'"
  printf '\n%s\n' "  --comskip /path/to/folder/or/file"
  printf '%s\n'   "    Regenerates the comskip file for recordings that have"
  printf '%s\n'   "    already been moved. Argument can be either a single"
  printf '%s\n'   "    recording or a directory containing already moved recordings."
  printf '%s\n'   "    eg. myth2kodi --comskip '/home/mythtv/recordings/1099_20151210093000.mpg'"
  printf '%s\n'   "    eg. myth2kodi --comskip '/home/mythtv/recordings'"
  printf '\n%s\n' "  -?|-h|--help"
  printf '%s\n'   "    Displays this message"
  printf '%s\n'   "    example: myth2kodi --help"
  printf '\n%s\n' "  --config-help"
  printf '%s\n'   "    Special Help, displays extended configuration help."
  printf '%s\n'   "    example: myth2kodi --config-help"
  printf '\n%s\n' "   --confidence"
  printf '%s\n'   "    Confidence Help, displays information on improving confidence"
  printf '%s\n\n' "    example: myth2kodi --confidence"
}

#A message about myth2kodi configuration files
msg_config(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  printf '%s\n' " ======showTranslations====="
  printf '%s\n' " If you are having problems with incorrect guide data such"
  printf '%s\n' " as improper titling, use showTranslations."
  printf '%s\n' " showTranslations can be applied by creating a file called:"
  printf '%s\n' " $m2kdir/showTranslations"
  printf '%s\n' " ##############################################################"
  printf '%s\n' " #My Guide Show Title = www.TheTVDB.com Show Title            #"
  printf '%s\n' " #Battlestar Gallactica = Battlestar Gallactica (2003)        #"
  printf '%s\n' " #The Office = The Office (US)                                #"
  printf '%s\n' " #Millionaire = Who Wants To Be A Millionaire                 #"
  printf '%s\n' " #Aqua teen Hungerforce = Aqua Teen Hunger Force              #"
  printf '%s\n\n' " ##############################################################"
  printf '%s\n' "======titleIgnore======"
  printf '%s\n' " If wish to ignore all shows with a specific title, use titleIgnore"
  printf '%s\n' " titleIgnore can be applied by creating a file called:"
  printf '%s\n' " $m2kdir/titleIgnore"
  printf '%s\n' " ##############################################################"
  printf '%s\n' " #Show to ignore                                              #"
  printf '%s\n' " #Battlestar Gallactica                                       #"
  printf '%s\n' " #The Office                                                  #"
  printf '%s\n' " #Millionaire                                                 #"
  printf '%s\n' " #Aqua teen Hungerforce                                       #"
  printf '%s\n\n' " ##############################################################"
  printf '%s\n' "======categoricIgnore======"
  printf '%s\n' " If you wish to ignore all shows with a specific category, use"
  printf '%s\n' " categoricIgnore"
  printf '%s\n' " categoricIgnore can be applied by creating a file called:"
  printf '%s\n' " $m2kdir/categoricIgnore"
  printf '%s\n' " ##############################################################"
  printf '%s\n' " #Category to ignore                                          #"
  printf '%s\n' " #Sports                                                      #"
  printf '%s\n' " #Sports Talk                                                 #"
  printf '%s\n' " #College Sports                                              #"
  printf '%s\n' " #Comedy                                                      #"
  printf '%s\n\n' " ##############################################################"
  printf '%s\n' "======myth2kodi.conf====="
  printf '%s\n' " myth2kodi.conf allows you to take almost any setting from the"
  printf '%s\n' " top of the myth2kodi file and override it. Your settings will"
  printf '%s\n' " remain static when you replace the myth2kodi script with a"
  printf '%s\n\n' " newer version."
  printf '%s\n' " myth2kodi.conf can be applied by creating a file called:"
  printf '%s\n' "   $m2kdir/myth2kodi.conf"
  printf '%s\n' " ##############################################################"
  printf '%s\n' " #SYMLINK=Disabled                                            #"
  printf '%s\n' " #AlternateMoveDir=/media/usbDrive                            #"
  printf '%s\n' " #NotifyUserName=adam                                         #"
  printf '%s\n' " #KODIIPs=( user:password@192.168.1.110:8080 )                #"
  printf '%s\n' " #Database=Disabled                                           #"
  printf '%s\n\n' " ##############################################################"
}

#A message about enabling Kodi to access the RSS feed generated by myth2kodi
msg_rss(){
  printf '%s\n' "======myth2kodi-rss====="
  printf '%s\n' "  myth2kodi generates an RSS file that can be accessed as a feed"
  printf '%s\n' "  from within Kodi. It essentially contains a list of the most"
  printf '%s\n\n' "  recent successfully completed jobs."
  printf '%s\n' "  To access myth2kodi's RSS feed, you will need to edit:"
  printf '%s\n' "    /home/<kodi-user>/.kodi/userdata/RssFeeds.xml"
  printf '%s\n' "  and add myth2kodi's feed. If the Kodi instance is on the same"
  printf '%s\n' "  machine running myth2kodi then just replace or add to Kodi's"
  printf '%s\n' "  default feeds with something like:"
  printf '%s\n' "    <feed updateinterval=\"30\">/var/www/myth2kodi-rss/rss.xml</feed>"
  printf '%s\n' "  If you want to access it from a different machine than the one"
  printf '%s\n' "  running myth2kodi then you'll need a webserver enabled on the"
  printf '%s\n' "  myth2kodi machine and the entry should look something like:"
  printf '%s\n\n' "    <feed updateinterval=\"30\">http://[youripaddress]/myth2kodi-rss/rss.xml</feed>"
}

#A message explaining how to improve confidence ratings for you recordings.
msg_improve_confidence(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  printf '%s\n\n' "About Confidence ratings:"
  printf '%s\n' " Confidence Ratings are used by myth2kodi."
  printf '%s\n' " These ratings serve as a guide to the probability of a"
  printf '%s\n' " perfect match. Ratings range from +4 to -6.  Any rating"
  printf '%s\n\n' " at or above 0 should be considered a good match."
  printf '%s\n' "How can I improve my Confidence Rating?"
  printf '%s\n' " 1. myth2kodi --config-help provides information on how"
  printf '%s\n' "    to improve Episode matching confidence by using a"
  printf '%s\n' "    showTranslations file to compensate for bad guide data."
  printf '%s\n' " 2. Add your favorite show's Zap2it ID to TheTVDB.com."
  printf '%s\n' " 3. Add your favorite show's OriginalAirdate to TheTVDB.com."
  printf '%s\n\n' " 4. Add your favorite show's proper Title to TheTVDB.com"
}

#Force an update of the myth2kodi database tables for a specified Series.
get_series_info(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform "Searching for series: $InputTitle"
  ShowName="$InputTitle"
  local tvdbshowname
  tvdbshowname="$(sed 's/ /%20/g' <<< "$ShowName" | sed 's/&/%26/g')"
  download_series_identification
  (( $? != 0 )) && return 1
  get_serieslinenumber_showname_fuzzy
  #if we have a series line number then translate that into a series id
  if [[ -n "$serieslinenumber" ]] && ((serieslinenumber > 0)); then
    set_seriesid_newshowname_from_serieslinenumber
    inform "FOUND: $NewShowName ID#:$SeriesID"
    make_m2k_database_dir
  else
    warn "${FUNCNAME[0]}() SeriesID COULD NOT BE DETERMINED"
    #If we're not in debug mode then cleanup show identification files.
    [[ -f "$TMP_SID_FILE" ]] && (( LOGLEVEL < 3 )) && rm -f "$TMP_SID_FILE"
    [[ -f "$TMP_SHN_FILE" ]] && (( LOGLEVEL < 3 )) && rm -f "$TMP_SHN_FILE"
    return 1
  fi
  if [[ -n "$SeriesID" ]]; then
    download_series_info
    return "$?"
  else
    err "We had serieslinenumber: $serieslinenumber but couldn't get a SeriesID."
    return 1
  fi
}

#Given a recording file or link find the associated link or file.
#Full paths are returned via RECORDING_FILE and RECORDING_LINK variables.
#It's possible to get RECORDING_LINK='' if recording is disconnected from MythTV.
find_file_link_pairs(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "arg1: $1"
  #Takes a single argument
  (( "$#" > 1 )) && { err "${FUNCNAME[0]}() only takes one arg."; return 1 ; }
  local FILE="$1"
  [[ -e "$FILE" ]] || { err "Doesn't exist: $FILE"; return 1; }
  #A regex that should match MythTVs file naming, for the 21st century.
  local RECPATTERN='[0-9]{4}_20[0-9]{2}[0-1][0-9][0-3][0-9][0-2][0-9][0-5][0-9]{3}'
  #Is FILE a link or a file
  if [[ -L "$FILE" ]]; then
    #FILE is a link, grab its target.
    RECORDING_LINK="$(realpath --no-symlinks "$FILE")"
    RECORDING_FILE="$(readlink "$FILE")"
    [[ -f "$RECORDING_FILE" ]] || { err "Broken link: $RECORDING_FILE"; return 1; }
    [[ -L "$RECORDING_FILE" ]] && { err "Multiple links, not following: $RECORDING_FILE"; return 1; }
    if [[ "$RECORDING_FILE" =~ $RECPATTERN ]]; then #NOTE: Don't quote the RHS.
      RECORDING_FILE_OWNER='MythTV'
      RECORDING_LINK_OWNER='myth2kodi'
    elif [[ "$RECORDING_LINK" =~ $RECPATTERN ]]; then #NOTE: Don't quote the RHS.
      RECORDING_FILE_OWNER='myth2kodi'
      RECORDING_LINK_OWNER='MythTV'
    fi
    return 0
  elif [[ -f "$FILE" ]]; then
    #FILE is a file,
    RECORDING_FILE="$(realpath "$FILE")"
    local -i found=1 #Use exit code convention of 0=success 1=failure.
    local -a check_dirs
    local LINK_NAME
    if [[ "$RECORDING_FILE" =~ $RECPATTERN ]]; then #NOTE: Don't quote the RHS.
      #FILE is a MythTV file name, check if there is a link to FILE from a myth2kodi target directory
      RECORDING_FILE_OWNER='MythTV'
      RECORDING_LINK_OWNER='myth2kodi'
      check_dirs=("$MoveDir" "$PrimaryMovieDir" "$PrimaryShowDir" "$AlternateMoveDir" "$AlternateMovieDir" "$AlternateShowDir")
    else
      #FILE is a moved file name, check if there is a link to FILE from a StorageGroup Directory
      RECORDING_FILE_OWNER='myth2kodi'
      RECORDING_LINK_OWNER='MythTV'
      check_dirs=($("$binpath"/mythdb_access --storagegroups            \
                                             --SecurityPin="$DBPin"     \
                                             --DBHostName="$DBHostName" \
                                             --DBName="$MySQLMythDb"    \
                                             --DBUserName="$MySQLuser"  \
                                             --DBPassword="$MySQLpass"))
    fi
    for check_dir in "${check_dirs[@]}" ; do
      LINK_NAME="$(find -L "$check_dir" -samefile "$RECORDING_FILE")"
      [[ -L "$LINK_NAME" ]] && { found=0 ; break ; }
    done
    (( found == 0 )) && { RECORDING_LINK="$(realpath --no-symlinks "$LINK_NAME")"; return 0; }
    if [[ ! "$RECORDING_FILE" =~ $RECPATTERN ]]; then
      warn "No link found to: $RECORDING_FILE"
      warncont "Assuming recording has been disconnected from MythTV."
      RECORDING_LINK=""
      return 0
    fi
    warn "Can't find link to: $RECORDING_FILE"
    warncont "This probably means that the file hasn't been successfully processed by myth2kodi."
    return 0
  else
    err "Not a file or link: $FILE"
    return 1
  fi
}

#Sets the RECORDING_NAME variable. If the arg is a MythTV recording file then
#it just sets as basename, if given a myth2kodi moved name then, if possible,
#we find the corresponding MythTV recording name.
set_recording_name(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "arg1: $1"
  #Takes a single argument
  (( "$#" > 1 )) && { err "${FUNCNAME[0]}() only takes one arg."; return 1 ; }
  #A regex that should match MythTVs file naming, for the 21st century.
  local RECPATTERN='[0-9]{4}_20[0-9]{2}[0-1][0-9][0-3][0-9][0-2][0-9][0-5][0-9]{3}'
  local -i found=1 #Use exit code convention of: 0=success; 1=failure.
  if [[ "$1" =~ $RECPATTERN ]]; then #NOTE: Don't quote the RHS.
    #Is a MythTV recording.
    found=0
    RECORDING_NAME="$1"
  else
    #In this case we need a full or relative path
    [[ -f "$1" ]] || { err "${FUNCNAME[0]}(): arg1 isn't a file."; return 1; }
    #Check if it's a moved file name that's still tracked by MythTV
    local -a sg_dirs
    #Get the sorage group directories defined in MythTV-DB
    sg_dirs=($("$binpath"/mythdb_access --storagegroups            \
                                        --SecurityPin="$DBPin"     \
                                        --DBHostName="$DBHostName" \
                                        --DBName="$MySQLMythDb"    \
                                        --DBUserName="$MySQLuser"  \
                                        --DBPassword="$MySQLpass"))
    #TODO: should check return state...
    for sg_dir in "${sg_dirs[@]}" ; do
      RECORDING_NAME="$(find -L "$sg_dir" -samefile "$1")"
      [[ "$RECORDING_NAME" =~ $RECPATTERN ]] && { found=0 ; break ; }
    done
    (( found == 0 )) && inform "Mapping myth2kodi file name to $RECORDING_NAME"
  fi
  if (( found == 0 )); then
    RECORDING_PATH="$(realpath --no-symlinks "$RECORDING_NAME")"
    RECORDING_NAME="$(basename "$RECORDING_NAME")"
    debug "Setting RECORDING_PATH='$RECORDING_PATH'"
    debug "Setting RECORDING_NAME='$RECORDING_NAME'"
    return 0
  else
    err "${FUNCNAME[0]}(): Failed to find MythTV-DB recording name for: $1"
    return 1
  fi
}

#Delete: the recording file and any links to it; associated database entry and
#        thumbnails; any undo, doover or created.tracking entries; and any
#        associated support files (comskip, NFO).
delete_recording(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  warn "Attempting to delete recording: $1"
  warncont "This will PERMANENTLY delete the recording, associated files"
  warncont "and the associated MythTV database entry."
  warncont "Are you sure you want to continue?"
  local yesorno=""
  read -r -n1 -p "  Requested permanent deletion: 'y' to continue or 'n' to exit... y/(n):>" yesorno
  printf '\n'
  [[ "$yesorno" != 'y' ]] && { inform "You must press 'y' to continue, aborting."; return 1 ; }

  #Find the recording file and any link to it.
  find_file_link_pairs "$1"
  [[ "$?" != 0 ]] && return "$?"
  debug "RECORDING_LINK: $RECORDING_LINK"
  debug "RECORDING_LINK_OWNER: $RECORDING_LINK_OWNER"
  debug "RECORDING_FILE: $RECORDING_FILE"
  debug "RECORDING_FILE_OWNER: $RECORDING_FILE_OWNER"

  #Find the MythTV recording file name and its path.
  set_recording_name "$1"
  [[ "$?" != 0 ]] && return "$?"
  InputPath="$RECORDING_PATH"
  InputFileBasename="$RECORDING_NAME"

  #TODO: Consider moving the DATABASE_ACCESS method logic below into the function
  #      delete_mythtv_database_entry(), so all calls respect DATABASE_ACCESS.
  #Delete the recording file and its associated DB entry
  case "$DATABASE_ACCESS" in
    MySQL)
      #Delete the recording file and any link to it.
      [[ -f "$RECORDING_LINK" ]] && rm -f "$RECORDING_LINK"
      [[ -f "$RECORDING_FILE" ]] && rm -f "$RECORDING_FILE"

      #Delete the associated database entry and thumbnails.
      delete_mythtv_database_entry
      ;;
    PythonBindings)
      local MTV_RECINFO_FILE
      MTV_RECINFO_FILE="$(mktemp "$M2K_TMPDIR/m2k_delrecinfo_$FileNameNow"-XXXX)"
      [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
      debug "Deleted recording info will be stored temporary file: '$MTV_RECINFO_FILE'"

      #Ask mythbackend to delete the recording (ther is typically a delay of 5-10 min).
      "$binpath"/mythdb_access --verbosity="$((LOGLEVEL<3?LOGLEVEL:3))" \
                               --filename="$InputFileBasename"          \
                               --SecurityPin="$DBPin"                   \
                               --DBHostName="$DBHostName"               \
                               --DBName="$MySQLMythDb"                  \
                               --DBUserName="$MySQLuser"                \
                               --DBPassword="$MySQLpass"                \
                               --output="$MTV_RECINFO_FILE"             \
                               --writeFile                              \
                               --delete 2>&1 | err_pipe "mythdb_access: "
      ;;
    *)
      NOTIFY_MSG="DATABASE_ACCESS incorrectly specified."
      err "${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
      EXIT_JOB_TYPE='UserSettingError'
      return 1
      ;;
  esac

  #Delete undo.sh entries associated with $RECORDING_NAME
  debug "Removing lines mentioning '$RECORDING_NAME' from $m2kdir/undo.sh"
  sed -i.bak "\#$RECORDING_NAME#d" "$m2kdir/undo.sh" 2>&1 | err_pipe "${FUNCNAME[0]}(): Line $LINENO: "
  (( LOGLEVEL < 3 )) && rm -f "$m2kdir/undo.sh.bak"

  #Delete doover.sh entries associated with $RECORDING_NAME
  if [[ -f "$m2kdir/doover.sh" ]]; then
    debug "Removing lines mentioning '$RECORDING_NAME' from $m2kdir/doover.sh"
    sed -i.bak "\#$RECORDING_NAME#d" "$m2kdir/doover.sh" 2>&1 | err_pipe "${FUNCNAME[0]}(): Line $LINENO: "
    (( LOGLEVEL < 3 )) && rm -f "$m2kdir/doover.sh.bak"
  fi

  #Delete created.tracking entries associated with recording.
  if [[ "$RECORDING_FILE_OWNER" = 'myth2kodi' ]]; then
    debug "File tracked by myth2kodi."
    debug "Removing lines mentioning '$RECORDING_FILE' from $m2kdir/created.tracking"
    sed -i.bak "\#$RECORDING_FILE#d" "$m2kdir/created.tracking" 2>&1 | err_pipe "${FUNCNAME[0]}(): Line $LINENO: "
  elif [[ "$RECORDING_LINK_OWNER" = 'myth2kodi' && -n "$RECORDING_LINK" ]]; then
    debug "Link tracked by myth2kodi."
    debug "Removing lines mentioning '$RECORDING_LINK' from $m2kdir/created.tracking"
    sed -i.bak "\#$RECORDING_LINK#d" "$m2kdir/created.tracking" 2>&1 | err_pipe "${FUNCNAME[0]}(): Line $LINENO: "
  fi
  (( LOGLEVEL < 3 )) && rm -f "$m2kdir/created.tracking.bak"

  #Delete any comskip or NFO files associated with the recording.
  if [[ "$RECORDING_FILE_OWNER" = 'myth2kodi' ]]; then
    rm -f "${RECORDING_FILE%.*}.nfo"
    rm -f "${RECORDING_FILE%.*}.txt"
  elif [[ "$RECORDING_LINK_OWNER" = 'myth2kodi' ]]; then
    rm -f "${RECORDING_LINK%.*}.nfo"
    rm -f "${RECORDING_LINK%.*}.txt"
  fi
  return 0
}

disconnect_recording(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  warn "Attempting to disconnect recording: $1"
  warncont "This will PERMANENTLY disconnect the recording from MythTV,"
  warncont "deleting the associated MythTV database entry."
  warncont "Are you sure you want to continue?"
  local yesorno=""
  read -r -n1 -p "  Requested permanent disconnection: 'y' to continue or 'n' to exit... y/(n):>" yesorno
  printf '\n'
  [[ "$yesorno" != 'y' ]] && { inform "You must press 'y' to continue, aborting."; return 1 ; }

  #Find the recording file and any link to it.
  find_file_link_pairs "$1"
  [[ "$?" != 0 ]] && return "$?"
  debug "RECORDING_LINK: $RECORDING_LINK"
  debug "RECORDING_LINK_OWNER: $RECORDING_LINK_OWNER"
  debug "RECORDING_FILE: $RECORDING_FILE"
  debug "RECORDING_FILE_OWNER: $RECORDING_FILE_OWNER"

  #Find the MythTV recording file name and its path.
  set_recording_name "$1"
  [[ "$?" != 0 ]] && return "$?"
  debug "RECORDING_PATH: $RECORDING_PATH"
  debug "RECORDING_NAME: $RECORDING_NAME"
  InputPath="$RECORDING_PATH"
  InputFileBasename="$RECORDING_NAME"

  #Remove link associated with recording, and if recording file still has a
  #MythTV name ('moved' in LINK mode) then actually move it to myth2kodi name.
  [[ -L "$RECORDING_LINK" ]] && rm -f "$RECORDING_LINK"
  if [[ "$RECORDING_FILE_OWNER" = 'MythTV' ]]; then
    mv "$RECORDING_FILE" "$RECORDING_LINK"
  fi

  #Delete the associated database entry and thumbnail
  delete_mythtv_database_entry

  #Delete undo.sh entries associated with $RECORDING_NAME
  debug "Removing lines mentioning '$RECORDING_NAME' from $m2kdir/undo.sh"
  sed -i.bak "/$RECORDING_NAME/d" "$m2kdir/undo.sh"
  (( LOGLEVEL < 3 )) && rm -f "$m2kdir/undo.sh.bak"

  #Delete doover.sh entries associated with $RECORDING_NAME
  debug "Removing lines mentioning '$RECORDING_NAME' from $m2kdir/doover.sh"
  sed -i.bak "/$RECORDING_NAME/d" "$m2kdir/doover.sh"
  (( LOGLEVEL < 3 )) && rm -f "$m2kdir/doover.sh.bak"

  #Delete created.tracking entries associated with recording.
  if [[ "$RECORDING_FILE_OWNER" = 'myth2kodi' ]]; then
    debug "File tracked by myth2kodi."
    debug "Removing lines mentioning '$RECORDING_FILE' from $m2kdir/created.tracking"
    sed -i.bak "\#$RECORDING_FILE#d" "$m2kdir/created.tracking"
  elif [[ "$RECORDING_LINK_OWNER" = 'myth2kodi' && -n "$RECORDING_LINK" ]]; then
    debug "Link tracked by myth2kodi."
    debug "Removing lines mentio ning '$RECORDING_LINK' from $m2kdir/created.tracking"
    sed -i.bak "\#$RECORDING_LINK#d" "$m2kdir/created.tracking"
  fi
  (( LOGLEVEL < 3 )) && rm -f "$m2kdir/created.tracking.bak"

  return 0
}

#Displays the log entries for processing of a specified recording file.
recording_log(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Process all the log files in our working directory and:
  #  Select only recording processing entries;
  #  Make each recording processing entry into an awk 'record';
  #  Print only records containing RECORDING_NAME, slightly formatted:
  #    two blank lines between records;
  #    prepend each record with the name of the log file it came from.
  local PROC='@@@@ PROCESSING RECORDING:'
  local COMP='@@@@ COMPLETE:'
  local LOGFILEPATTERN="${LogFileName}_20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]*.gz"
  local LOG_FILE
  local LOGFILELIST_FILE
  local TEMPLOG_FILE
  #Find the MythTV recording file name and its path.
  set_recording_name "$1"
  [[ "$?" != 0 ]] && return "$?"
  debug "RECORDING_PATH: $RECORDING_PATH"
  debug "RECORDING_NAME: $RECORDING_NAME"
  LOGFILELIST_FILE="$(mktemp "$M2K_TMPDIR"/m2k_logfilelist-XXXX)"
  [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
  debug "Created a temporary list of logfiles file: $LOGFILELIST_FILE"
  TEMPLOG_FILE="$(mktemp "$M2K_TMPDIR"/m2k_templog-XXXX)"
  [[ "$?" != 0 ]] && { err "Failed to create temporary file." ; return 1 ; }
  debug "Created a temporary recording-specific log file: $TEMPLOG_FILE"
  #Start a log file list with the current log file
  printf '%s\n' "$LOGFILE" > "$LOGFILELIST_FILE"
  #Add archived log files to the list, most recent first
  find "$m2kdir" -maxdepth 1 -type f -name "$LOGFILEPATTERN" | sort -r >> "$LOGFILELIST_FILE"
  #Create a temporary log file for this recording
  printf '%s\n\n' "#### Log entries for: $RECORDING_NAME ####" > "$TEMPLOG_FILE"
  while read -r LOG_FILE ; do
    if [[ "${LOG_FILE##*.}" = 'gz' ]]; then
      if gzip -dc "$LOG_FILE" 2>/dev/null | grep -q "$PROC" ; then
        debug "Searching for relevant entries in: $LOG_FILE"
        awk '/'"$PROC"'/,/'"$COMP"'/ {print $0}' <(gzip -dc "$LOG_FILE") \
          | awk -v RS="$PROC" -v OFS='\n' -v ORS='\n\n'                  \
              '$0~/'"${RECORDING_NAME%%.}"'/{print "'"$LOG_FILE"'",RS$0}' >> "$TEMPLOG_FILE"
      fi
    elif [[ "${LOG_FILE##*.}" = 'log' ]]; then
      #Confirm the log file actually contains a process recording entry
      if grep -q "$PROC" "$LOG_FILE" ; then
        debug "Searching for relevant entries in: $LOG_FILE"
        awk '/'"$PROC"'/,/'"$COMP"'/ {print $0}' "$LOG_FILE" \
          | awk -v RS="$PROC" -v OFS='\n' -v ORS='\n\n'      \
              '$0~/'"${RECORDING_NAME%%.}"'/{print "'"$LOG_FILE"'",RS$0}' >> "$TEMPLOG_FILE"
      fi
    else
      warn "Unrecognised log file match: $LOG_FILE"
    fi
  done < "$LOGFILELIST_FILE"
  (( LOGLEVEL < 3 )) && rm -f "$LOGFILELIST_FILE"
  #
  if (( $(wc --lines < "$TEMPLOG_FILE") > 2 )); then
    debug "Viewing log entries for $RECORDING_NAME in less."
    less "$TEMPLOG_FILE"
    debug "Finished viewing."
    (( LOGLEVEL < 3 )) && rm -f "$TEMPLOG_FILE"
    return 0
  else
    inform "There don't appear to be any processing entries for: $1"
    printf '%s\n' "#### NO ENTRIES FOUND ####" >> "$TEMPLOG_FILE"
    return 1
  fi
}

success_postprocessing(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"

  #Move comskip data to proper folder and add created.tracking entry.
  if [[ "$CommercialMarkup" = "Created" ]]; then
    mv "$MARKUPFRAMES_TMP" "$MoveDir/$ShowFileName.txt"
    if [[ "$TRACKING" = 'Enabled' ]]; then
      printf '%s\n' "'$MoveDir/$ShowFileName.txt' '$MoveDir/$ShowFileName.$OriginalExt'" >> "$m2kdir/created.tracking"
    fi
  fi

  #Additional features, notifications, rss, daily report.
  [[ "$RequiresNFO" = "1" ]] && generate_episode_nfo
  kodi_newshow
  add_undo
  [[ "$RequiresDoover" = "1" ]] && add_doover
  dailyreport
  [[ "$CREATE_RSS" == 'Enabled' ]] && generaterss
  if [[ "$PROCESS_RECORDING_MODE" = 'MOVE' && "$SYMLINK" = 'Disabled' ]]; then
    set_group_permission
  fi
}

########################### END FUNCTION DEFINITIONS ###########################


######################### BEGIN MAIN PROGRAM ###################################

#TODO: The permission handling stuff seems a bit convoluted, I also think I've
#  found at least a few bugs. It would seem far simpler to enforce a dedicated
#  user to function as the "Librarian". That is add a Librarian= to the user
#  settings at the start of this file. Probably with the default of
#  Librarian="mythtv" for maximum compatibility with existing expectations of
#  the code... Then simply refuse to run with a helpful error message if the
#  variable $CALLER doesn't equal $Librarain. The requirement would just be
#  that the user $Librarian be the one running MythTV and that they have write
#  privileges to the MoveDirs that Kodi can see. Then most/all of the need for
#  running commands with sudo and the need for undo to be run as root can be
#  removed... Need to check expectations of mythdb_access and other auxiliary
#  functions before making this change.

#TODO: At some point this main needs to be cleaned up, at the moment it's a
#  little bit too organic, final structure should be something like:
main(){

  #Capture args the script was called with.
  m2karg_count="$#"
  m2karg1="$1" ; m2karg2="$2" ; m2karg3="$3" ; m2karg4="$4"

  #Make them read-only so we can't accidentally modify them.
  declare -gr m2karg_count m2karg1 m2karg2 m2karg3 m2karg4

  #Initial setup: override defaults with myth2kodi.conf; initialise logging system.
  m2k_init

  #Basic tests to make sure we were called correctly.
  validate_args
  [[ "$?" != 0 ]] && exit_job "$EXIT_JOB_TYPE"

  #If the first arg is a command line switch, figure out what to do.
  if [[ "${m2karg1:0:1}" = "-" ]]; then
    parse_command_flags
    exit_job "$EXIT_JOB_TYPE"
  fi
  debug "No command flag set. Processing as recording."

#    #If trying to move a recording, get info from command line
#    #Command line sanity checks
#    #Now we have all important settings, and know we're not performing some other function,
#     do filesystem checks etc -- no point doing a lot of work if we can't move anything at the end..
#    #Do we have enough info from the command line to move, if so jump to verify
#    #If not: Get info from the MythTV-DB
#    #MythTV-DB Guide data basic/common post processing, then sanity checks.
#    #Do we have enough info to move, if so jump to verify
#    #If still lacking information, try matching against TheTVDB info
#      #If SchedulesDirect, check zap2it
#      #If US, check airdate
#      #If SxxExx but no EpisodeTitle, use SxxExx to get EpisodeTitle.
#      #If EpisodeTitle but no SxxExx, use EpisodeTitle to get SxxExx.
#      #If No SxxExx and no EpisodeTitle: check against Plot.
#    #Verify: do checks to make sure what we're moving and where we're moving it too makes sense,
#             and that we have good confidence that the names we're using are correct.
#    #IF WE'RE NOT CONFIDENT OR ANYTHING ELSE DURING THE ABOVE STEPS IS WRONG, WRITE JOB TO DOOVER, REPORT WHAT WENT WRONG, BUT OTHERWISE DO NOTHING!
#    #Move file...
#    #Notify Kodi, RSS, and whoever else wanted to know that we're done and what it is we've done.
#    #THE END
}

#Capture args the script was called with.
m2karg_count="$#"
m2karg1="$1" ; m2karg2="$2" ; m2karg3="$3" ; m2karg4="$4"
#Make them read-only so we can't accidentally modify them.
declare -r m2karg_count m2karg1 m2karg2 m2karg3 m2karg4

#Do initial setup: override defaults with myth2kodi.conf; initialise logging system.
m2k_init

#TODO: Make proper arg parser...
#TODO: Set the inputs as fixed (read-only) parameters, then use different variables consistently if we need to modify them...
InputPath="$1"
InputTitle="$2"
InputSubtitle="$3"
#TODO: Should allow manual input of season and episode numbers in addition to
#  Title & Subtitle, with full information all searching should be overridden/bypassed...
#  Issue warnings for any conflicts. but don't override command line arguments...
#InputSxx="$4"
#InputExx="$5"
#InputCategory="%6" #So we can specify that it's a Movie...

#Some basic tests to make sure we were called correctly
validate_args
[[ "$?" != 0 ]] && exit_job "$EXIT_JOB_TYPE"

#If the first arg is a command line switch, figure out what to do.
if [[ "${m2karg1:0:1}" = "-" ]]; then
  parse_command_flags
  exit_job "$EXIT_JOB_TYPE"
fi
debug "No command flag set. Processing as recording."

#Initial log entry for the processing of recording, regardless of LOGLEVEL.
{
  printf '%s\n' "@@@@ PROCESSING RECORDING: $(date --rfc-3339=seconds) @@@@"
  printf '%s\n' "$m2kVersion on $m2kPlatform"
} >> "$LOGFILE"
PROCESSING_RECORDING="True"
inform "Processing: $InputPath"

InputFileBasename="$(basename "$InputPath")" #"${InputPath##*/}"

#As long as we're not in diagnostics mode, gather info from MythTV-DB.
if [[ "$m2kDiagnosticsMode" != "True" ]]; then
  process_mythtvdb
  [[ "$?" != 0 ]] && exit_job "$EXIT_JOB_TYPE"
else
  [[ "$Database" = 'Enabled' ]] && inform "Temporarily disabling access to MythTV-DB -- for diagnostics."
  Database='Disabled'
fi
msg_merged_input_mythtvdb

#At this point we should have an initial show name, if not then abort.
ShowName="$InputTitle"
if [[ -z "$ShowName" ]]; then
  NOTIFY_MSG="Unable to set ShowName."
  msg_usage
  exit_job 'GenericUnspecifiedError'
fi
#Check for show Title translations relating to the show in question.
show_translation

#Do not process files in files categoricIgnore or titleIgnore, just exit
process_ignore_lists
[[ "$?" != 0 ]] && exit_job "$EXIT_JOB_TYPE"

#TODO: check whether the split on semicolon here and elsewhere should be in process_mythtvdb_schedulesdirect
#split on semicolon, there will only be one episode looked up.
EpisodeSubtitle="$(sed 's/;.*//' <<< "$InputSubtitle")"
#Only keep Alpha-numeric characters, space, parenthesis and the four chars & , . -
EpisodeSubtitle="$(sed -r 's/[^[:alnum:] &,.)(-]//g' <<< "$EpisodeSubtitle")"
OriginalExt="${InputFileBasename#*.}" #TODO: Should be "${InputFileBasename##*.}" ???
originaldirname="$(dirname "$InputPath")"
#Set originaldir name if none was supplied
[[ "$originaldirname" =~ ^('./'|'.'|'')$ ]] && originaldirname="$(pwd)"

#TODO: Again with the split on semicolon???
SafeShowName=$(sed 's/;.*//' <<< "$ShowName") #TODO: ??? ${ShowName%%;*}
#Only keep Alpha-numeric characters, space, parenthesis and the four chars & , . -
SafeShowName="$(sed -r 's/[^[:alnum:] &,.)(-]//g' <<< "$SafeShowName")"
#Format Show name for Sending to www.TheTVDB.com and KODI
tvdbshowname=$(sed 's/ /%20/g' <<< "$ShowName" | sed 's/&/%26/g')

#Reset move paths if TargetPathIsInputPath is active, creating dirs as needed.
if [[ "$TargetPathIsInputPath" = 'Enabled' ]]; then
  inform "TargetPathIsInputPath=Enabled. Resetting paths, creating directories."
  set_target_dir_as_input_path_dir
fi

#####MAINTENANCE#####
#check for interrupted undo jobs
[[ -f "$m2kdir/undo.lock" && ! -f "$m2kdir/undo.sh" ]] && mv "$m2kdir/undo.lock" "$m2kdir/undo.sh"

#From time-to-time check created.tracking, dir.tracking, and remove orphans.
periodic_maintenace

#####SEARCH FOR SHOW AND BUILD INFORMATION#####

#Process as though it's an episode of a tv series.
if [[ "$m2kProgramIDCheck" != "SH" && "$m2kProgramIDCheck" != "MV" ]]; then
  #Query TheTVDB on show title, then return a list of Zap2itID, ShowName and seriesid.
  download_series_identification
  if [[ "$?" = 0 ]]; then
    #Start by trying to match on Zap2itID
    ConfidenceReasoning="$ConfidenceReasoning Attempted Match On Zap2itID:"
    [[ -n "$Zap2itSeriesID" ]] && { get_serieslinenumber_zap2itid ; zap2itid_exitstatus="$?" ; }
    (( LOGLEVEL < 3 )) && rm -f "$TMP_ZAP2IT_FILE"
    if [[ "$zap2itid_exitstatus" = 0 ]]; then
      ((++SeriesConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Successful;"
      inform "MATCH FOUND BASED ON Zap2itID: $NewShowName"
    else
      ((--SeriesConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Failed;"
    fi

    #If Zap2itSeriesID match failed to find the SeriesLineNumber
    if (( SeriesConfidenceRating <= 0 )); then
      ConfidenceReasoning="$ConfidenceReasoning Attempted match on Standard Logic:"
      [[ -n "$ShowName" ]] && get_serieslinenumber_showname
      if [[ "$?" = 0 ]]; then
        ConfidenceReasoning="$ConfidenceReasoning Successful;"
      else
        warn "FAILED to get series line number from table with standard logic, requiring doover."
        RequiresDoover=1
        ((--SeriesConfidenceRating))
        ConfidenceReasoning="$ConfidenceReasoning Failed; Attempted Title match on Fuzzy Logic:"
        [[ -n "$ShowName" ]] && get_serieslinenumber_showname_fuzzy
        if [[ "$?" = 0 ]]; then
          ConfidenceReasoning="$ConfidenceReasoning Successful;"
        else
          ((--SeriesConfidenceRating))
          ConfidenceReasoning="$ConfidenceReasoning Failed; Information not obtainable;"
        fi
      fi
    fi
  else
    SeriesConfidenceRating=-3
    ConfidenceReasoning="$ConfidenceReasoning Download series identification: Failed;"
  fi

  #if we have a series line number then translate that into a series id
  if [[ -n "$serieslinenumber" ]] && ((serieslinenumber > 0)); then
    set_seriesid_newshowname_from_serieslinenumber
    inform "FOUND:$NewShowName ID#:$SeriesID WITH CONFIDENCE:$SeriesConfidenceRating"
  else
    warn "SERIESID COULD NOT BE DETERMINED"
    #If we're not in debug mode then cleanup show identification files.
    [[ -f "$TMP_SID_FILE" ]] && (( LOGLEVEL < 3 )) && rm -f "$TMP_SID_FILE"
    [[ -f "$TMP_SHN_FILE" ]] && (( LOGLEVEL < 3 )) && rm -f "$TMP_SHN_FILE"
  fi
fi

#If it's not a recognized episode, then we need to assign the name myth2kodi will use.
[[ -z "$ShowName" ]] && ShowName="$InputTitle"
[[ -z "$NewShowName" ]] && NewShowName="$ShowName"

if [[ -n "$SeriesID" ]]; then
  make_m2k_database_dir

  #If database is out of date, download new database
  #TODO: Without internet connection, this fails to run properly even when local
  #  information should be sufficient to properly name episode. Add a flag for
  #  Series that have finished, so we don't keep updating for TV Series that
  #  that finished years ago -- see the Status field for the series in the
  #  ShowName.xml in the $m2kdir dir. Also enable using existing data if update fails.
  check_m2k_database_up_to_date
  if [[ $? != 0 ]]; then
    download_series_info
    if [[ $? != 0 ]]; then
      warn "COULD NOT DOWNLOAD UP-TO-DATE INFORMATION FROM TheTVDB! requiring doover."
      RequiresDoover=1
    fi
  fi
#if series id is not obtained send failure message
elif [ -z "$SeriesID" ] && [ "$m2kProgramIDCheck" != "SH" ] && [ "$m2kProgramIDCheck" != "MV" ]; then
  ConfidenceReasoning="$ConfidenceReasoning Failed; "
  warn "SERIES ID WAS NOT FOUND. TheTVDB MAY BE DOWN. IF NOT TRY USING A showTranslations FILE."
  printf '%s\n' "$InputTitle" >> "$UnrecognizedSeriesFile"
  if [[ "$Database" = 'Enabled' ]]; then
    warncont "RECSTART:$ShowStartTime-"
    warncont "Movie Air Date:$MovieAirDate-"
    warncont "Original Air Date:$OriginalAirDate-"
    warncont "Channel ID:$ChanID-"
    warncont "Show Category:$ShowCategory-"
    [[ -z "${Exx:2:1}" ]] && Exx=''
  fi
fi

#TODO: If we haven't identified the Series, try NLP match $Plot against possible plots to guess a Series.

#####PROCESS EPISODE INFORMATION#####
#If we have a SeriesID but don't already have Season and Episode information
if [[ -n "$SeriesID" ]]; then
  inform "Processing SeriesID:$SeriesID"
  #####GET ABSOLUTE EPISODE NUMBER#####
  if [ "$GuideDataType" = "SchedulesDirect" ] ; then
    ConfidenceReasoning="$ConfidenceReasoning Attempted match on OriginalAirDate:"
    set_absolute_episode_number_by_airdate
    AirdateExitStatus=$?
    [[ "$AirdateExitStatus" = "1" && -n "$EpisodeSubtitle" ]] && resolve_multiple_matches_airdate
    test "$?" = "0" && AirdateExitStatus=0
    if [ "$AirdateExitStatus" = "0" ]; then
      ((++EpisodeConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Successful; "
      GotEpisodeNumber=1
    else
      warn "AIRDATE FAILED. TITLE MATCH ON ABSOLUTE EPISODE NUMBER: $AbsoluteEpisodeNumber"
      ((--EpisodeConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Failed;"
    fi
  fi

  if ((GotEpisodeNumber != 1)) && [[ -n "$EpisodeSubtitle" ]]; then
    ConfidenceReasoning="$ConfidenceReasoning Attempted SubTitle match on Standard logic:"
    set_absolute_episode_number_by_ename
    if [ "$?" = "0" ]; then
      ConfidenceReasoning="$ConfidenceReasoning Successful; "
    else
      warn "AIRDATE/STANDARD LOGIC FAILED. FUZZY LOGIC ABSOLUTE: $AbsoluteEpisodeNumber. Requiring doover."
      RequiresDoover=1
      ((--EpisodeConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Failed; Attempted SubTitle match on Fuzzy logic:"
      set_absolute_episode_number_by_ename_fuzzy
      if [ "$?" = "0" ]; then
        ConfidenceReasoning="$ConfidenceReasoning Successful; "
      else
        ((--EpisodeConfidenceRating))
        ConfidenceReasoning="$ConfidenceReasoning Failed;"
      fi
    fi
  fi

  #update confidence total
  let ConfidenceRating=EpisodeConfidenceRating+SeriesConfidenceRating

  #Verification only makes sense if we got AbsoluteEpisodeNumber from a method
  # other than Standard or Fuzzy logic above.
  if ((GotEpisodeNumber == 1)) && [[ -n "$AbsoluteEpisodeNumber" ]]; then
    #####VERIFICATION OF CONFIDENCE RATING#####
    #backup AbsoluteEpisodeNumber for tests
    AbsoluteEpisodeNumberBackup="$AbsoluteEpisodeNumber"
    if [[ -n "$InputSubtitle" && -n "$OriginalAirDate" ]]; then
      #Verify with Standard logic
      set_absolute_episode_number_by_ename
      if [ "$AbsoluteEpisodeNumber" != "$AbsoluteEpisodeNumberBackup" ]; then
        msg_standard_logic_warning
        [[ -z "$AbsoluteEpisodeNumber" ]] && AbsoluteEpisodeNumber="Nothing"
        ConfidenceReasoning="$ConfidenceReasoning Standard Logic came up with Episode Number $AbsoluteEpisodeNumber. This does not match $AbsoluteEpisodeNumberBackup;"
      else
        #TODO For shows which are way off, we need some sort of doover mechanism.
        #CONFIDENCE:2 LOGIC PATH:  Attempted Match On Zap2itID: Successful; Attempted match on OriginalAirDate: Successful;
        #Standard Logic came up with line 76. This does not match 85; Fuzzy Logic test came up with line 76. This does not match 85;
        #JOB: myth2kodi '/home/mythtv/Videos/1035_20101109001500.mpg' 'Aqua Teen Hunger Force' 'Couple Skate'
        #TARGET SET:/home/mythtv/Videos/Episodes/Aqua Teen Hunger Force/Season 6/Aqua Teen Hunger Force S06E03 (She Creature).mpg
        increment_fuzzy_logic_error_count
        ConfidenceReasoning="$ConfidenceReasoning Verified with Standard logic;"
        (( ++ConfidenceRating ))
      fi

      #Verify with Fuzzy
      set_absolute_episode_number_by_ename_fuzzy
      if [ "$AbsoluteEpisodeNumber" != "$AbsoluteEpisodeNumberBackup" ]; then
        [[ -z "$AbsoluteEpisodeNumber" ]] && AbsoluteEpisodeNumber="Nothing"
        ConfidenceReasoning="$ConfidenceReasoning Fuzzy Logic test came up with Episode Number $AbsoluteEpisodeNumber. This does not match $AbsoluteEpisodeNumberBackup;"
        msg_fuzzy_logic_warning
      else
        increment_fuzzy_logic_error_count
        ConfidenceReasoning="$ConfidenceReasoning Verified with Fuzzy logic;"
        (( ++ConfidenceRating ))
      fi
    fi
    #Restore AbsoluteEpisodeNumber after testing
    AbsoluteEpisodeNumber="$AbsoluteEpisodeNumberBackup"
  fi

  #Statistical Fuzzy Logic monitoring
  increment_total_matches
  debug "TOTAL FUZZY LOGIC MATCHES:$FuzzyLogicMatches"
  #TODO: Consider repositioning this debug, also look into increment_fuzzy_logic_error_count usage... Maybe use $FuzzyLogicError here: ${FuzzyLogicError:-0}
  debug "TOTAL VERIFIED FUZZY ERRORS:$(test -f "$m2kdir/FuzzyLogicError.log" && cat "$m2kdir/FuzzyLogicError.log" || echo "0")"
fi

#TODO: The following few blocks will run even if we haven't properly identified the series, which doesn't make
#      sense for the things trying to set SxxExx...

#If we already have Sxx and Exx from MythTV-DB, use them. If we also had a Subtitle, then do some verification.
# Reversed sense of match: [[ -z "$Sxx" || "$Sxx" =~ ^(S00|S)$ || -z "$Exx" || "$Exx" =~ ^(E00|E)$ ]]
if [[ "$Sxx" != "S" && -n "$Sxx" && "$Sxx" != "S00" && "$Exx" != "E" && -n "$Exx" && "$Exx" != "E00" ]] ; then
  #TODO: If the confidence rating from the above is good, and we have an
  #  AbsoluteEpisodeNumber then use it to validate the Sxx, Exx & Subtitle from
  #  the MythTV-DB.
  inform "Using episode number: $Sxx$Exx, extracted from the MythTV-DB."
  #TODO: Probably should only do the following if the Series confidence rating
  #  is ok.
  #If we don't have a Subtitle, then use Sxx & Exx to get it from the TVDb info.
  if [[ -z "$EpisodeSubtitle" ]]; then
    AbsoluteEpisodeNumberBackup=$AbsoluteEpisodeNumber
    set_absolute_episode_number_by_sxxexx
    if [ "$?" = "0" ]; then
      EpisodeSubtitle=$(sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir/$NewShowName/$NewShowName.actualEname.txt")
      inform "MythTV-DB didn't have an EpisodeSubtitle, using '$EpisodeSubtitle' from TheTVDB."
    else
      AbsoluteEpisodeNumber=$AbsoluteEpisodeNumberBackup
    fi
  fi
  #Strip the leading "S" from Sxx,
  SeasonNumber="${Sxx#S}"
  #and any leading "0"
  SeasonNumber="${SeasonNumber#0}"

#If we don't already have EXX and SXX, set them by matching Absolute Episode Number across myth2kodi's database
elif [[ -n "$AbsoluteEpisodeNumber" ]]; then
  #NOTE: this function also sets EpisodeSubtitle and SeasonNumber
  set_sxxexx_absolute_episode_number
else
  warn "Couldn't set Sxx and Exx from MythTV-DB or set them based on InputSubtitle."
  ConfidenceReasoning="$ConfidenceReasoning Could not get Sxx and Exx from MythTV-DB or set them based on InputSubtitle; "
fi

#If it's not tagged as a Movie but lacking SxxExx and then as a fallback check storagegroup in case it's a Movie we missed
if [[ "$StorageGroupFallback" = 'Enabled' ]]; then
  debug "StorageGroupFallback is Enabled"
  #TODO: Make a HasSxxExx variable that is set and used consistently, #NOTE: there is already one but it's weirdly used
  #      if [[ -z "$Sxx" || "$Sxx" =~ ^(S00|S)$ || -z "$Exx" || "$Exx" =~ ^(E00|E)$ ]]; then HasSxxExx=0; else HasSxxExx=1; fi
  if [ "$m2kProgramIDCheck" != "MV" ] && [[ "$Sxx" = "S" || -z "$Sxx" || "$Sxx" = "S00" || "$Exx" = "E" || -z "$Exx" || "$Exx" = "E00" ]] ; then
    if grep -iq '\(Movies*\|Films*\)' <<< "$StorageGroup" ; then
      inform "GUESSING that this is a Movie based on being in storagegroup: $StorageGroup"
      m2kProgramIDCheck="MV"
      ProgramIDType="Movie"
      ((--ConfidenceRating)) #Decrement confidence, because this is a guess.
      ConfidenceReasoning="$ConfidenceReasoning Possible misidentified Movie, overriding Guide Data, Guess; "
    fi
  fi
fi

#TODO: Need to add checks for existence of myth2kodi database files for $NewShowName and/or check that we've identified the series before bothering with the following

#TODO: Assuming we have identified the Series, but have no Subtitle, try NLP match $Plot against possible plots to guess a subtitle

#TODO: If this works reliably, then consider moving it up to directly below fuzzy match on subtitle
#As a last resort, if we still think it's an episode but have no episode info, try fuzzy match on plot
if [[ "$PlotMatchFallback" = 'Enabled' ]]; then
  debug "PlotMatchFallback is Enabled" #[[ -z "$Sxx" || "$Sxx" =~ ^(S00|S)$ || -z "$Exx" || "$Exx" =~ ^(E00|E)$ ]]
  if [ "$m2kProgramIDCheck" = "EP" ] && [[ "$Sxx" = "S" || -z "$Sxx" || "$Sxx" = "S00" || "$Exx" = "E" || -z "$Exx" || "$Exx" = "E00" ]] ; then
    getAbsoluteEpisodeNumberWithFuzzyPlotMatch
    if [[ "$?" = "0" && -n "$AbsoluteEpisodeNumber" ]]; then
      inform "Setting Sxx, Exx, and EpisodeSubtitle based on FuzzyPlotMatch:"
      #NOTE: set_sxxexx_absolute_episode_number also sets EpisodeSubtitle and SeasonNumber
      set_sxxexx_absolute_episode_number
      ((--ConfidenceRating)) #Decrement confidence, because this is a guess.
      ConfidenceReasoning="$ConfidenceReasoning Found AbsoluteEpisodeNumber with fuzzy plot match, Guess; "
    else
      err "Failed in last ditch attempt to identify episode with fuzzy plot match, we have no SxxExx."
      #TODO: Probably should exit here...
    fi
  fi
fi


#######SANITY CHECKS#####

if [ "$m2kProgramIDCheck" = "EP" ] && [[ "$Exx" = "E" || -z "$Exx" ]]; then
  ConfidenceReasoning="$ConfidenceReasoning Guide Data did not match a specific Episode;"
  warn "Identified recording as episode but failed to determine episode number, requiring doover."
  RequiresDoover=1
  #TODO come up with a way to have a variable like DataWasNotObtainable to check and make it a SH later

#If it's a movie or a showing, give it a name.
#TODO: If it's a movie, try using imdb or similar with available $Plot to determine if the Title is correct...
elif [ "$m2kProgramIDCheck" = "MV" ] || [ "$m2kProgramIDCheck" = "SH" ] ; then
  NewShowName="$InputTitle"
  ConfidenceReasoning="$ConfidenceReasoning Guide Data reported this is a $ProgramIDType;"
fi

#if the confidence was low, then show requires a doover
((ConfidenceRating <= -4)) && RequiresDoover=1 && warn "ConfidenceRating low. Requiring doover."

#If file is a link then activate link mode so the original link is not screwed up.
if [[ -L "$InputPath" ]]; then
  warn "FILE IS A LINK FORCING PROCESS_RECORDING_MODE='LINK'."
  PROCESS_RECORDING_MODE='LINK'
  SYMLINK='Enabled'
fi

#If user wants database data deleted, then we will do that if the match was a good confidence level
if [[ "$PROCESS_RECORDING_MODE" = 'MOVE' && "$SYMLINK" = 'Disabled' ]]; then
  ((ConfidenceRating > -4)) && RequiresDoover=0
fi

#####INVALID FILE HANDLING#### #TODO: This should come straight after arg parse and the Initial log entry for the processing of recording
#If file to be moved does not exist, then report
if [ ! -f "$InputPath" ] && [ "$InputPath" != "testfile.ext" ]; then
  msg_invalid_path_error "$InputPath"
  NOTIFY_MSG="InputPath not a file: '$InputPath'"
  exit_job 'FileOrPathDoesNotExist'
fi

#Check write permissions and free space for Move and Working directories.
check_filesystem

msg_operation_summary

######PRE-NAMING CHECKS#####
#if no episode data and it's not a movie or a test
if [[ -z "$Exx" && "$InputPath" != "testfile.ext" ]]; then
  if [[ -z "$ChanID" && -n "$InputPath" ]]; then #TODO: check this...
    NOTIFY_MSG="Episode could not be matched based on supplied Title and SubTitle."
    warn "$NOTIFY_MSG"
    exit_job 'NameCouldNotBeAssigned'
  elif [ "$m2kProgramIDCheck" = "MV" ]; then
    #Ensures the doover value was not set for the movie and use safe show name
    RequiresDoover=0
    NewShowName="$SafeShowName"
  #If user has determined that they do not want unrecognisable tv shows in their library
  elif [[ "$ShowStopper" = 'Enabled' ]]; then
    #msg_unable_to_identify_recording
    msg_tvdb_incomplete
    exit_job 'NameCouldNotBeAssigned'
  elif [ "$m2kProgramIDCheck" = "SH" ]; then
    #Ensures the doover value was not set for the show and use safe show name
    NewShowName="$SafeShowName"
    msg_show_warning
  else
    #change the show to a Generic type
    NewShowName="$SafeShowName"
    msg_epishow
  fi
fi

#Figure out if the file can go in the MoveDir, or if the alternate should be used
set_move_location

#####OUTPUT FILE NAME FORMATTING#####
#Format Shows
#Only keep Alpha-numeric characters, space, parenthesis and the four chars & , . -
EpisodeSubtitle="$(sed -r 's/[^[:alnum:] &,.)(-]//g' <<< "$EpisodeSubtitle")"
NewShowName="$(sed -r 's/[^[:alnum:] &,.)(-]//g' <<< "$NewShowName")"
ShowName="$(sed -r 's/[^[:alnum:] &,.)(-]//g' <<< "$ShowName")"

#Format Episodes showname=show name Sxx=season number Exx=episode number EpisodeSubtitle=episode name
if [[ -z "$NamingConvention" ]]; then
  set_show_file_name
else
  [[ -z "$NewShowName" ]] && NewShowName="$ShowName"
  set_show_file_name_categoric
fi

#### MAKE THE DIRECTORY WE'LL MOVE THE RECORDING TO ####
make_show_dir

#####FAILSAFE HANDLING#####
#TODO: Review the "FailSafe" handling throughout the script.
#If failsafe state is set then create link in FailSafeMode
if [ "$FailSafeState" = "1" ]; then
  #failsafe activates MoveDir = failsafe dir and link mode is used
  failsafe
  #TODO: undo and doover entries not being generated here... However, can't just call them
  #      as failsafe() doesn't set MoveDir=$FailSafeDir. Need to clean this up when refactoring
  #      main... see, make_show_dir and TODO in set_move_location
  exit_job "$EXIT_JOB_TYPE"
fi

#####ANTI-CLOBBER#####
#TODO: IF WE'RE MAKING THE MISTAKE OF MOVING A RECORDING THAT WE'VE ALREADY MOVED, OR
#    IF WE'VE IDENTIFIED A DIFFERENT SHOW AS THE SAME SHOW THEN SENSIBLE BEHAVIOUR
#    IS TO REPORT A DETAILED ERROR MESSAGE AND DO NOTHING!!!
if [[ -f "$MoveDir/$ShowFileName.$OriginalExt" ]]; then
  err "FILE NAME ALREADY EXISTS:"
  errcont "FILE NAME:$MoveDir/$ShowFileName.$OriginalExt"
  errcont "CALLED AS: myth2kodi '$1' '$2' '$3' '$4'"
  errcont "InputTitle: $InputTitle"
  errcont "InputSubtitle: $InputSubtitle"
  errcont "Plot: $Plot"
  errcont "WE'VE EITHER ALREADY PROCESSED THIS RECORDING OR OUR FILE NAME GENERATION IS TOO GENERIC."
  errcont "EITHER WAY, ABORTING."
  #Write an entry in the duplicates file, for easy check/removal of duplicates.
  printf '"%s" "%s" "%s" "%s"\n' "$InputTitle" "$ShowStartTime" "$InputPath" "$ShowFileName" >> "$DuplicatesFile"
  NOTIFY_MSG="Recording identified as duplicate of: $MoveDir/$ShowFileName.$OriginalExt"
  exit_job 'FileAlreadyExists'
  #TODO: When refactoring main, consider allowing forced move with auto name incrementing when move-to file already exists.
  #If file exists then make a new name for it
  # myth2kodiCounter=0
  # NameCheck=0
  # while [ $NameCheck = '0' ]; do
  #   #TODO: Sublime text syntax highlighting fails here, the different coloured 2 in
  #   #  the variable name below isn't actually a problem, fix the syntax highlighting.
  #   ((++myth2kodiCounter))

  #   #If file does not exist, then it is a valid target
  #   if [ ! -e "$MoveDir/$ShowFileName-$myth2kodiCounter.$OriginalExt" ]; then
  #     NameCheck="1"
  #     ShowFileName=$(echo "$ShowFileName"-"$myth2kodiCounter")
  #     warn "FILE NAME EXISTS. FILE WILL BE KNOWN AS: $ShowFileName"
  #   fi
  # done
fi

#If this is a test file, then exit now.
[[ "$InputPath" = "testfile.ext" ]] && testfile_exit

#If the user is not mythtv and the settings are set for mythtv only, then exit, display a clear status message.
check_path_permission "$InputPath"

#If the show is generic programming, this is the best myth2kodi can do.
[[ "$m2kProgramIDCheck" = "SH" ]] && msg_show_warning

#####MOVE MODE HANDLING#####
#If processing recording in 'MOVE' mode, move and rename the file.
if [[ "$PROCESS_RECORDING_MODE" = 'MOVE' ]]; then
  #Send notifications, Move the file and rename
  debug "MOVING FILE: '$InputPath' to '$MoveDir/$ShowFileName.$OriginalExt'"
  mv "$InputPath" "$MoveDir/$ShowFileName.$OriginalExt"

  #Check and report if file was moved
  if [[ -e "$MoveDir/$ShowFileName.$OriginalExt" ]]; then
    if [[ -f "$MoveDir/$ShowFileName.$OriginalExt" ]]; then
      #Make symlink back to original file
      if [[ "$SYMLINK" = 'Enabled' ]]; then
        inform "Creating symlink in move mode."
        ln -s "$MoveDir/$ShowFileName.$OriginalExt" "$InputPath"
        [[ -L "$InputPath" ]] || err "Failed to Create symlink: FILESYSTEM MAY NOT SUPPORT SYMLINKS"
      #If SYMLINK=Disabled, remove database entries
      elif [[ "$SYMLINK" = 'Disabled' ]]; then
        chmod 775 "$MoveDir/$ShowFileName.$OriginalExt"
        if [[ "$RequiresDoover" != '1' ]]; then
          debug "SYMLINK='Disabled' and doesn't require doover, so MythTV-DB info will be removed."
          delete_mythtv_database_entry
        else
          warn "Job requires doover, so attempting to create symlink in SYMLINK='Disabled' mode."
          ln -s "$MoveDir/$ShowFileName.$OriginalExt" "$InputPath"
          if [[ ! -L "$InputPath" ]]; then
            err "Failed to Create symlink: FILESYSTEM MAY NOT SUPPORT SYMLINKS"
          elif [[ -L "$InputPath" ]]; then
            debug "Symlink Successfully created."
            warn "Setting SYMLINK='Enabled' for subsequent processing."
            SYMLINK='Enabled'
          fi
        fi
      else
        err "SYMLINK must be set as 'Enabled' or 'Disabled', but SYMLINK='$SYMLINK'"
      fi

      success_postprocessing

      #We've successfully moved the recording -- notify then exit.
      msg_completed_move
      exit_job 'MoveModeSuccessful'

    #if file was not moved (has zero size), then fail
    elif [ ! -s "$MoveDir/$ShowFileName.$OriginalExt" ]; then
      rm -f "$MoveDir/$ShowFileName.$OriginalExt"
      msg_wrote_zero_length_file
      exit_job 'ZeroLengthFile'
    fi
  elif [ ! -f "$MoveDir/$ShowFileName.$OriginalExt" ]; then
    msg_permission_error_while_moving
    exit_job 'MoveFailed'
  fi

#####LINK MODE HANDLING#####
#If symlink is in LINK mode then create symlink
elif [[ "$PROCESS_RECORDING_MODE" = 'LINK' ]]; then
  inform "CREATING LINK IN LINK MODE WITH CONFIDENCE:$ConfidenceRating"

  ln -s "$InputPath" "$MoveDir/$ShowFileName.$OriginalExt"

  #if file was created
  if [ -L "$MoveDir/$ShowFileName.$OriginalExt" ]; then
    inform "Symlink created: $MoveDir/$ShowFileName.$OriginalExt"
    if [[ "$TRACKING" = 'Enabled' ]]; then
      printf '%s\n' "'$MoveDir/$ShowFileName.$OriginalExt' '$InputPath'" >> "$m2kdir/created.tracking"
    fi

    success_postprocessing

    #We've successfully linked the recording -- notify then exit.
    NOTIFY_MSG="$ShowFileName linked to $MoveDir"
    exit_job 'LinkModeSuccessful'

  #If link failure, send notification and fail
  elif [ ! -L "$MoveDir/$ShowFileName.$OriginalExt" ]; then
    msg_symlink_not_created
    exit_job 'LinkingFailed'
  fi
fi

#if no match is found then send error messages
[[ -z "$Exx" ]] && msg_generic_unspecified_error

#send notification if enabled
NOTIFY_MSG="myth2kodi operation failed See $LOGFILE for more information"
exit_job 'GenericUnspecifiedError'

err "The exit_job function must be broken for you to see this message..."
exit 4
