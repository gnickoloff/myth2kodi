#! /bin/bash


# ***** WELCOME! Scroll further down to set the user settings. *****

#mythicalLibrarian by Adam Outler
#TODO: Contact original author before moving to a public GitHub repo...
#email: adamoutler gmail.com
#Software the way it should be: Free and Open Source
#Please contact me with any bug reports
#Tech Support: http://forum.kodi.tv/showthread.php?pid=470402

#SAK: Modified for me...
#Good site for learning Bash: http://wiki.bash-hackers.org/

#TODO: Make use of TMDb (https://www.themoviedb.org/) when the recorded
#  program is identified as being a Movie... Or http://omdbapi.com/, eg
#  http://www.omdbapi.com/?t=Casino&y=&plot=short&r=xml


#TODO: A number of the long "test" lines would be much easier to read/debug
#  if they were rewritten as "if ; then else" blocks.

#TODO: Clean up the name space by using "local" for variable declerations
#  within functions.

#TODO: Go through and check for variables that aren't initialised before
#  first use -- prefer initialising everything as it avoids cruft from
#  the environment, though should check interaction with global settings.

#TODO: Consider changing backticks `` used for command substitution to
#  this form $() -- see, http://wiki.bash-hackers.org/syntax/expansion/cmdsubst

#TODO: Consider replacing all echo statements with corresponding printf, as
#  it's apparently preferred for compatibility/portability reasons. See,
#    http://wiki.bash-hackers.org/commands/builtin/printf

#Intention:
#  This program is designed to be a user job in MythTV. It can be called by
#  creating a user job. It must have access to your MythTV recordings
#  This file should be placed in /usr/local/bin
#  The MythTV user job can then be called as follows:
#    /usr/local/bin/myth2kodi "%DIR%/%FILE%"
#
#Usage:
#  myth2kodi "Target File" "show name" "episode name"
#  eg. myth2kodi "/home/myth/recordings/2308320472023429837.mpg" "South Park" "Here Comes the Neighborhood"
#
#Output-target:
#  If an error occurs and the file cannot be moved, then no change will occur to
#  the original file. If the Movedir is full or not available, such as when
#  running a NAS and the computer is disconnected from the network, the
#  AlternateMoveDir will be used. If both of these dirs fail, the show will be
#  SymLinked in the FailSafeDir. You may elect to run the user job at a later
#  time when the issue has been resolved. Output dir and link type will depend
#  on user settings. The file name however, is preset to the most acceptable
#  standard:
#    Show Title - SxxExx (Episode Title).ext
#
#Symlinking:
#  When Symlinking is enabled, myth2kodi will follow its normal mode of
#  operation. In MOVE mode, myth2kodi will create a symlink from the new
#  file in the same name and location of the old file. In LINK mode,
#  myth2kodi will not move the file, LINK mode creates a new symlink to
#  the original file.
#
#Output-Files:
#  myth2kodi will create several files in it's working folder. This is a
#  list of the files and their functions:
#    +created.tracking keeps track of created comskip.txt and NFO files so they
#      can be deleted in the future if their video file is deleted.
#    +doover.sh is designed to keep track of failed jobs. It is designed to be
#      executable. #Commented commands are those which are determined to be
#      questionable. This file can be made executable and ran after a problem is
#      corrected which caused the problem. Questionable commands are those which
#      will require you to add a episode title and set the myth2kodi
#      Database=Disabled setting. Questionable files do not have sufficient
#      guide data.
#    +markupstart.txt and markupstop.txt are files which contain information
#      from the last comskip generation. Deletion will cause no adverse effects.
#    +output.log keeps track of operations and can be used to determine problems.
#    +shn.txt, sid.txt, and working.xml are used each time to determine the name
#      and show id of the last show identified.
#    +DailyReport directory is used to log the files which were moved that day.
#      It can be used as a "program guide" of sorts to keep track of what has
#      been added to your library.
#
#Logging:
#  Log file will show information for troubleshooting. You can find the log file
#  in the working folder. Log file default location:
#    /home/<user>/.myth2kodi/output.log
#
#Database-external:
#  This program will make 3 calls to TheTvDb for every episode. The first one is
#  to obtain the series ID and verify the show name is correct. The second is to
#  check if the internally managed database is up-to-date. The third call will
#  only be made if the internal database is not up-to-date. The third call will
#  download a larger file which contains all information about the show which is
#  known on TheTvDb.
#
#Database-internal:
#  While myth2kodi maintains and requires it's own external file/folder
#  database in the working directory, there is also support for integration with
#  MythTV's internal database. MythTV Database is required for movies to be
#  recognized and handled by myth2kodi. Also, in the event that the
#  integrated fuzzy logic cannot make a determination of the correct show name,
#  myth2kodi will pull the original air date from the MythTV database
#  and attempt to make an exact match to theTvDb.com supplied data. In addition,
#  the type of program is extracted from the mythtv database and a determination
#  is made weather or not there is sufficient information available to identify
#  the show based upon guide data. In order to make myth2kodi work to
#  it's full potential, all settings must be filled out correctly under the
#  database section of the user settings. Currently, the only guide data
#  supported is schedulesdirect through mythtv. When updating myth2kodi
#  it is best to delete all database folders to ensure proper data formatting.
#
#Dependencies:
#  depends on "curl", "agrep", "libnotify-bin" and Mythtv Backend for database
#  access. install curl with:
#    "apt-get install curl"
#  curl downloads webpages and sends commands to KODI. Install agrep with:
#    "apt-get install agrep"
#  agrep provides fuzzy logic. Optionally, install libnotify-bin with:
#    "apt-get install libnotify-bin" -allows GNOME desktop notifications
#
#Gnome Notifications:
#  In order for myth2kodi to send notifications to the GNOME desktop, it
#  must have no-password sudo access. It uses this access strictly to send
#  complete, moving and failure status notifications. Because this program is
#  launched by the user mythtv under normal circumstances, mythtv must
#  temporarily become your user name in order to send a notification to your
#  desktop. This requires the use of a separate script, and for mythtv to have a
#  sudoers group with no password option. Notifications are an optional feature
#  and will only work on the MythTV backend computer. The librarian-notify-send
#  script should be located in /usr/local/bin. You can get this script here:
#    https://sourceforge.net/projects/mythicallibrari/files/mythicalLibrarianBeta/librarian-notify-send/download
#
#KODI Notifications:
#   If options are enabled, myth2kodi will send a http requests to a
#   specified KODI Server to display library updates, to update the library and
#   to clean out the library.  In order for this to work KODI you must ensure
#   that the setting in KODI under System->Network->Services->Allow control of
#   KODI via HTTP and Allow programs on other systems to control KODI are
#   enabled.
#
#Show Name Translation:
#  The user may elect to create a file in the myth2kodi working folder
#  which will then translate any recorded show name into the desired show name.
#  This is useful for adding a year to distinguish between a new series and an
#  older series and/or typos in your guide data. By default it should be called
#  "showTranslations" and it will be in your $m2kdir folder.
#  showTranslations is not needed by most users and the file should only
#  be created if it is needed. Under most circumstances, the integrated fuzzy
#  logic will be sufficient to translate the guide name to the TvDb name,
#  however, showTranslations is available to improve accuracy to 100%. The
#  format of showTranslations is as follows (NB: no "#" or space at the start of
#  a line, only one space either side of "=", and no trailing space or any other
#  characters):
#    Filename: $m2kdir/showTranslations
#      My Guide Show Title = www.TheTvDb.com Show Title
#      Battlestar Gallactica = Battlestar Gallactica (2003)
#      The Office = The Office (US)
#      Millionaire = Who Wants To Be A Millionaire
#      Aqua teen Hungerforce = Aqua Teen Hunger Force
################################################################################


########################### BEGIN USER SETTINGS ################################
###Stand-alone mode values###
#SYMLINK has 3 modes.  MOVE|LINK|Disabled: Default=MOVE
#Create symlink at InputPath after 'MOVE' | Do not move, just create a sym'LINK' | move the file, symlinking is 'Disabled'
SYMLINK="MOVE"
#MoveDir is the folder which myth2kodi will move the file. No trailing / is accepted eg. "~/videos"
MoveDir="/media/video/tv"  #<------THIS VALUE MUST BE SET-------
#AlternateMoveDir will act as a secondary MoveDir if the primary MoveDir fails.  No trailing / is accepted eg. "~/videos"
AlternateMoveDir="/home/librarian/recordedTV"
#If TargetPathIsInputPath is Enabled, original dir will override MoveDir. Useful
#for multiple recording dirs. TargetPathIsInputPath will separate generic shows
#from episodes and movies. Enabled|Disabled
TargetPathIsInputPath="Disabled"
#Internet access Timeout in seconds: Default Timeout=50 (seconds)
Timeout=50
#Update database time in secconds, Longer duration means faster processing time and less strain on TheTvDb. Default='84000' (1 day)
UpdateDatabase=74200
#TODO: Consider adding variable binpath=/usr/local/bin/ as a step toward non-root install.
#myth2kodi working file dir: Default=$HOME/.myth2kodi (home/username/.myth2kodi)
m2kdir="$HOME/.myth2kodi"
#For testing /data/sknock/TEMP/.mythicalLibrarian
#FailSafe mode will enable symlinks to be formed in FailSafeDir if the move or symlink operation fails. Enabled|Disabled
FailSafeMode="Enabled"
#FailSafeDir is used when the file cannot be moved to the MoveDir. FailSafe will not create folders. eg. /home/username
FailSafeDir="/home/librarian/FailSafe"  #<------THIS VALUE MUST BE SET-------
#DirTracking will check for and remove the folders created by myth2kodi
DirTracking="Enabled"
#the following line contains the API key from www.TheTvDb.Com. Default project code: 6DF511BB2A64E0E9
APIkey="6DF511BB2A64E0E9"
#TODO: If I ever put this on GitHub I should register a fresh APIkey - http://thetvdb.com/?tab=apiregister
#SAK: This one was set at some point for some reason: APIkey=0F3A338F0FCB29A2
#  but it seems to be rejected for certain uses...
#Language setting
Language="en"

###Database settings###
#MythTV MYSQL access allows addition of movies, comskip data, and improves accuracy of episode recognition.
#Database access Enabled|Disabled
Database="Enabled"
#Database Type MythTV|MythTVPythonBindings  Default=MythTVPythonBinding
DatabaseType="MythTVPythonBindings"
#Guide data type: SchedulesDirect currently covers DataDirect, MC2XML and others.  NoLookup will bypass tvdb scanning
#Options: SchedulesDirect|NoLookup
GuideDataType="SydFTA"
#The IP address or name of the server for MythTV Database (used in python bindings only)
DBHostName="192.168.1.42"
#MySQL User name: Default="mythtv"
MySQLuser="mythtv"
#MySQL Password: Default="mythtv"
MySQLpass="mythtv" #<------THIS VALUE MUST BE SET-------
#MythTV Backend server: Default=localhost
#SAK: NOT USED ###MythTVBackendServer=localhost
#The Database Pin for the MythTV Database (used in python bindings only)
DBPin=8446
#MySQL Myth Database: Default="mythconverg"
#If utilizing mythconverg with Python Bindings, then it would be MySQLMythDb=PythonBindingsmythconverg
MySQLMythDb="mythconverg"
#Primary Movie Dir. myth2kodi will attempt to move to this dir first. No trailing / is accepted eg. "~/videos"
PrimaryMovieDir="/media/video/movies" #<------THIS VALUE MUST BE SET-------
#AlternateMovieDir will act as a Secondary move dir if the primary movie dir fails
AlternateMovieDir="/home/librarian/recordedMovies"
#ShowStopper = Enabled prevents generic shows and unrecognized episodes from being processed
ShowStopper="Enabled"
#Primary Show Dir. myth2kodi will attempt to move to this dir first. No trailing / is accepted eg. "~/videos"
PrimaryShowDir="/media/video/recordedShows" #<------THIS VALUE MUST BE SET-------
#AlternateMoveDir will act as a Seccondary move dir if the primary move dir fails
AlternateShowDir="/home/librarian/recordedShows"
#CommercialMarkup will generate comskip files for recordings when they are moved. Enabled|Disabled
CommercialMarkup="Enabled"
#CommercialMarkupCleanup will execute a maintenance routine which will remove comskip files if they are not needed
CommercialMarkupCleanup="Enabled"

###Reporting/Communications###
#Enables debug mode. This is a verbose mode of logging which should be used for troubleshooting.  Enabled|Disabled
DEBUGMODE="Enabled"
#DailyReport provides a local log of shows added to your library per day. Enabled|Disabled
DailyReport="Enabled"
#Notify tells myth2kodi to send a notification to GNOME Desktop upon completion. Enabled|Disabled
Notify="Enabled"
#If notifications are enabled, NotifyUserName should be the same as the user logged into the GNOME Session. (your username)
NotifyUserName="librarian" #<------THIS VALUE MUST BE SET-------
#Send a notification to KODI to Update library upon Successful move job Enabled|Disabled
KODIUpdate="Enabled"
#Send a notification to KODI to cleanup the library upon Successful move job Enabled|Disabled
#TODO:#NOTE:Don't fully trust the automated call of clean, and currently it doesn't even
#  seem to be invoked at the times that would make sense, so for now I'm disabling it. See
#  the TODO in KODIAutomate().
KODIClean="Disabled"
#Send Notifications to KODI UI when library is updated Enabled|Disabled
KODINotify="Enabled"
#Ip Address and port for KODI Notifications Eg.KODIIPs=( "192.168.1.110:8080" "192.168.1.111:8080" "XBOX:8080" )
KODIIPs=( "192.168.1.42:8080" ) #<------THIS VALUE MUST BE SET-------
#maxItems controls the number of items in the RSS. RSS Can be activated by creating a folder in /var/www/mythical-rss.
maxItems=8
########################## END USER SETTINGS ###################################

mythicalVersion="myth2kodi Version 0.2.0; mythicalLibrarian 953ish+"

#
declare -r LogFile="$m2kdir/output.log"
#declare -r DiagnosticsFile="$m2kdir/diagnostics.log"

########################### BEGIN USER JOBS ####################################
#The RunJob function is a place where you can put your custom script to be run
#at the end of execution. Though it may be at the top, this is actually the end
#of the program.
RunJob(){
  case $jobtype in
  #Successful Completion of myth2kodi
    LinkModeSuccessful|MoveModeSuccessful)
      echo "SUCCESSFUL COMPLETION TYPE: $jobtype"
      #Insert Custom User Job here

      #
      exit 0
      ;;

  #Information was not obtainable
    TvDbIsIncomplete|GenericShow)
      echo "INSUFFICIENT INFORMATION WAS SUPPLIED:$jobtype"
      #Insert Custom User Job here

      #
      exit 0
      ;;

  #File system error occurred
    PermissionError0Length|InvalidFileNameSupplied|PermissionErrorWhileMoving|FailSafeModeComplete|LinkModeFailed)
      echo "FILE SYSTEM ERROR:$jobtype"
      #Insert Custom User Job here

      #
      exit 1
      ;;
  #Generic error occurred
    GenericUnspecifiedError)
      echo "UNKNOWN ERROR OCCOURED:$jobtype"
      #Insert Custom User Job here

      #
      exit 3
      ;;
  #User elected not to process jobs which can not be properly categorized
    NameCouldNotBeAssigned)
      echo "NAME COULD NOT BE ASSIGNED BASED UPON DATA SUPPLIED"
      #Insert Custom User Job here

      #
      exit 3
      ;;
  #User elected to use a title/category ignore file
    titleIgnore|categoricIgnore)
      echo "Show Was ignored based on $jobtype"
      #Insert Custom User Job Here

      #
      exit 0
      ;;
  esac
  #Custom exit point may be set anywhere in program by typing RunJob on any new line
  #Insert Custom User Job here

  #
  exit 4
}

#TODO: Drop update entirely, however, consider repurposing mythicalSetup as myth2kodi --setup
# myth2kodi --update (mythicalSetup) will merge user jobs into myth2kodi automagically.
# Put your desired commands into one of the following files.  You may need to create the folder
# /etc/myth2kodi/JobSuccessful
# /etc/myth2kodi/JobInformationNotComplete
# /etc/myth2kodi/JobGenericError
# /etc/myth2kodi/JobFilesystemError
# /etc/myth2kodi/JobInsufficientData
# /etc/myth2kodi/JobIgnoreList
# /etc/myth2kodi/JobUnspecified
# After running mythicalSetup, the user job will be incorporated into the
# myth2kodi script and  Executed when the job is run.

### EXAMPLE JOB (Leading "# " should be removed) ###
# /etc/myth2kodi/JobSuccessful:
# #Transcode your file using the myth2kodi variables
# ffmpeg -i S:"$MoveDir/$ShowFileName.$OriginalExt" -target ntsc-svcds:"$MoveDir/$ShowFileName.mp4"
# #remove the myth2kodi symlink
# rm "$InputPath"
# #make a new symlink
# ln -s  "$MoveDir/$ShowFileName.mp4" "$InputPath"
# #Set the new file extension
# OriginalExt=mp4
# #Create tracking entry for the file
# performLoggingForMoveMode
# ####Move the .txt(comskip) and .nfo(Information) files if needed.
# enable the KODI communications
# KODIUpdate=Enabled
# KODIClean=Enabled
# KODINotify=Enabled
# #Tell myth2kodi to do KODI communications
# KODIAutomate

#Suggested examples are:
# 1.string together multiple versions of myth2kodi configured for
#   different languages. Set a different Language for each, then on failure,
#   call the next job.
# 2.custom name replacement of certain programming
# 3.custom file moving of certain programming
# 4.set custom folders based upon recorded channel
# 5.set custom user jobs based upon who ran the file
# 6.make a "new movies" "old movies" folder.
#The limits are endless.

#The following is a list of variables which can be used as a part of user jobs
#at the end of myth2kodi:
#####ALL RECORDINGS####
#$MoveDir/$ShowFileName.$OriginalExt = location of moved file.
#$ShowName = Processed Title
#$InputTitle = actual database title
#$MoveDir = the folder to which the file was moved ie. "/home/mythtv/videos/Episode"
#$ShowFileName = the name of the show moved, not including extension eg. "simpsons S01E02 (foo)" or "MovieTitle(year)"
#$OriginalExt = original file extension  eg "mpg"
#$NewShowName = Successfully resolved show name
#$ChanID = ChannelID
#$ProgramID= The Program IDentification information found in the MythTV DB
#$ShowStartTime = begin recording time
#$ShowCategory = category like children or sports also specifies Movie in SydFTA data
#$m2kProgramIDCheck = "SH" for SHow or sports - "MV" for MoVie - "EP" for EPisode
#$Plot = Plot
#$Stars = Stars
#$FileBaseName = name of the file to be moved without ext
#$XMLTVGrabber = your guide data type
#$ProgramIDType= Generic episode with no data, Movie, or Series With Episode Data
#$Zap2itSeriesID= Zap2it ID with SH, MV or EP stripped
#$MyUserName = name of user running myth2kodi
#$SafeShowName = title of show after showTranslations formatted for filesystem use

####EPISODES AND GENERIC SHOWS####
#$OriginalAirDate = original air date  Generic programming will be the first episode ever, for episodes it will be the first aired date
#$EpisodeSubtitle = Subtitle or EPisode Name

#####EPISODES####
#$Exx = Episode Number or "Movie" in case of a movie
#$Sxx = Season number or blank in case of movie
#$SeriesID = TheTVDB series ID
#$TvDbTime = current tvdb time
#$LastUpdated = last updated time (for Episodes only others will be blank)
# = tvdb order numbering

####MOVIES####
#$MovieAirDate = the original year the movie aired

############################## END USER JOBS ###################################




################################################################################
#################### ADEPT PERSONNEL ONLY BEYOND THIS POINT ####################
################################################################################

######################### BEGIN FUNCTION DEFINITIONS ###########################
TraditionalNamingConventions(){
  #Format Episodes showname=show name Sxx=season number Exx=episode number EpisodeSubtitle=episode name
  if [ "$Exx" != "" ] && [ "$Exx" != "E" ]; then
    ShowFileName=`echo "$NewShowName $Sxx$Exx ($EpisodeSubtitle)"`

  #Format Movies
  elif [ "$m2kProgramIDCheck" = "MV" ]; then
    Exx="Movie"
    MoveDir="$PrimaryMovieDir"
    #TODO: If adding a year then we really want original release date so the Kodi metadata lookup works reliably.
    if [ "$MovieAirDate" != "" ]; then
      echo "WARNING: currently forcing bypass adding MovieAirDate to Movie file names." | tee -a  "$LogFile"
      ShowFileName="$NewShowName" # ShowFileName="$NewShowName ($MovieAirDate)"
    else
      ShowFileName="$NewShowName"
    fi
  #Format generic Shows
  else
    Exx="Generic"
    MoveDir="$PrimaryShowDir"
    ShowFileName=`echo "$ShowName S0E0 ($EpisodeSubtitle Recorded $datehour on $ChanID)"`
    RequiresNFO=1
    test "$m2kProgramIDCheck" = "EP" && RequiresDoover=1
  fi
}

CategoricNamingConventions(){
  #Method1 - use airdate for season
  if [ "${OriginalAirDate:0:4}" != "0000" ] && [ "${OriginalAirDate:0:4}" != "" ] && [ "$UseMethod2" != "1" ] ; then
    EventYear="${OriginalAirDate:0:4}"
    Sxx=$EventYear
    EventMonthDay=`echo "${OriginalAirDate:5:5}" | tr -d "-" | sed 's/0*//'`
    Exx=$EventMonthDay
    test "$NewShowName" = "" && NewShowName=$ShowName
  else #Flag failure of Method1
    testedmethod1=0
  fi
  #Slight further testing of Method1 results
  if [ "$EventMonthDay" != "" ] && [ "$EventYear" -gt "1900" ] && [ "$EventMonthDay" -gt "0" ]; then
    testedmethod1=1
  else
    testedmethod1=0
  fi

  #Method2 -
  if [ "$testedmethod1" != "1" ]; then
    test "${ShowStartTime:0:4}" != 0000 && test "${ShowStartTime:0:4}" != "" && EventYear="${ShowStartTime:0:4}" && EventMonthDay=`echo "${ShowStartTime:5:5}" | tr -d "-" | sed 's/0*//'`
    Exx=$EventMonthDay
    Sxx=$EventYear
    #Check validity of Method2
  fi

  #Test final result and assign ShowFileName
  test "$EventYear" -gt "1900" && test "$EventMonthDay" -gt "0" && ShowFileName="$NewShowName S$EventYear""E$EventMonthDay ($InputSubtitle Recorded $datehour)"

  RequiresNFO=1
  HasSxxExx=1
}

######DAILY REPORT#####
#This function reports all shows processed based on date
dailyreport(){
  if [ $DailyReport = Enabled ]; then
    test ! -d "$m2kdir/DailyReport" && mkdir "$m2kdir/DailyReport"
    local reportfilename=`date +%Y-%m-%d`
    local reporttime=`date +%T`
    echo "$reporttime - $ShowFileName">>"$m2kdir/DailyReport/$reportfilename"
  fi
  return 0
}

#####CHECK PERMISSIONS#####
#CheckPermissions by writing a small file then deleting it, checking along the way.
#CheckPermissions takes file size, free space on dir, and the dir, then it performs
#tests. The result will be $TMoveDirWritable as a 1 or a 0 for writable or not.
#$1=filesize $2=freespace $3=folder to check
checkPermissions(){
  #set Test variable to 0.  It will be a 1 if everything passes.
  TMoveDirWritable=0
  if [ "$2" != "" ]; then
    if [ "$1" != "" ]; then
      if [ -d "$3" ]; then
        if [ $1 -lt $2 ]; then
          echo "Testing write permission on $3">"$3/arbitraryfile.ext"
          if [ -f "$3/arbitraryfile.ext" ] ; then
            if [ -s "$3/arbitraryfile.ext" ]; then
              rm -f "$3/arbitraryfile.ext"
              test ! -f "$3/arbitraryfile.ext" && TMoveDirWritable=1 || TMoveDirWritable=0
            else
              TMoveDirWritable=0
              echo "CREATED $3/arbitraryfile.ext BUT COULD NOT WRITE DATA INTO THE FILE" | tee -a "$LogFile"
            fi
          else
            echo "$MyUserName TRIED TO WRITE TO $3 --FAILED" | tee -a "$LogFile"
            test ! -r "$3" && echo "QUICK FIX: sudo chmod a+r \"$3\"" | tee -a "$LogFile"
            test ! -w "$3" && echo "QUICK FIX: sudo chmod a+w \"$3\"" | tee -a "$LogFile"
            echo "QUICK FIX: sudo chown $MyUserName \"$3\"" | tee -a "$LogFile"
          fi
        elif [ -z "$2" -o $1 -ge $2 ]; then
          TMoveDirWritable=0
          echo "INSUFFICIENT FREE SPACE ON $3" | tee -a "$LogFile"
          echo "QUICK FIX: Remove unnecessary files" | tee -a "$LogFile"
        fi
      else
        echo "FOLDER DOES NOT EXIST: $3" | tee -a "$LogFile"
        echo "QUICK FIX: mkdir \"$3\"" | tee -a "$LogFile"
      fi
    else
      echo "COULD NOT READ FILESIZE ON $InputPath" | tee -a "$LogFile"
      echo "QUICK FIX: chmod -R 775 \"$InputPath\"" | tee -a "$LogFile"
    fi
  else
    echo "COULD NOT READ FREE SPACE on \"$3\"" | tee -a "$LogFile"
    echo "QUICK FIX: mkdir \"$3\" ; chmod -R 775 \"$3\"" | tee -a "$LogFile"
  fi

  return 0
}

#####COMSKIP FILES#####
#Function GenComSkip creates a comskip.txt file for use with the show upon moving, created from data from library
GenComSkip(){
  myth2kodiCounter=1
  #Set up comskip file
  test -f "$m2kdir/markupframes.txt" && rm -f "$m2kdir/markupframes.txt"
  echo "FILE PROCESSING COMPLETE">"$m2kdir"/markupframes.txt
  echo "------------------------">>"$m2kdir"/markupframes.txt
  while read line ; do
    myth2kodiCounter=`expr $myth2kodiCounter + 1`;
    StartData=`sed -n "$myth2kodiCounter"p "$m2kdir/markupstart.txt"`
    StopData=`sed -n "$myth2kodiCounter"p "$m2kdir/markupstop.txt"`
    if [ ! -z "$StopData" ]; then
      echo "$StartData $StopData">>"$m2kdir"/markupframes.txt
      CommercialMarkup="Created"
      echo "COMMERCIAL DATA START:$StartData STOP:$StopData"
    fi
  done <"$m2kdir/markupstop.txt"
  return 0
}

#####KODI COMMUNICATIONS#####
#This function Automates communication with KODI
KODIAutomate(){
  local data=""
  #Send notification to KODI, Update Library, Clean Library
  if [ "$KODINotify" = "Enabled" || "$KODIUpdate" = "Enabled" || "$KODIClean" = "Enabled" ]; then
    local curlPOST='curl -L -s -m3 --connect-timeout 5 -X POST -H "Content-Type: application/json" -d'
    for KODIIP in ${KODIIPs[@]} ; do
      echo "SENDING REQUESTED COMMANDS TO: $KODIIP"
      #TODO:Updating the Library prior to sending the Notification probably makes more sense.
      if [ "$KODINotify" = "Enabled" ] ; then
        data=\''{"jsonrpc":"2.0",
                 "method":"GUI.ShowNotification",
                 "params":{"title":"myth2kodi added","message":"'$tvdbshowname'"},
                 "id":1}'\'
        $curlPOST $data http://$KODIIP/jsonrpc > /dev/null 2>&1
        echo "SENT: GUI.ShowNotification for $tvdbshowname"
      fi
      if [ "$KODIUpdate" = "Enabled" ] ; then
        data=\''{"jsonrpc":"2.0", "method":"VideoLibrary.Scan", "id":1}'\'
        $curlPOST $data http://$KODIIP/jsonrpc > /dev/null 2>&1
        echo "SENT: VideoLibrary.Scan"
      fi
      #TODO: Requesting Kodi to Clean its Library doesn't seem to make sense in the same
      #  context as Update & Notify, that is, cleaning after adding a new show makes
      #  little sense and has the potential danger of completely clearing out Kodi's
      #  Library information if for example a network drive is temporarily unavailable
      #  due to a network problem. It does, however, seem to make sense to request
      #  Kodi to run Clean of its Library after myth2kodi runs undo, doover, or any
      #  other means of removing or renaming a file of which Kodi is aware... Perhaps
      #  split KODIAutomate() into KodiNewShow() and KodiCleanup()...
      if [ "$KODIClean" = "Enabled" ] ; then
        data=\''{"jsonrpc":"2.0", "method":"VideoLibrary.Clean", "id":1}'\'
        $curlPOST $data http://$KODIIP/jsonrpc > /dev/null 2>&1
        echo "SENT: VideoLibrary.Clean"
      fi
    done
  fi
  return 0
}

#####GENERATE RSS ENTRY#####
#This function generates an RSS feed for use on the web server. This can be used
#in /home/<kodi-user>/.kodi/userdata/RssFeeds.xml replace the feeds.feedburner.com link
#with:
#  <feed updateinterval="30">http://[youripaddress]/mythical-rss/rss.xml</feed>
#Big thanks to barney_1!
generaterss() {
  #user settings:
  rssDir="/var/www/mythical-rss"
  maxItems=8  #maximum number of items to read into the feed

  #script settings
  OLDrssFile="rss.xml"
  TEMPrssFile="rss.temp"

  #HTML line break code for nice formatting
  lineBreak="&lt;br /&gt;"

  #test if rssFile directory is writeable
  if [ ! -w "$rssDir" ]; then
    echo -e "RSS generation failed:\nDirectory not writeable ($rssDir)"
    return 5
  fi

  #test if rssFile is writeable
  if [ -e "$rssDir/$OLDrssFile" ] && [ ! -w "$rssDir/$OLDrssFile" ]; then
    echo -e "RSS generation failed:\nFile exists but is not writeable: $rssDir/$OLDrssFile"
    return 6
  fi

  #Setup the rss file
  echo -e '<?xml version="1.0" encoding="ISO-8859-1" ?>' > $rssDir/$TEMPrssFile
  echo -e '<rss version="2.0">' >> $rssDir/$TEMPrssFile
  echo -e '<channel>' >> $rssDir/$TEMPrssFile
  echo -e '\t<title>myth2kodi</title>' >> $rssDir/$TEMPrssFile
  echo -e '\t<link>http://kodi.tv</link>' >> $rssDir/$TEMPrssFile
  echo -e '\t<description>myth2kodi Daily Report Information</description>' >> $rssDir/$TEMPrssFile

  #write current recording information to first item.
  echo -e "\t\t<item>">>$rssDir/$TEMPrssFile
  echo -e "\t\t\t<title>$NewShowName</title>">>$rssDir/$TEMPrssFile

  if [ "$m2kProgramIDCheck" = "EP" ]; then
    echo -e "\t\t\t<link>http://www.thetvdb.com/?tab=series&amp;id=$SeriesID</link>">>$rssDir/$TEMPrssFile
  elif [ "$m2kProgramIDCheck" = "MV" ]; then
    echo -e "\t\t\t<link>http://www.imdb.com/search/title?release_date=,$MovieAirDate&amp;title=$ShowName&amp;title_type=feature</link>">>$rssDir/$TEMPrssFile
  else
    tvdotcomshowname=`echo $ShowName | sed s/" "/"%20"/g`
    echo -e "\t\t\t<link>http://www.tv.com/search.php?type=11&amp;stype=all&amp;tag=search%3Bfrontdoor&amp;qs=$tvdotcomshowname </link>">>$rssDir/$TEMPrssFile
  fi

  #TODO: Need to make the call to ifconfig more portable, maybe just revert to straight call and add /sbin to librarians path.
  #  The below assumed the first inet addr was the correct one, but that can lead to the loopback, using m2 and removing 127.0.0.1 avoids this problem,
  #  though it's probably better to just set myip in the configuration at top of file
  which /sbin/ifconfig >/dev/null && myip=`/sbin/ifconfig | grep 'inet addr' -m2 | cut -d: -f2 | awk '{ print $1}' | grep -v "127.0.0.1"`
  rssEpisodeSubtitle=`echo $EpisodeSubtitle | sed s/"&"/"&amp;"/g`
  rssNewShowName=`echo $NewShowName | sed s/"&"/"&amp;"/g`
  rssPlot=`echo $Plot | sed s/"&"/"&amp;"/g`
  mythicalGUID=`echo "$MyUserName@$myip""$MoveDir/$ShowFileName.$OriginalExt" | sed s/"("/"%28"/g | sed s/")"/"%29"/g | sed s/"\ "/"%20"/g`
  echo -e "\t\t\t<guid>sftp://$mythicalGUID</guid>">>$rssDir/$TEMPrssFile
  echo -e "\t\t\t<pubDate>"$(date -R -d "$ShowStartTime")"</pubDate>">>$rssDir/$TEMPrssFile
  echo -e "\t\t\t<description>">>$rssDir/$TEMPrssFile
  echo -e "\t\t\t\tEpisode Title: $rssEpisodeSubtitle$lineBreak">>$rssDir/$TEMPrssFile
  echo -e "\t\t\t\tProgram: $rssNewShowName$lineBreak">>$rssDir/$TEMPrssFile
  echo -e "\t\t\t\tSeason: $Sxx$lineBreak">>$rssDir/$TEMPrssFile
  echo -e "\t\t\t\tEpisode: $Exx$lineBreak$lineBreak">>$rssDir/$TEMPrssFile
  echo -e "\t\t\t\tPlot: $rssPlot">>$rssDir/$TEMPrssFile
  echo -e "\t\t\t</description>">>$rssDir/$TEMPrssFile
  echo -e "\t\t</item>">>$rssDir/$TEMPrssFile

  #If there is an old RSS file
  if [ -e "$rssDir/$OLDrssFile" ]; then
    #test for number of </item> tags using grep
    RssItemCount=$(grep -c "</item>" "$rssDir/$OLDrssFile")

    #if $maxItems is greater than this number
    if [ $maxItems -gt $RssItemCount ]; then
      #set a variable to track this number + 1 for the new entry
      itemLimit=$(($RssItemCount+1))
    else
      #set tracking variable to $maxItems
      itemLimit=$maxItems
    fi

    #get the line number for the first <item> tag
    firstLine=$(grep -n -m 1 "<item>" "$rssDir/$OLDrssFile" | cut -d ":" -f 1)
    #get the line number for our last </item> tag
    lastLine=$(grep -n -m $(($itemLimit-1)) "</item>" "$rssDir/$OLDrssFile" | tail -n1 | cut -d ":" -f 1)
    #set IFS to use line break as a delineator
    # OLDIFS=$IFS
    #SAK: Surely the following can be IFS="\n"
    #TODO: It can't, but there must be a better solution than below... THis should do it: IFS=$'\n'
    local IFS=$'\n'
#     IFS='
# '
    #IFS="\n"
    #Read in the old RSS file
    declare -a old_rss_data=( $(cat "$rssDir/$OLDrssFile") )
    arrayLen=${#old_rss_data[@]}
    #iterate through the array
    for index in $(seq $((firstLine-1)) $((lastLine-1))) ; do
      echo "${old_rss_data[$index]}" >> $rssDir/$TEMPrssFile
    done
    #copy line from old to new
    #if copied line is </item>
      #increment counter
    #if counter is great than tracking variable
      #break
  fi

  #close the file.
  echo -e '\t</channel>' >> $rssDir/$TEMPrssFile
  echo -e '</rss>' >> $rssDir/$TEMPrssFile

  #move fully formed temp file on top of the old file
  mv "$rssDir/$TEMPrssFile" "$rssDir/$OLDrssFile"
  echo "RSS ENTRY SUCCESSFULLY CREATED: $rssDir/$OLDrssFile"
  # IFS=$OLDIFS
  return 0
}

#####MOVE MODE LOGGING#####
#This function provides logging for move mode
performLoggingForMoveMode(){
  #Create undo and doover file if not present
  test ! -f "$m2kdir/undo.sh"   && echo "rm -f \"$m2kdir/undo.sh\"">>"$m2kdir/undo.sh"     && chmod 666 "$m2kdir/undo.sh"
  test ! -f "$m2kdir/doover.sh" && echo "rm -f \"$m2kdir/doover.sh\"">>"$m2kdir/doover.sh" && chmod 666 "$m2kdir/doover.sh"

  test "$SYMLINK" != "Disabled" && echo  "test -L \"$InputPath\" && rm -f \"$InputPath\" && echo removed \"$InputPath\"">>"$m2kdir/undo.sh"
  test "$SYMLINK" != "Disabled" && echo  "test -f \"$MoveDir/$ShowFileName.$OriginalExt\" && mv \"$MoveDir/$ShowFileName.$OriginalExt\" \"$InputPath\" && echo moved \"$MoveDir/$ShowFileName.$OriginalExt\" to \"$InputPath\"">>"$m2kdir/undo.sh"

  if [ "$SYMLINK" = "MOVE" ]; then
    test "$RequiresDoover" = "1" && echo "test -f \"$MoveDir/$ShowFileName.$OriginalExt\" && test -L \"$InputPath\" && rm -f \"$InputPath\" && echo Moving \"$InputPath\" to original location">>"$m2kdir/doover.sh"
    test "$RequiresDoover" = "1" && echo "test -f \"$MoveDir/$ShowFileName.$OriginalExt\" && mv \"$MoveDir/$ShowFileName.$OriginalExt\" '$InputPath'">>"$m2kdir/doover.sh"
    test "$RequiresDoover" = "1" && echo "myth2kodi \"$InputPath\" \"$InputTitle\" \"$InputSubtitle\"" >>"$m2kdir/doover.sh"
  fi
}

#####LINK MODE LOGGING#####
#This function performs logging for link mode
performLoggingForLinkMode(){
  #Create undo and doover file if not present
  test ! -f "$m2kdir/undo.sh" && echo "rm -f \"$m2kdir/undo.sh\"" >> "$m2kdir/undo.sh" && chmod 666 "$m2kdir/undo.sh"
  test ! -f "$m2kdir/doover.sh" && echo "rm -f \"$m2kdir/doover.sh\"">>"$m2kdir/doover.sh" && chmod 666 "$m2kdir/doover.sh"

  test "$RequiresDoover" = "1" && echo "test -L \"$MoveDir/$ShowFileName.$OriginalExt\" && rm -f \"$MoveDir/$ShowFileName.$OriginalExt\"">>"$m2kdir/doover.sh"
  test "$RequiresDoover" = "1" && echo "myth2kodi \"$InputPath\" \"$InputTitle\" \"$InputSubtitle\"">>"$m2kdir/doover.sh"
  echo "test -L \"$MoveDir/$ShowFileName.$OriginalExt\" && rm -f \"$MoveDir/$ShowFileName.$OriginalExt\"">>"$m2kdir/undo.sh"
  echo "'$MoveDir/$ShowFileName.$OriginalExt'" "'$InputPath'">>"$m2kdir"/created.tracking
}

writeJobToDooverQue(){
  test "$InputPath" != "" && echo "myth2kodi '$1' '$2' '$3'">>"$m2kdir"/doover.sh
}

doFailSafeMode(){
  echo "FAILSAFE FLAG WAS SET CHECK PERMISSIONS AND FOLDERS">>"$LogFile"
  echo "FAILSAFE FLAG WAS SET"
  if [ $FailSafeMode = "Enabled" ]; then
    echo "PERMISSION ERROR OR DRIVE FULL">>"$LogFile"
    echo "ATTEMPTING SYMLINK TO FAILSAFE DIR: $FailSafeDir">>"$LogFile"
    echo "ATTEPMTING SYMLINK TO FAILSAFE DIR"
    ln -s "$InputPath" "$FailSafeDir/$ShowFileName.$OriginalExt"
    test -f "$FailSafeDir/$ShowFileName.$OriginalExt";echo "FAILSAFE MODE COMPLETE: SYMLINK CREATED">>"$LogFile"
    test ! -f "$FailSafeDir/$ShowFileName.$OriginalExt"; echo "FAILSAFE MODE FAILURE CHECK PERMISSIONS AND FREE SPACE IN $FailSafeDir">>"$LogFile"
  fi

  test $Notify = Enabled && sudo -u "$NotifyUserName" /usr/local/bin/librarian-notify-send "myth2kodi FAILSAFE" "FAILSAFE mode active See $LogFile for more information" error
}

#####MYTHTV DATABASE#####
#This function gathers information from the MythTV database for use in the program
GetMythTVDatabase(){
  #TODO: This conditional seems weird as PythonBindings isn't set anywhere and
  #  even if it were set to True then this function would do nothing rather
  #  than accessing the database via the Python bindings...
  #TODO: try compressing the below with something like:
  #local dbselect="mysql -u$MySQLuser -p$MySQLpass -e \"use '$MySQLMythDb' ; printf \"select %s from recorded where basename like '$InputFileBasename';\""
  #then we'd have:
  #test "$InputTitle" = "" && InputTitle=`$dbselect  \"title\" | sed s/"title"/""/g | sed -n "2p"`
  #ChanID=`$dbselect  \"chanid\" | sed s/"\/"/""/g | sed -n 2p | sed s/"chanid"/""/g | sed s/" "/""/g`
  #etc
  if [ "$PythonBindings" != "True" ]; then
    #Obtain MythTV Database Information
    echo "Accessing MythTV DataBase:"
    #get Title
    test "$InputTitle" = "" && InputTitle=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select title from recorded where basename like '$InputFileBasename'; " | sed s/"title"/""/g | sed -n "2p"`
    #get Subtitle
    test "$InputSubtitle" = "" && InputSubtitle=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select subtitle from recorded where basename like '$InputFileBasename' ; " | sed s/"subtitle"/""/g | sed -n "2p"`
    #TODO: It's possible the following two lines require the '| sed -n "2p"' for filtering what is returned by the mysql SELECT -- So far I think I've only used the PythonBindings.
    #get Season Number, SydFTA sometimes has a season field #TODO: change call to enable Season Number as an input
    test "$InputSeasonNum" = "" && InputSeasonNum=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select season from recorded where basename like '$InputFileBasename' ;" | sed s/"season"/""/g | sed -n "2p"`
    #get Episode Number, SydFTA sometimes has an episode field  #TODO: change call to enable Episode Number as an input
    test "$InputEpisodeNum" = "" && InputEpisodeNum=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select episode from recorded where basename like '$InputFileBasename' ; " | sed s/"episode"/""/g | sed -n "2p"`
    #TODO: Determine if substitution of "/" with "" below is SchedulesDirect specific, if so move it to ProcessSchedulesDirect...
    #get chanid for recordings to identify program table
    ChanID=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select chanid from recorded where basename like '$InputFileBasename';" | sed s/"\/"/""/g | sed -n 2p | sed s/"chanid"/""/g | sed s/" "/""/g`
    #get ProgramID from recorded to identify program
    ProgramID=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select programid from recorded where basename like '$InputFileBasename' ; " | sed s/"\/"/""/g | sed -n "2p" | sed s/"programid"/""/g`
    #Get series id from basename to identify program
    LocalSeriesID=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select seriesid from recorded where basename like '$InputFileBasename' ; " | sed s/"\/"/""/g | sed -n "2p" | sed s/"seriesid"/""/g`
    #Get Plot from basename to identify program
    Plot=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select description from recorded where basename like '$InputFileBasename' ; " | sed s/"\/"/""/g | sed -n "2p" | sed s/"description"/""/g`
    #Get rating from basename to identify program
    Stars=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select stars from recorded where basename like '$InputFileBasename' ; " | sed s/"\/"/""/g | sed -n "2p" | sed s/"Stars"/""/g`
    #get show start time to identify program ----future development
    ShowStartTime=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select starttime from recorded where basename like '$InputFileBasename' ; " | sed s/"\/"/""/g | sed -n "2p" | sed s/"starttime"/""/g`
    #get category from recorded to identify program table -----future development
    ShowCategory=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select category from recorded where basename like '$InputFileBasename' ; " | sed s/"\/"/""/g | sed -n "2p" | sed s/"category"/""/g`
    #get storagegroup from recorded as a possible fallback to identify movies #TODO: Once accessing this works, make use of it...
    StorageGroup=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select storagegroup from recorded where basename like '$InputFileBasename' ; " | sed s/"\/"/""/g | sed -n "2p" | sed s/"storagegroup"/""/g`
    #get original air date for tv shows
    OriginalAirDate=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select originalairdate from recorded where basename like '$InputFileBasename' ; " | sed s/"\/"/""/g | sed -n "2p" | sed s/"originalairdate"/""/g`
    test "$OriginalAirDate" = "0000-00-00" && OriginalAirDate="$null"
    #get DataType
    XMLTVGrabber=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select xmltvgrabber from videosource ; " | sed s/"xmltvgrabber"/""/g | sed s/"\/"/""/g | sed -n "2p" | sed s/" "/""/g`
    #get year for movies
    MovieAirDate=`mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select airdate from recordedprogram where programid like '$ProgramID' and chanid like '$ChanID' ; " | sed s/"\/"/""/g | sed s/"airdate"/""/g | sed -n "2p" | sed s/" "/""/g`
    #Blank year if it is invalid
    if [ ! -z "$MovieAirDate" ] && [ $MovieAirDate -lt 1900 ]; then
      MovieAirDate=$null
    fi

    #####COMSKIP DATA#####
    #Set up counter, remove old markup data and generate new markup file from markupstart and stop
    if [ "$CommercialMarkup" = "Enabled" ]; then
      #Remove old and generate a comskip Start list
      echo "">"$m2kdir/markupstart.txt"
      mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select mark from recordedmarkup where starttime like '$ShowStartTime' and chanid like '$ChanID' and type like "4" ; " | sed s/"mark"/""/g | sed s/" "/""/g>>$m2kdir/markupstart.txt
      #Remove old and generate comskip Stop list
      echo "">"$m2kdir/markupstop.txt"
      mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select mark from recordedmarkup where starttime like '$ShowStartTime' and chanid like '$ChanID' and type like "5" ; " | sed s/"mark"/""/g | sed s/" "/""/g>>$m2kdir/markupstop.txt
      #Combine commercial data into a single comskip file and remove the initial files
      GenComSkip
    fi
    return 0
  fi
}

#####UTILIZE PYTHON BINDINGS TO GET MYTHTV DB##### Requires dependency
#TODO: Check functionality of and if necessary clean-up MythDataGrabber
GetMythTvPythonBindings(){
  echo "Attempting to pull database information on $InputPath"
  #make a named pipe for database output
  test ! -p "$m2kdir/mythicalDbOut" && mkfifo "$m2kdir/mythicalDbOut"

  #run the python bindings and output to named pipe
  /usr/local/bin/MythDataGrabber --filename="$InputFileBasename" --DBPin="$DBPin" --DBHostName="$DBHostName" --DBName="$MySQLMythDb" --DBUserName="$MySQLuser" --DBPassword="$MySQLpass"> "$m2kdir/mythicalDbOut" &
  pythonExitStatus=$?
  test "$pythonExitStatus" != "0" && echo -e "DATABASE ACCESS ERROR: COULD NOT OBTAIN INFORMATION \n  Check DBInfo in mythicalSetup, verify file is mythtv file"

  #read values from named pipe, remove quotes and declare $Variable=$Value
  while read var equals value ; do
    value=`echo $value | tr -d \"`
    test "$equals" = "=" && declare $var="$value"
    echo $var$equals$value
  done < "$m2kdir/mythicalDbOut" > /dev/null 2>&1

  if [ "$CommercialMarkup" = "Enabled" ]; then
    #Output commercial data to initial files
    printf "%s\n" "${startdata[@]}" >"$m2kdir/markupstart.txt"
    printf "%s\n" "${stopdata[@]}"  >"$m2kdir/markupstop.txt"
    #Combine commercial data into a single comskip file and remove the initial files
    GenComSkip
  fi

  #Import mythtv values into myth2kodi values, don't clobber title, subtitle, season-number, or episode-number.
  test "$InputTitle" = "" && InputTitle=$title
  test "$InputSubtitle" = "" && InputSubtitle=$subtitle
  test "$InputSeasonNum" = "" && InputSeasonNum=$season
  test "$InputEpisodeNum" = "" && InputEpisodeNum=$episode

  #redefine database var names into myth2kodi var names
  MovieAirDate=$airdate
  OriginalAirDate=$originalairdate
  ShowCategory=$category
  StorageGroup=$storeagegroup
  Stars=$stars
  Plot=$description
  LocalSeriesID=$seriesid
  ProgramID=$programid
  ChanID=$chanid
  ShowStartTime=$starttime

  #cleanup, remove the fifo named pipe
  test -p "$m2kdir/mythicalDbOut" && rm -f "$m2kdir/mythicalDbOut"
}

#####PROCESS DATABASE INFORMATION#####
#Function ProcessSchedulesDirect processes Zap2it/SchedulesDirect/Tribune data for use in the program
ProcessSchedulesDirect(){
  #Check for database permissions
  test "$ChanID" = "" && echo "%%%NO DATABASE INFORMATION. CHECK LOGIN/PASS OR FILE %%%%%">>"$LogFile"
  #disqualify invalid movie airdates
  test ! -z "$MovieAirDate" && test $MovieAirDate -lt 1900 && MovieAirDate=$null

  test "$OriginalAirDate" = "None" && OriginalAirDate=""
  test "$OriginalAirDate" = "none" && OriginalAirDate=""

  #Get rating from Stars
  rating=`printf "%0.f" $Stars`
  test $rating != "" && let rating=$rating*2
  test $rating = "" && rating=1

  #Create MV/EP/SH Identification Type from ProgramID
  m2kProgramIDCheck=${ProgramID:0:2}

  #Extrapolate data from Programid
  test "$m2kProgramIDCheck" = "SH" && ProgramIDType="Generic Episode With No Data"
  test "$m2kProgramIDCheck" = "MV" && ProgramIDType="Movie"
  test "$m2kProgramIDCheck" = "EP" && ProgramIDType="Series With Episode Data"
  test "$m2kProgramIDCheck" = "SP" && ProgramIDType="Sports Programming" && m2kProgramIDCheck=SH

  #account for .0123's in EITonly data type
  ProgramID=`echo $ProgramID | cut -f1 -d"."`

  #Check if database contains enough information to put into doover que
  GoForDoover=0
  test "${x:0:2}" = "EP" && echo woot
  test "$EpisodeSubtitle" != "" && GoForDoover=1

  #Get barebones zap2it series id.
  Zap2itSeriesID=`echo $ProgramID | tr -d MVSHEP | sed 's/0*//' | sed 's/.\{4\}$//'`

  #strip needless chars from date
  datehour=`echo "$ShowStartTime" | tr ":" "." | tr " " "@"`
  #get 4 digit year
  seasonyear=`echo "${ShowStartTime:0:4}"`

  #predefined naming conventions
  if [ "$ShowCategory" = "Sports event" -o "$ShowCategory" = "News" -o "$ShowCategory" = "Newsmagazine" ]; then
    NamingConvention=$ShowCategory
  fi

  #If news, bypass Categoric naming convention 1
  test NamingConvention="News" && UseMethod2=1

  return 0
}

#TODO: Rename as ExtractSxxExxFromPlot for consistency...
ExtractSxxExx(){
  #TODO: Maybe change the * to \? in most cases below so the matching is less inclusive
  #TODO: Maybe add warning in the case of 4x4 in case it's not actually an SxxExx
  #If available use the season and episode fields from MythTV database, otherwise,
  #use or attempt to determine $SeasonEpisode
  #extract a season number Sxx and episode number Exx
  #Assumes season and episode numbers in range 1-99
  if [ "$SeasonEpisode" = "" ] && [ "$InputSeasonNum" = "" ] && [ "$InputEpisodeNum" = "" ]; then
    #Check the Plot field for the SeasonEpisode info, SBS is big on
    #including it in the plot/description field instead of where it belongs
    #The below should work for any of the following forms:
    #S01E42 | (01x42) | s01e42 | 1X2 | S1E4 | (S01Ep42) | (S1Ep42) | 42x1 | (S.01Ep.42) | (S.01,Ep.42)
    SeasonEpisode=`echo $Plot | grep -i --only-matching '\(s\.*[0-9]*[0-9]\,*\(e\|ep\)\.*[0-9][0-9]*\)\|\([0-9]*[0-9]x[0-9][0-9]*\)'`
  fi
  if [ "$InputSeasonNum" != "" ] && [ "$InputEpisodeNum" != "" ]; then
    Sxx="$InputSeasonNum"
    Exx="$InputEpisodeNum"
  elif [ "$SeasonEpisode" != "" ]; then
    Sxx=`echo $SeasonEpisode | grep -i --only-matching '\(s\.*[0-9]*[0-9]\)\|\([0-9]*[0-9]x\)' | sed 's/s\.*\|x//I'`
    Exx=`echo $SeasonEpisode | grep -i --only-matching '\(\(e\|ep\)\.*[0-9][0-9]*\)\|\(x[0-9][0-9]*\)' | sed 's/\(E\.*\|Ep\.*\)\|x//I'`
    #Strip leading zero
    Sxx=${Sxx#0}
    Exx=${Exx#0}
  else
    echo "WARNING:${FUNCNAME}() - No Season & Episode number information is available."
    return 1
  fi
  #Single digit episode and show names are not allowed Ex and Sx replaced with Sxx Exx
  test $Sxx -lt 10  && Sxx="S0$Sxx" || Sxx="S$Sxx"
  test $Exx -lt 10  && Exx="E0$Exx" || Exx="E$Exx"

  return 0
}

RemoveSeasonEpisodeFromPlot(){
  if [ "$SeasonEpisode" != "" ] ; then
    #Check if it's in the leading position and if so, remove it
    local SEstring=`echo $Plot | grep -i --only-matching '(\?\(s\.*[0-9]*[0-9]\,*\(e\|ep\)\.*[0-9][0-9]*\))\?\s*\|(\?\([0-9]*[0-9]x[0-9][0-9]*\))\?\s*'`
    if [ "$SEstring" != "" ] ; then
      echo "WARNING: SeasonEpisode was in the leading position of the Plot field, removing it to simplify subsequent processing."
      Plot=`echo $Plot | sed s/"$SEstring"/""/`
      #TODO: Still need to strip any trailing space or leading "- " from the Plot
    fi
  else
    echo "WARNING: SeasonEpisode isn't currently set, so not going to discard it from Plot field."
  fi
}

#TODO: Rename as ExtractSubtitleFromPlot for consistency -- guessing will now be done elsewhere
GuessSubtitle(){
  #NOTE:
  #Try to extract a subtitle from the plot field (Luv Ya SBS)
  InputSubtitle=`echo $Plot | grep --only-matching '^\(\(\(\(\w\+\)\(.\?\s*\)\)\|\(\&\s*\)\)\{1,7\}\)\( -\|\:\)'`
  #Clean off the trailing " -" or ":" that we're using to identify it
  InputSubtitle=`echo $InputSubtitle | grep --only-matching '\(\(\(\w\+\)\(.*\s*\)\)\|\(\&\s*\)\)\{,7\}\(\w\+\)'`
  echo "Guessed Subtitle from Plot field as '$InputSubtitle'"
  return 0
}

RemoveSubtitleFromPlot(){
  #TODO: If we extracted a subtitle from Plot variable then remove that text from Plot.
  if [ "$InputSubtitle" != "" ] ; then
    local STstring=$(echo $Plot | grep --only-matching '^\(\(\(\(\w\+\)\(.\?\s*\)\)\|\(\&\s*\)\)\{1,7\}\)\( -\|\:\)\s*')
    if [ "$STstring" != "" ] ; then
      echo "WARNING: Episode subtitle was in the Plot field, removing it to simplify subsequent processing."
      Plot=$(echo $Plot | sed s/"$STstring"/""/)
    fi
  else
    echo "WARNING: InputSubtitle isn't currently set, so not going to discard it from Plot field."
  fi
}

#A Process function compatible with Sydney over the air data...
ProcessSydFTA(){
  #Check for database permissions
  test "$ChanID" = "" && echo "%%%NO DATABASE INFORMATION. CHECK LOGIN/PASS OR FILE %%%%%">>"$LogFile"
  #disqualify invalid movie airdates
  test ! -z "$MovieAirDate" && test $MovieAirDate -lt 1900 && MovieAirDate=$null

  #We don't use these, but if they're "none" we still want them changed to ""
  test "$OriginalAirDate" = "None" && OriginalAirDate=""
  test "$OriginalAirDate" = "none" && OriginalAirDate=""

  #TODO:#NOTE: Stars field in SydFTA data tends to be empty, consider what to do here.
  #Get rating from Stars
  rating=`printf "%0.f" $Stars`
  test $rating != "" && let rating=$rating*2
  test $rating = "" && rating=1

  #TODO: Does this need to be more general, accounting for 00 | S0 | S00 | etc
  #  On the other hand, if it's reliably 0, then remove this and just
  #  change the conditionals to check for 0
  #Default value for season and episode numbers is 0, not $null or ""
  test "$InputSeasonNum" = 0 && InputSeasonNum=$null
  test "$InputEpisodeNum" = 0 && InputEpisodeNum=$null

  ###The ProgramID field from FTA EPG data in Sydney?Australia? doesn't specify MV/EP/SH,
  ###the Movie specification is "almost-always" found in the Category field of
  ###the MythTV database. So, we'll use that.
  if [ "$ShowCategory" = "Movie" ]; then
    m2kProgramIDCheck="MV"
  else #For now assume that if it's not a Movie it's an episode of a series
    #TODO: For now we mainly/only record Movies and Episodes of TV series,
    #  so, this is an ok approximation, but should look through more EPG data
    #  and determine whether the Category field reliably distinguishes things
    #  like news, sport, etc
    m2kProgramIDCheck="EP"
  fi

  #TODO: Check the SeriesID field in MythTV DB & see if we can make more
  #  sensible use of whatever it contains...

  #If the information is already available, set the Sxx & Exx variables
  if [ "$m2kProgramIDCheck" = "EP" ]; then
    ExtractSxxExx
    RemoveSeasonEpisodeFromPlot
    #If we haven't set a Subtitle yet, try and get one from $Plot
    if [ "$InputSubtitle" = "" ]; then
      GuessSubtitle
      RemoveSubtitleFromPlot
    fi
  fi

  #Strip the Movie: tag that some stations very helpfully put in the title field...
  if  [ "$m2kProgramIDCheck" = "MV" ]; then
    InputTitle=`echo $InputTitle | sed s/"Movie:\s*"/""/I`
  fi

  #Extrapolate data from Programid
  test "$m2kProgramIDCheck" = "SH" && ProgramIDType="Generic Episode With No Data"
  test "$m2kProgramIDCheck" = "MV" && ProgramIDType="Movie"
  test "$m2kProgramIDCheck" = "EP" && ProgramIDType="Series With Episode Data"
  test "$m2kProgramIDCheck" = "SP" && ProgramIDType="Sports Programming" && m2kProgramIDCheck=SH

  #FTA stations providing a ProgramID use CRID: https://en.wikipedia.org/wiki/Crid
  #Remove the leading CRID://
  ProgramID=`echo $ProgramID | sed s/"crid:\/\/"//I`
  #Extract the Authority, ie the station broadcasting the show
  ProgramAuthority=`echo $ProgramID | cut -f1 -d"/"`
  #Extract the show specific information, removing the leading /
  ProgramData=`echo $ProgramID | sed s/$ProgramAuthority"\/"//`
  #Populate the ProgramID variable with the ProgramData field of CRID
  ProgramID=$ProgramData

  #strip needless chars from date
  datehour=`echo "$ShowStartTime" | tr ":" "." | tr " " "@"`

  #predefined naming conventions
  if [ "$ShowCategory" = "Sports event" -o "$ShowCategory" = "News" -o "$ShowCategory" = "Newsmagazine" ]; then
    NamingConvention=$ShowCategory
  fi

  #If news, bypass Categoric naming convention 1
  test NamingConvention="News" && UseMethod2=1

  return 0
}

#####PROCESS DATABASE INFORMATION#####
####NoLookup is an alternate mode where TheTvDb is not used for lookups
ProcessNoLookup(){
  #Check for database permissions
  test "$ChanID" = "" && echo "%%%NO DATABASE INFORMATION. CHECK LOGIN/PASS OR FILE %%%%%">>"$LogFile"
  #disqualify invalid movie airdates
  test ! -z "$MovieAirDate" && test $MovieAirDate -lt 1900 && MovieAirDate=$null

  #Get rating from Stars
  rating=`printf "%0.f" $Stars`
  test $rating != "" && let rating=$rating*2
  test $rating = "" && rating=1

  #Create MV/EP/SH Identification Type from ProgramID
  m2kProgramIDCheck=${ProgramID:0:2}

  #Spoof show as episode to avoid programid
  test "$m2kProgramIDCheck" = "EP" && ProgramIDType="Generic Episode With No Data" && m2kProgramIDCheck="SH"
  #Extrapolate data from Programid
  test "$m2kProgramIDCheck" = "SH" && ProgramIDType="Generic Episode With No Data"
  test "$m2kProgramIDCheck" = "MV" && ProgramIDType="Movie"
  test "$m2kProgramIDCheck" = "SP" && ProgramIDType="Sports Programming" && m2kProgramIDCheck=SH

  #account for .0123's in EITonly data type
  ProgramID=`echo $ProgramID | cut -f1 -d"."`

  #This probably isn't necessary, but adding it for the time-being match previous state. #SAK
  Zap2itSeriesID="$LocalSeriesID"

  #strip needless chars from date
  datehour=`echo "$ShowStartTime" | tr ":" "." | tr " " "@"`
  #get 4 digit year
  seasonyear=`echo "${ShowStartTime:0:4}"`

  if [ "$ShowCategory" = "Sports event" -o "$ShowCategory" = "News" -o "$ShowCategory" = "Newsmagazine" ]; then
    NamingConvention=$ShowCategory
  fi
  test NamingConvention="News" && UseMethod2=1

  return 0
}

#####REMOVE ENTRIES FROM LIBRARY#####
#remove mythtv recording's pictures and database entries.  Thanks to barney_1.
DeleteRelevantDatabaseFilesAndPictures(){
  #Make sure we got input arguments and file is valid
  if [ ! -e "$InputPath" ]; then
    #Remove recording entry from mysql database
    echo "REMOVING - $FileBaseName - THUMBNAILS - DATABASE ENTRIES" | tee -a "$LogFile"
    mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; delete from recorded where basename like '$FileBaseName'; "
    #Remove thumbnails
    rm -f "$originaldirname/$FileBaseName".*
  fi
  return 0
}

#####USE AbsoluteEpisodeNumber TO SET SXX AND EXX#####
setSxxAndExxFromAbsoluteEpisodeNumber(){
  #if line match is obtained, then gather new episode name, Sxx and Exx
  EpisodeSubtitle=`sed -n $AbsoluteEpisodeNumber'p' "$m2kdir"/"$NewShowName"/"$NewShowName".actualEname.txt`

  #gather series and episode names from files created earlier.
  Exx=`sed -n $AbsoluteEpisodeNumber'p' "$m2kdir"/"$NewShowName"/"$NewShowName".E.txt`
  Sxx=`sed -n $AbsoluteEpisodeNumber'p' "$m2kdir"/"$NewShowName"/"$NewShowName".S.txt`
  test $Sxx != "" && SeasonNumber=$Sxx

  #Single digit episode and show names are not allowed Ex and Sx replaced with Exx Sxx
  test $Exx -lt 10  && Exx="E0$Exx" || Exx="E$Exx"
  test $Sxx -lt 10  && Sxx="S0$Sxx" || Sxx="S$Sxx"
  echo "EPISODE:$EpisodeSubtitle EPISODE NUMBER:$AbsoluteEpisodeNumber $Sxx$Exx WITH CONFIDENCE: $EpisodeConfidenceRating"
}

determineIfDatabaseIsUpToDate(){
  #Get current server time
  test -f "$m2kdir/$NewShowName/current.time" && rm -f "$m2kdir/$NewShowName/current.time"
  curl -L -s -m"$Timeout" "http://www.thetvdb.com/api/Updates.php?type=none">"$m2kdir/$NewShowName/current.time"

  #Get the time from the file
  test -f "$m2kdir/$NewShowName/current.time" && CurrentTime=`cat "$m2kdir/$NewShowName/current.time" | grep '<Time>' | sed s/"<\/\?Time>"/""/g`
  test "$CurrentTime" = "" && CurrentTime=99999999
  rm -f "$m2kdir/$NewShowName/current.time"

  #If file exist for last updated time, then get value
  if [ -f "$m2kdir/$NewShowName/lastupdated.time" ]; then
    LastUpdated=`cat "$m2kdir/$NewShowName/lastupdated.time"`

  #If no last updated time, then assign a never updated value and update now
  elif [ ! -f "$m2kdir/$NewShowName/lastupdated.time" ]; then
    return 1
  fi

  #if time server is down, then just update
  if [ "$CurrentTime" = "" -o "$CurrentTime" = "99999999" ]; then
    echo "THETVDB TIME SERVER WAS DOWN"
    return 1
  fi

  #Apply Database Update interval to last update time  LastUpdated = NextUpdated
  NextUpdate=0
  let NextUpdate=$LastUpdated+$UpdateDatabase

  #if episode information is out of date or not created
  if [ $CurrentTime -gt $NextUpdate ]; then
    curl -L -s -m"$Timeout" " http://www.thetvdb.com/api/Updates.php?type=all&time=$LastUpdated" >> "$m2kdir/$NewShowName/UpdatesList.txt"
    grep "$SeriesID" "$m2kdir/$NewShowName/UpdatesList.txt"
    if [ "$?" != 0 ]; then
      echo "DATABASE IS OUT OF DATE. NEXT UPDATE $NextUpdate Current $CurrentTime"
      return 1
    else
      return 0
    fi
  #Send report to the log if database was not updated.
  elif [ $CurrentTime -le $NextUpdate ]; then
    echo "DATABASE IS MAINTAINED. TIME IS:$CurrentTime NEXT UPDATE IS:$NextUpdate"
    return
  fi
  #some other condition was present. update anyways.
  return 1
}

#####GET EPISODE INFORMATION#####
downloadInfoAboutMatchedTitleAndCreateTxtFileTables(){
  #Download information from server
  echo -ne "Downloading Series: $SeriesID \n" 1>&2
  local TheTVDBShowXML="http://www.thetvdb.com/api/$APIkey/series/$SeriesID/all/$Language.xml"
  local FieldsWeWant="(</?Series>|</?seriesid>|</?Status>|</?lastupdated>|</?Episode>|</?EpisodeName>|</?FirstAired>|</?SeasonNumber>|</?EpisodeNumber>|</?Overview>)"
  curl -L -s -m"$Timeout" $TheTVDBShowXML | grep -E $FieldsWeWant > "$m2kdir/$NewShowName/$NewShowName.xmlTest"
  test $? = 0 && echo "$CurrentTime" > "$m2kdir/$NewShowName/lastupdated.time"

  #Validate that the show has a EpisodeName tag and is a valid download before clobbering our old download.
  grepTest=""
  grepTest=`grep "EpisodeName" "$m2kdir/$NewShowName/$NewShowName.xmlTest"`
  test "$grepTest" != "" && mv "$m2kdir/$NewShowName/$NewShowName.xmlTest" "$m2kdir/$NewShowName/$NewShowName.xml"

  #create a folder/file "database" Strip XML tags.  Series, Exx and Sxx are separated into different files
  if [ -f "$m2kdir/$NewShowName/$NewShowName.xml" ]; then
    Ename=""
    actualEname=""
    FAired=""
    SeasonNr=""
    EpisodeNr=""
    EpisodeOverview=""
    recordNumber=-1
    #TODO: Unless there is some reason to keep repeated info in the same file,
    #  it seems like it'd be better to mv existing file to .old or .$Today.old,
    #  the problem with the latter being it'd require manual cleanup, but it has
    #  the benefit of maintaining more past data to revert to...
    echo "Parsing Downloaded information: $NewShowName.xml "
    while read line ; do
      if [[ $recordNumber < 0 ]]; then
        #TODO:Check for a Status line and if it exists and says Ended then touch
        #  a file called Status.Ended in the $m2kdir/$NewShowName/
        #  directory, then add a check for this before we bother trying to
        #  download information again. Also, use the lastupdated field if present.
        #Skip lines until the end series block tag is found
        if [[ $line == \<\/Series\> ]]; then
          #Start processing the episode info
          recordNumber=0
        fi
      elif [[ $line == \<\/Episode\> ]]; then
        (( ++recordNumber ))
        echo -ne "Building Record:$recordNumber ${actualEname:0:20}           \n" 1>&2
        echo "$actualEname" >> "$m2kdir/$NewShowName/$NewShowName.actualEname.txt"
        echo "$Ename" >> "$m2kdir/$NewShowName/$NewShowName.Ename.txt"
        echo "$FAired" >> "$m2kdir/$NewShowName/$NewShowName.FAired.txt"
        echo "$SeasonNr" >> "$m2kdir/$NewShowName/$NewShowName.S.txt"
        echo "$EpisodeNr" >> "$m2kdir/$NewShowName/$NewShowName.E.txt"
        echo "$EpisodeOverview" >> "$m2kdir/$NewShowName/$NewShowName.Plot.txt"
        Ename=""
        actualEname=""
        FAired=""
        SeasonNr=""
        EpisodeNr=""
        EpisodeOverview=""
      #Get actual show name
      elif [[ $line == \<EpisodeName\>* ]]; then
        line=${line/<\/EpisodeName>/}
        line=${line/<EpisodeName>/}
        line=${line/&lt;/}
        line=${line/&gt;/} 
        line=${line/&quot;/} 
        line=${line/&amp;/&}
        line=${line/|/}
        line=${line/\?/}
        line=${line/\*/}
        line=${line/:/}
        line=${line/+/}
        line=${line/\\/}
        line=${line/\//}
        line=${line/[/}
        line=${line/]/}
        line=${line/\'/}
        line=${line/\"/}
        actualEname=${line/&ndash;/-}
        Ename=${actualEname/;*/}
      #Get OriginalAirDate
      elif [[ $line == \<FirstAired\>* ]]; then
        line=${line/<\/FirstAired>/}
        line=${line/<FirstAired>/}
        FAired=$line
      #Get Season number
      elif [[ $line == \<SeasonNumber\>* ]]; then
        line=${line/<\/SeasonNumber>/}
        line=${line/<SeasonNumber>/}
        SeasonNr=$line
      #Get Episode number
      elif [[ $line == \<EpisodeNumber\>* ]]; then
        line=${line/<\/EpisodeNumber>/}
        line=${line/<EpisodeNumber>/}
        EpisodeNr=$line
      #Get Episode Overview
      elif [[ $line == \<Overview\>* ]]; then
        line=${line/<\/Overview>/}
        line=${line/<Overview>/}
        EpisodeOverview=$line
      fi
    done < "$m2kdir/$NewShowName/$NewShowName.xml"

    chmod 666 "$m2kdir/$NewShowName/$NewShowName".actualEname.txt
    chmod 666 "$m2kdir/$NewShowName/$NewShowName".Ename.txt
    chmod 666 "$m2kdir/$NewShowName/$NewShowName".FAired.txt
    chmod 666 "$m2kdir/$NewShowName/$NewShowName".S.txt
    chmod 666 "$m2kdir/$NewShowName/$NewShowName".E.txt
    chmod 666 "$m2kdir/$NewShowName/$NewShowName".Plot.txt
    GotNewInformation=1

  elif [ ! -f "$m2kdir/$NewShowName/$NewShowName.xml" ]; then
    echo "COULD NOT DOWNLOAD:$TheTVDBShowXML">>"$LogFile"
  fi
  #check if files were created and generate message
  if [ "$GotNewInformation" = "1" ]; then
    return 0
    echo $CurrentTime>"$m2kdir/$NewShowName/lastupdated.time" && chmod 666 $CurrentTime>"$m2kdir/$NewShowName/lastupdated.time"
    echo "LOCAL DATABASE UPDATED:$m2kdir/$NewShowName">>"$LogFile"
  elif [ ! -f "$m2kdir/$NewShowName/$NewShowName.Ename.txt" ]; then
    echo "*** PERMISSION ERROR $m2kdir/$NewShowName/">>"$LogFile"
    return 1
  fi
  return 1
}

#####MATCH ZAP2ITID TO TVDB#####
GetSeriesLineNumberFromTableWithZap2itID(){
  if [ -n $Zap2itSeriesID ] ; then
    serieslinenumber=0
    #loop through all show names received by TheTvDb and match Zap2it ID.
    while read line ; do
      (( ++ serieslinenumber ))
      echo "TESTING FOR ZAP2ITID MATCH:$line `sed -n $serieslinenumber"p" $m2kdir/shn.txt`"
      Zap2ItTest=`echo $line | tr -d MVSHEP | sed 's/0*//'`
      if [ "$Zap2ItTest" = "$Zap2itSeriesID" ] && [ "$Zap2itSeriesID" != "" ]; then
        return 0
        break
      fi
    done < "$m2kdir"/zap2it.txt
    return 1
  else
    echo "WARNING:GetSeriesLineNumberFromTableWithZap2itID() called, with no Zap2itSeriesID"
    return 1
  fi
}

#####FUZZY LOGIC RECOGNITION OF SERIES#####
#This function provides fuzzy logic matching of a show name and returns a seriesid
GetSeriesLineNumberFromTableWithFuzzyLogic(){
  serieslinenumber=`agrep -Byn "${ShowName:0:27}" "$m2kdir/shn.txt" | sed 's/:.*//' | grep -m1 ^`
  #Correct for serieslinenumber = ""
  test "$serieslinenumber" = "" && serieslinenumber="0"

  #Get the seriesid based on the showname
  if [ $serieslinenumber -gt 0 ]; then
    return 0
  fi
  return 1
}

#####STANDARD TITLE RECOGNITION OF SERIES#####
GetSeriesLineNumberFromTableWithStandardLogic(){
  serieslinenumber=`grep -nix "$ShowName" "$m2kdir/shn.txt" | sed 's/:.*//' | grep -m1 ^`

  #Correct for serieslinenumber = ""
  test "$serieslinenumber" = "" && serieslinenumber="0"
  #Get the seriesid based on the showname
  if [ $serieslinenumber -ge 1 ]; then
    return 0
  fi
  return 1
}

##### RESOLUTION OF MULTIPLE AIRDATE MATCHES #####
#ResolveMultipleAirdateMatches is used in the event of multiple matches on the same airdate
#It resolves a conflict by matching the matched airdate by title.
ResolveMultipleAirdateMatches(){
  local NewShowBasename="$m2kdir/$NewShowName/$NewShowName"
  #Cleanup from last instance match if required
  ConfidenceReasoning="$ConfidenceReasoning Conflict; Multiple Airdates Detected- Parsed results; Attempted to resolve conflict with Standard Logic:"
  test -f "$NewShowBasename.InstanceEnames.txt"            && rm "$NewShowBasename.InstanceEnames.txt"
  test -f "$NewShowBasename.InstanceFAiredLineNumbers.txt" && rm "$NewShowBasename.InstanceFAiredLineNumbers.txt"
  test -f "$NewShowBasename.InstanceLineNumbers.txt"       && rm "$NewShowBasename.InstanceLineNumbers.txt"
  #Create a list of line numbers which match original airdate
  grep -n "$OriginalAirDate" "$NewShowBasename.FAired.txt" | sed 's/:.*//'>>"$NewShowBasename.InstanceFAiredLineNumbers.txt"
  #Loop through list and create instance matching files
  while read line ; do
    echo "$line" >>"$NewShowBasename.InstanceLineNumbers.txt"
    sed -n $line'p' "$NewShowBasename.Ename.txt" >> "$NewShowBasename.InstanceEnames.txt"
  done < "$NewShowBasename.InstanceFAiredLineNumbers.txt"

  #get instance line number
  IntermediateEpisodeNumber=`grep -ni "$EpisodeSubtitle" "$NewShowBasename.InstanceEnames.txt" | grep -m1 ^ | sed 's/:.*//'`
  #translate instance line number to actual line number
  if [ "$IntermediateEpisodeNumber" != "" ] ; then
    AbsoluteEpisodeNumber=`sed -n $IntermediateEpisodeNumber'p' "$NewShowBasename.InstanceLineNumbers.txt"`
  fi
  if [ "$AbsoluteEpisodeNumber" != "" ]; then
    ConfidenceReasoning="$ConfidenceReasoning Successful;"
    return 0
  else
    ConfidenceReasoning="$ConfidenceReasoning Failed; Attempted to resolve conflict with Fuzzy Logic:"
    #get instance line number
    IntermediateEpisodeNumber=`agrep -Byn "${EpisodeSubtitle:0:29}" "$NewShowBasename.InstanceEnames.txt" | grep -m1 ^ | sed 's/:.*//'`
    #translate instance line number to actual line number
    if [ "$IntermediateEpisodeNumber" != "" ] ; then
      AbsoluteEpisodeNumber=`sed -n $IntermediateEpisodeNumber'p' "$NewShowBasename.InstanceLineNumbers.txt"`
    fi
    if [ "$AbsoluteEpisodeNumber" != "" ]; then
      ConfidenceReasoning="$ConfidenceReasoning Successful;"
      return 0
    else
      ConfidenceReasoning="$ConfidenceReasoning Failed;"
      return 1
    fi
  fi
  return 1
}

#####CREATE SHOW FOLDER#####
makeShowDirIfNeeded(){
  if [ ! -d "$m2kdir/$NewShowName" ]; then
    mkdir "$m2kdir/$NewShowName"
    chmod 777 "$m2kdir/$NewShowName" #TODO: consider chmod 755
    echo "Creating myth2kodi Database Folder">>"$LogFile"
  fi
}

#####SET THE SERIESID AND SHOW NAME#####
setSeriesIDandNewShowNameBasedOnSeriesLineNumber(){
  #Get the seriesid based on the showname
  SeriesID=`sed -n $serieslinenumber'p' "$m2kdir"/sid.txt | grep -m1 ^`
  NewShowName=`sed -n $serieslinenumber'p' "$m2kdir"/shn.txt | grep -m1 ^ | sed s/"&amp;"/"\&"/g`

  #Cleanup files to prevent mismatch next time
  test -f "$m2kdir"/sid.txt && rm -f "$m2kdir"/sid.txt
  test -f "$m2kdir"/shn.txt && rm -f "$m2kdir"/shn.txt
  test -f "$m2kdir"/Zap2it.txt && rm -f "$m2kdir"/Zap2it.txt
}

#####AIRDATE MATCH#####
getAbsoluteEpisodeNumberWithOriginalAirdate(){
  AbsoluteEpisodeNumber=""
  if [ "$OriginalAirDate" != "" ] ; then
    AbsoluteEpisodeNumber=`grep -n "$OriginalAirDate" "$m2kdir/$NewShowName/$NewShowName.FAired.txt" | grep -m1 ^ | sed 's/:.*//'`
  fi
  #Account for original series airdate
  if [ "$AbsoluteEpisodeNumber" != "" ] && [ $AbsoluteEpisodeNumber -gt 0 ]; then
    #Account for original show airdate = first air date
    NumberOriginalAirdates=`grep "$OriginalAirDate" "$m2kdir/$NewShowName/$NewShowName.FAired.txt" | wc -l`
    test $NumberOriginalAirdates -gt 1 && return 1
    echo "Absolute Exx NR:$AbsoluteEpisodeNumber BASED ON AIRDATE:$OriginalAirDate" | tee -a "$LogFile"
    return 0
  fi
  return 2
}

#Get the AbsoluteEpisodeNumber corresponding to Sxx and Exx
getAbsoluteEpisodeNumberWithSxxExx(){
  AbsoluteEpisodeNumber=""
  Snum=${Sxx#S} ; Snum=${Snum#0}
  Enum=${Exx#E} ; Enum=${Enum#0}
  SxxAENs=`grep -nix "$Snum" "$m2kdir/$NewShowName/$NewShowName.S.txt" | sed s/:.*//`
  ExxAENs=`grep -nix "$Enum" "$m2kdir/$NewShowName/$NewShowName.E.txt" | sed s/:.*//`
  AbsoluteEpisodeNumber=`comm -12 <(echo $SxxAENs | sed s/" "/"\n"/g | sort) <(echo $ExxAENs | sed s/" "/"\n"/g | sort)`
  if [ "$AbsoluteEpisodeNumber" != "" ] && [ $AbsoluteEpisodeNumber -gt 0 ]; then
    echo "Using SxxExx, determined AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber"
    return 0
  fi
  echo "WARNING: Failed to determine AbsoluteEpisodeNumber"
  return 1
}

######STANDARD LOGIC EPISODE MATCH#####
##TODO we need some sort of regex to account for matches like
##'The Office' 'The Delivery, Part 1'   -guide data
##'The Office' 'The Delivery (1)'       -TvDb data
getAbsoluteEpisodeNumberWithStandardLogic(){
  AbsoluteEpisodeNumber=""
  AbsoluteEpisodeNumber=`grep -nix "$EpisodeSubtitle" "$m2kdir/$NewShowName/$NewShowName.Ename.txt" | grep -m1 ^ | sed 's/:.*//'`
  if [ "$AbsoluteEpisodeNumber" != "" ] && [ $AbsoluteEpisodeNumber -gt 0 ]; then
    return 0
  fi
  return 1
}

######FUZZY LOGIC EPISODE MATCH#####
getAbsoluteEpisodeNumberWithFuzzyLogic(){
  AbsoluteEpisodeNumber=""
  AbsoluteEpisodeNumber=`agrep -Byn "${EpisodeSubtitle:0:29}" "$m2kdir/$NewShowName/$NewShowName.Ename.txt" | grep -m1 ^ | sed 's/:.*//'`
  if [ "$AbsoluteEpisodeNumber" != "" ] && [ $AbsoluteEpisodeNumber -gt 0 ]; then
    return 0
  fi
  return 1
}

#####SEARCH THETVDB AND CREATE DATA FILES#####
searchTheTvDbAndReturnTxtFileTables(){
  #TODO: Instance searching rather then global.  Need to create an instance variable based on time and chanid.
  #Search TheTvDb and return an XML file with results
  curl -L -s -m"$Timeout" www.thetvdb.com/api/GetSeries.php?seriesname=$tvdbshowname>"$m2kdir/working.xml"

  #Separate the XML into textual DBs containing SeriesID, ShowName and Zap2it IDs
  cat "$m2kdir/working.xml" | grep "<seriesid>" | sed -e s/"<\/\?seriesid>"//g \
                                                      -e s/'&quot;'/'"'/       \
                                                      -e s/"&amp;"/"\&"/       \
                                                      -e s/'&ndash;'/'-'/      \
                                                      -e s/"&lt;"/"<"/         \
                                                      -e s/"&gt;"/">"/ >"$m2kdir/sid.txt"
  cat "$m2kdir/working.xml" | grep "<SeriesName>" | sed -e s/"<\/\?SeriesName>"//g \
                                                        -e s/'&quot;'/'"'/         \
                                                        -e s/"&amp;"/"\&"/         \
                                                        -e s/'&ndash;'/'-'/        \
                                                        -e s/"&lt;"/"<"/           \
                                                        -e s/"&gt;"/">"/ >"$m2kdir/shn.txt"

  #parse the XML for shows with Zap2ItIDs
  test -f "$m2kdir/zap2it.txt" && rm -f "$m2kdir/zap2it.txt"
  while read line ; do
    test "$line" = "<Series>" && NextShow=1
    test "$line" = "</Series>" && test "$NextShow" = "1" && echo "" >>"$m2kdir/zap2it.txt" && NextShow=0

    if [[ $line =~ '<zap2it_id>'* ]] ; then
      echo $line | sed -e s/"<\/\?zap2it_id>"// \
                       -e s/'&quot;'/'"'/       \
                       -e s/"&amp;"/"\&"/       \
                       -e s/'&ndash;'/'-'/      \
                       -e s/"&lt;"/"<"/         \
                       -e s/"&gt;"/">"/ >>"$m2kdir/zap2it.txt"
      NextShow=0
    fi
  done < "$m2kdir/working.xml"
}

DoTestFileExit(){
  [[ -d ./Episodes ]] && [[ ! "$(ls -A ./Episodes)" ]] && rmdir ./Episodes
  [[ -d ./Movies ]]   && [[ ! "$(ls -A ./Movies)" ]]   && rmdir ./Movies
  [[ -d ./Showings ]] && [[ ! "$(ls -A ./Showings)" ]] && rmdir ./Showings
  exit 0
}

updateRunningFuzzyLogicErrorCount(){
  #additional logging for statistical purposes
  test ! -f "$m2kdir"/FuzzyLogicError.log && echo "0">"$m2kdir"/FuzzyLogicError.log
  FuzzyLogicError="`cat "$m2kdir"/FuzzyLogicError.log`"
  (( ++FuzzyLogicError ))
  rm -f "$m2kdir"/FuzzyLogicError.log
  echo "$FuzzyLogicError">"$m2kdir"/FuzzyLogicError.log
}

updateRunningTotalMatchesCount(){
  #additional logging for statistical purposes
  test ! -f "$m2kdir"/TotalEpisodeMatches.log && echo "0">"$m2kdir"/TotalEpisodeMatches.log
  FuzzyLogicMatches="`cat "$m2kdir"/TotalEpisodeMatches.log`"
  (( ++FuzzyLogicMatches ))
  rm -f "$m2kdir"/TotalEpisodeMatches.log
  echo "$FuzzyLogicMatches">"$m2kdir"/TotalEpisodeMatches.log
}

#Function DoMythTVPermissionsCheck will check to see if the file is
#owned by mythtv and cause myth2kodi to exit with a descriptive
#message if certain criteria are met.
DoMythTVPermissionsCheck(){
  # if no bypass, and file is owned by mythtv, and username is not mythtv
  # and system is set to use mythtv database, and symlink is move
  #TODO: This might not work
  #TODO: Probably should change explicit "mythtv" here to a variable designating
  #  a single authorised librarian, eg Librarian="mythtv", then adding a simple
  #  check of $MyUserName and bailing with an ERROR message if != $Librarian,
  #  this should avoid most/all permission issues.
  if [ "$InputOption" != "--BypassPermissionsCheck" ] || [ "$InputOption" = "" ] && [ "$InputSubtitle" = "" ] && [ "$InputTitle" != "--BypassPermissionsCheck" ]; then
    if  [ "`ls -l \"$InputPath\"| awk '{ print $3 }'`" = "mythtv" ] && [ "$MyUserName" != "mythtv" ] && [ "$SYMLINK" = "MOVE" ]; then
      UserName=$USER
      echo -e " ########################################################################" | tee -a "$LogFile"
      echo -e " ##############################  ERROR  #################################" | tee -a "$LogFile"
      echo -e " ########################################################################" | tee -a "$LogFile"
      echo -e " USER NAME:$UserName ATTEMPTED TO RENAME A MYTHTV OWNED FILE" | tee -a "$LogFile"
      echo -e " myth2kodi HAS PREVENTED THIS UNAUTHORIZED FILE ACTION" | tee -a "$LogFile"
      echo -e " THIS IS A SAFETY FEATURE TO PRESERVE FILE PERMISSIONS." | tee -a "$LogFile"
      echo -e " PLEASE RUN THE FOLLOWING TO SET PROPER PERMISSIONS WHEN RENAMING FILES:" | tee -a "$LogFile"
      echo -e " sudo su mythtv" | tee -a "$LogFile"
      echo -e " myth2kodi \"$InputPath\" \"$InputTitle\" \"$InputSubtitle\"" | tee -a "$LogFile"
      echo -e " OR AT YOUR OWN RISK BYPASS THIS CHECK BY ADDING --BypassPermissionsCheck" | tee -a "$LogFile"
      echo -e " AT THE END OF THE LINE YOU JUST RAN." | tee -a "$LogFile"
      echo -e " " | tee -a "$LogFile"
      echo -e " Done." | tee -a "$LogFile"
      jobtype="PermissionErrorWhileMoving"
      RunJob
    fi
  fi
}

UserJobOutsideMythTV(){
  echo -e " ERROR: MythTV User Job is only valid when run as a user job by MythTV."
  echo -e " When outside MythTV call the file directly, EG."
  echo -e " myth2kodi /path_to/file.ext"
  echo -e "   --OR when looking up a non database Episode--"
  echo -e " myth2kodi /path_to/file.ext \"Title of Show\" \"Subtitle of show\""
  echo -e "done."
  jobtype="GenericUnspecifiedError"
  RunJob
}

DisplayShowWarning(){
  echo "GENERIC GUIDE DATA WAS SUPPLIED TYPE: $ProgramIDType- $InputTitle, $InputSubtitle">>"$LogFile"
  echo "WARNING:%%%%%%%%%%PROGRAM GUIDE DATA IS NOT COMPLETE%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
}

DisplayCompletedMoveMessage(){
  echo "@@@@@@@@@@@@@OPERATION COMPLETE" `date` "@@@@@@@@@@@@@@@@">>"$LogFile"
  echo "MOVED: $InputPath"
  echo "TO: $MoveDir/$ShowFileName.$OriginalExt "
}

DisplayEpiShowMessage(){
  echo "WARNING: EPISODE INFORMATION COULD NOT BE OBTAINED"
  echo "HANDLING AS A GENERAL SHOWING"
  echo "Please consider helping out and adding to thetvdb."
  echo "WARNING:SHOW WAS CONSIDERED AN EPISODE BUT INFORMAITON WAS NOT OBTAINABLE">>"$LogFile"
  echo "%%%%%%%%%%%%Please consider helping out and adding to thetvdb%%%%%%%%%%%%">>"$LogFile"
  echo "HANDLING EPISODE AS GENERAL SHOWING AND DUMPING INTO --doover USER JOB">>"$LogFile"
}

FuzzyLogicDoesNotJiveMessage(){
  echo "%%%%%%%%%%%%%%%%%%%%%%Testing Fuzzy Logic results%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%% GUIDE DATA AND TVDB DATA DO NOT MATCH %%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%% Possible causes: small variations in episode name %%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%% bad guide data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%% bad tvdb airdate %%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%% bad tvdb episode name %%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%% bad tvdb zap2it id %%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo -e "%%%%%AIRDATE MATCH AND FUZZY LOGIC ARE IN DISAGREEMENT%%%%% \n CHECK $LogFile FOR MORE INFORMATION"
  DEBUGMODE=Enabled
}

StandardLogicDoesNotJiveMessage(){
  echo "%%%%%%%%%%%%%%%%%%%%Testing Standard Logic results%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%% GUIDE DATA AND TVDB DATA DO NOT MATCH %%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%% Possible causes: small variations in episode name %%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%% bad guide data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%% bad tvdb airdate %%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%% bad tvdb episode name %%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%% bad tvdb zap2it id %%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo -e "%%%%%AIRDATE MATCH AND FUZZY LOGIC ARE IN DISAGREEMENT%%%%% \n CHECK $LogFile FOR MORE INFORMATION"
  DEBUGMODE=Enabled
}

InvalidFileErrorMessage(){
  echo "INPUT FILE NAME NON EXISTANT -CHECK FILE NAME AND READ PERMISSIONS"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%INPUT FILE NAME NON EXISTANT CHECK FILE NAME AND PERMISSIONS%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%OPERATION FAILED" `date` "%%%%%%%%%%%%%%%%%">>"$LogFile"
}

tvDbIsIncomplete(){
  echo "%%%%%%%%%%www.TheTvDB.com information is incomplete $InputTitle, $InputSubtitle">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%Please consider helping out and adding to thetvdb%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "ERROR: INFORMATION COULD NOT BE OBTAINED"
  echo "ENABLE HANDLING OF UNRECOGNIZED SHOWS TO PROCESS THIS FILE"
  echo "TO PREVENT THIS ERROR IN THE FUTURE ENABLE HANDLING OF UNRECOGNIZED SHOWS">>"$LogFile"
  echo "%%%%%%%%%%%%%%OPERATION FAILED" `date` "%%%%%%%%%%%%%%%%%">>"$LogFile"
  local errtype="myth2kodi Error"
  local errmsg="Could not obtain information from server about: $InputTitle. TheTvDb is incomplete"
  if [ "$Notify" = "Enabled" ] ; then
    sudo -u "$NotifyUserName" /usr/local/bin/librarian-notify-send "$errtype" "$errmsg" web-browser
  fi
}

Wrote0LengthFile(){
  local errtype="myth2kodi Failure"
  local errmsg="$ShowFileName could not be moved to $MoveDir"
  if [ "$Notify" = "Enabled" ] ; then
    sudo -u "$NotifyUserName" /usr/local/bin/librarian-notify-send "$errtype" "$errmsg" stop
  fi
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%WROTE 0 LENGTH FILE%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%OPERATION FAILED" `date` "%%%%%%%%%%%%%%%%%">>"$LogFile"
}

PermissionErrorWhileMoving(){
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%PERMISSION ERROR WHILE MOVING%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%OPERATION FAILED" `date` "%%%%%%%%%%%%%%%%%">>"$LogFile"
  local errtype="myth2kodi Failure"
  local errmsg="$ShowFileName could not be moved to $MoveDir"
  if [ "$Notify" = "Enabled" ] ; then
    sudo -u "$NotifyUserName" /usr/local/bin/librarian-notify-send "$errtype" "$errmsg" stop
  fi
}

SymlinkNotCreated() {
  echo "PERMISSION ERROR OR FILE SYSTEM DOES NOT SUPPORT SYMLINKS:$MoveDir"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%LINK PERMISSION ERROR: SYMLINK NOT CREATED%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%OPERATION FAILED" `date` "%%%%%%%%%%%%%%%%%">>"$LogFile"
  local errtype="myth2kodi Error"
  local errmsg="Failure while creating link. Check permissions"
  if [ "$Notify" = "Enabled" ] ; then
    sudo -u "$NotifyUserName" /usr/local/bin/librarian-notify-send "$errtype" "$errmsg" stop
  fi
}

#####GENERIC UNSPECIFIED ERROR#####
#This function provides an error message on generic errors
genericUnspecifiedError(){
  echo "NO MATCH FOUND.  TROUBLESHOOTING: Check www.TheTvDb TO SEE IF $InputTitle EXISTS. ">>"$LogFile"
  echo "CHECK EPISODE NAME $InputSubtitle. CHECK INTERNET CONNECTION. CHECK API KEY.">>"$LogFile"
  echo "NOT ENOUGH INFORMATION PULLED FROM DATABASE TO IDENTIFY FILE AS MOVIE OR EPISODE">>"$LogFile"
  echo "CHECK www.TheTvDb.com  RUN myth2kodi LINK COMMAND PROMPT.">>"$LogFile"
  echo "FOR MORE INFORMATION SEE http://kodi.wiki/index.php?title=mythicalLibrarian">>"$LogFile" #TODO: If I ever make this public, remember to make a thread.
  echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%">>"$LogFile"
  echo "%%%%%%%%%%%%%%OPERATION FAILED" `date` "%%%%%%%%%%%%%%%%%">>"$LogFile"
}

MaintenanceWarning(){
  local yesorno=""
  echo " --You have entered Maintenance mode."
  echo " myth2kodi will perform maintenance on it's records."
  echo " Please ensure that All network attached storage and removable"
  echo " storage drives are connected and mounted properly before continuing"
  read -n1 -p " Would you like myth2kodi to conduct a scan? y/(n)>" yesorno
  if [ "$yesorno" != "y" ]; then
    echo ""
    echo "You must press 'y' to continue"
    exit 1
  fi
}

determinePrimaryOrAlternateFolderUsage(){
  #Command line, no database Episodes: Determine where File will fit
  FailSafeState=0
  test "$MoveDirWritable" != "1" -a "$m2kProgramIDCheck" = "" && MoveDir="$AlternateMoveDir"
  test "$MoveDirWritable" != "1" -a "$m2kProgramIDCheck" = "" -a "$AlternateMoveDirWritable" != "1" && FailSafeState=1

  #Episode handling: Determine where File will fit
  test "$MoveDirWritable" != "1" -a "$m2kProgramIDCheck" = "EP" && MoveDir="$AlternateMoveDir"
  test "$MoveDirWritable" != "1" -a "$m2kProgramIDCheck" = "EP" -a "$AlternateMoveDirWritable" != "1" && FailSafeState=1

  #Movie handling: Determine where file will fit
  test "$m2kProgramIDCheck" = "MV" -a "$PrimaryMovieDirWritable" != "1" && PrimaryMovieDir="$AlternateMoveDir"
  test "$m2kProgramIDCheck" = "MV" -a "$PrimaryMovieDirWritable" != "1" -a "$AlternateMovieDirWritable" != "1" && FailSafeState=1

  #Show Handling: Determining Where File will fit
  test "$m2kProgramIDCheck" = "SH" -a "$PrimaryShowDirWritable" != "1" && PrimaryShowDir="$AlternateShowDir"
  test "$m2kProgramIDCheck" = "SH" -a "$PrimaryshowDirWritable" != "1" -a "$AlternateShowDirWritable" != "1" && FailSafeState=1
}

#####MAKE FOLDER#####
MakeFolder() {
  #If specified, make $movedir = $movedir/show name
  if [ "$NewShowName" != "" ]; then
    MoveDir="$MoveDir/$NewShowName"
    if [ ! -d "$MoveDir" ]; then
      echo "CREATING FOLDER: $MoveDir">>"$LogFile"
      echo "$MoveDir">>"$m2kdir"/dir.tracking
      mkdir "$MoveDir"
      chmod 775 "$MoveDir"
    fi

    #Make the Season folder if it is applicable and does not exist
    if [ "$SeasonNumber" != "" ]; then
      MoveDir="$MoveDir/Season $SeasonNumber"
      if [ ! -d "$MoveDir" ]; then
        mkdir "$MoveDir"
        chmod 775 "$MoveDir"
        echo "$MoveDir">>"$m2kdir"/dir.tracking
      fi
    fi

  fi
  #Error message if folder was not created
  if [ ! -d "$MoveDir" ]; then
    echo "COULD NOT CREATE $MoveDir/$NewShowName">>"$LogFile"
    echo "##########################################################">>"$LogFile"
    echo "#############FAILSAFE MODE HAS BEEN ACTIVATED#############">>"$LogFile"
    echo "##########################################################">>"$LogFile"
    if [ $Notify = "Enabled" ]; then
      sudo -u "$NotifyUserName" /usr/local/bin/librarian-notify-send "myth2kodi error" "failsafe mode activated."  error
    fi
    SYMLINK=LINK
    MoveDir=$FailSafeDir
    FailSafeState=1
    RequiresDoover=1
  fi
}

#####USE ORIGINAL DIR#####
#If TargetPathIsInputPath is set, then this changes movedir to original dir.
setTargetFolderAsInputPathFolder(){
  #Set originaldir name if none was supplied
  test "$originaldirname" = "./" && originaldirname="$(pwd)"
  test "$originaldirname" = "." && originaldirname="$(pwd)"
  test "$originaldirname" = "" && originaldirname="$(pwd)"
  #For directory names: No trailing / is accepted eg. "~/videos" not "~/videos/"
  #MoveDir is the folder which myth2kodi will move the file.
  MoveDir="$originaldirname/Episodes"
  test ! -d "$MoveDir" && mkdir "$MoveDir"
  #AlternateMoveDir will act as a secondary MoveDir if the primary MoveDir fails.
  AlternateMoveDir="$originaldirname/Episodes"
  test ! -d "$AlternateMoveDir" && mkdir "$AlternateMoveDir"
  #Primary Movie Dir. myth2kodi will attempt to move to this dir first.
  PrimaryMovieDir="$originaldirname/Movies"
  test ! -d "$PrimaryMovieDir" && mkdir "$PrimaryMovieDir"
  #AlternateMovieDir will act as a Secondary move dir if the primary move dir fails.
  AlternateMovieDir="$originaldirname/Movies"
  test ! -d "$AlternateMovieDir" && mkdir "$AlternateMovieDir"
  #PrimaryShowDir is where generic episodes will be placed.
  PrimaryShowDir="$originaldirname/Showings"
  test ! -d "$PrimaryShowDir" && mkdir "$PrimaryShowDir"
  #AlternateShowDir will act as a Secondary Show Dir if the primary show dir fails.
  AlternateShowDir="$originaldirname/Showings"
  test ! -d "$AlternateShowDir" && mkdir "$AlternateShowDir"
}

#####GENERATE tvshow.nfo#####
#Generates folder tvshow.nfo file
GenerateTVShowNFO(){
  test -f "$MoveDir/tvshow.nfo" && rm -f "$MoveDir/tvshow.nfo"
  echo -e "<tvshow>">>"$MoveDir"/tvshow.nfo
  echo -e "\t<title>$NewShowName</title>">>"$MoveDir/tvshow.nfo"
  if [ "$SeriesID" != "" ] ; then
    echo -e "\t<episodeguide>http://www.thetvdb.com/api/$APIkey/series/$SeriesID/all/$Language.xml</episodeguide>">>"$MoveDir/tvshow.nfo"
  else
    echo -e "\t<episodeguide></episodeguide>">>"$MoveDir/$ShowFileName.nfo"
  fi
  echo -e "</tvshow>">>"$MoveDir/tvshow.nfo"
  return 0
}

#####GENERATE NFO FILE#####
#Create an NFO file based upon extracted information
GenerateEpisodeNFO(){
  test -f "$MoveDir/$ShowFileName.nfo" && rm -f "$MoveDir/$ShowFileName.nfo"
  echo -e "<episodedetails>">>"$MoveDir/$ShowFileName.nfo"
  #SAK-REPLACED BELOW, SEE http://forum.kodi.tv/showthread.php?tid=65644&page=65&highlight=json
  #echo -e "<tvshow>">>"$MoveDir/$ShowFileName.nfo"
  echo -e "<episodedetails>">>"$MoveDir/$ShowFileName.nfo"

  if [ "$NamingConvention" = "" ] ; then
    if [ "$GoForDoover" = "1" ]; then
      echo -e "\t<title>$EpisodeSubtitle Recorded $datehour -Episode in --doover Que</title>">>"$MoveDir/$ShowFileName.nfo"
    else
      echo -e "\t<title>$EpisodeSubtitle Recorded $datehour -Showing</title>">>"$MoveDir/$ShowFileName.nfo"
    fi
  else
    echo -e "\t<title>$EpisodeSubtitle Recorded $datehour -Categoric</title>">>"$MoveDir/$ShowFileName.nfo"
  fi

  echo -e "\t\t<rating>$rating</rating>">>"$MoveDir/$ShowFileName.nfo"
  echo -e "\t<Plot>$Plot</Plot>">>"$MoveDir/$ShowFileName.nfo"
  echo -e "\t<genre>$ShowCategory</genre>">>"$MoveDir/$ShowFileName.nfo"
  if [ "$HasSxxExx" = "1" ] ; then
    echo -e "\t<season>$Sxx</season>" >>"$MoveDir/$ShowFileName.nfo"
    echo -e "\t<episode>$Exx</episode>">>"$MoveDir/$ShowFileName.nfo"
  else 
    echo -e "\t<season>0</season>">>"$MoveDir/$ShowFileName.nfo"
    echo -e "\t<episode>0</episode>">>"$MoveDir/$ShowFileName.nfo"
  fi
  #SAK-REPLACED BELOW, SEE http://forum.kodi.tv/showthread.php?tid=65644&page=65&highlight=json
  #echo -e "</tvshow>">>"$MoveDir/$ShowFileName.nfo"
  echo -e "</episodedetails>">>"$MoveDir/$ShowFileName.nfo"
  echo "'$MoveDir/$ShowFileName.nfo'" "'$MoveDir/$ShowFileName.$OriginalExt'">>"$m2kdir"/created.tracking
  return 0
}

##### IGNORE LIST #####
ignoreList(){
  local ignoreTest=""
  #Test if the title is in the titleIgnore file
  if [ -f "$m2kdir/titleIgnore" ]; then
    ignoreTest=`grep "$InputTitle" "$m2kdir/titleIgnore"`
    if [ "$InputTitle" = "$ignoreTest" ]; then
      JobType=titleIgnore
      runJob
    fi
  fi
  #Test if the Category is in the categoricIgnore file
  if [ -f "$m2kdir/categoricIgnore" ]; then
    ignoreTest=`grep "$ShowCategory" "$m2kdir/categoricIgnore"`
    if [ "$ShowCategory" = "$ignoreTest" ]; then
      JobType=categoricIgnore
      runJob
    fi
  fi
  return 0
}

#####SHOW TRANSLATIONS HANDLING#####
#Get show translations if the $m2kdir/showTranslations file exists.
#The show title will be replaced by the one in the user created showTranslations file
ShowTranslations(){
  if [ -f "$m2kdir"/showTranslations ] && [ "$ShowName" != "" ]; then
    showtranslation=`grep "$ShowName = " "$m2kdir/showTranslations" | sed s/"$ShowName = "/""/g `
    if [ "$showtranslation" != "" ]; then
      ShowName=$showtranslation
      echo "USER TRANSLATION: $InputTitle = $ShowName">>"$LogFile"
    elif [ "$showtranslation" = "" ]; then
      showtranslation="Inactive"
    fi
  fi
  return 0
}

#####MAINTENANCE ROUTINE#####
#TODO: Need to go through this function line-by-line and make sure it behaves as expected in a do-no-harm sort of way...
#DoMaintenance loops through all logged files and checks if their parent is there.  If no parent, then file is deleted.
DoMaintenance() {
  echo "PERFORMING MAINTENANCE ROUTINE..."
  #check for interrupted undo jobs
  test -f "$m2kdir/undo.lock" && test ! -f "$m2kdir/undo.sh" && mv "$m2kdir/undo.lock" "$m2kdir/undo.sh"

  #Check and make doover.sh and undo.sh if it does not exist
  test ! -f "$m2kdir/doover.sh" && echo 'rm -f "'$m2kdir'"/doover.sh'>"$m2kdir/doover.sh" && chmod 666 "$m2kdir/doover.sh"
  test ! -f "$m2kdir/undo.sh" && echo 'rm -f "'$m2kdir'"/undo.sh'>"$m2kdir/undo.sh" && chmod 666 "$m2kdir/undo.sh"

  if [ "$CommercialMarkupCleanup" = "Enabled" ] && [ -f "$m2kdir/created.tracking" ]; then
    myth2kodiCounter=0
    echo "PERFORMING MAINTENANCE ROUTINE">>"$LogFile"
    local SupportFile=""
    while read line ; do
      (( ++myth2kodiCounter ))
      echo -ne "File record $myth2kodiCounter: ${SupportFile:0:20}     \n" 1>&2
      SupportFile=`echo $line|cut -d"'" -f2`
      MainFile=`echo $line|cut -d"'" -f4`
      ls "$MainFile" > /dev/null 2>&1
      if [ "$?" != "0" ]; then
        if [ -d "`dirname "$SupportFile"`" ]; then
          echo "REMOVING ORPHAN $SupportFile"
          echo "REMOVING ORPHAN $SupportFile">>"$LogFile"
          rm -f "$SupportFile"
        else
          echo "FOLDER DISCONNECTED:$SupportFile"
          echo "FOLDER DISCONNECTED:$SupportFile">>"$LogFile"
          test "$removedead" != "1" && echo "$line" >> "$m2kdir/created.tracking2" || echo "REMOVING FROM FUTURE SEARCHES: $line "
        fi
      else
        echo "$line" >> "$m2kdir/created.tracking2"
      fi
    done <"$m2kdir/created.tracking"
    test -f "$m2kdir/created.tracking" && rm -f "$m2kdir/created.tracking"
    test -f "$m2kdir/created.tracking2" && mv "$m2kdir/created.tracking2" "$m2kdir/created.tracking"
  fi

  #Check if folders are empty and remove dir if needed and it was created by myth2kodi
  if [ "$DirTracking" = "Enabled" ] && [ -f "$m2kdir/dir.tracking" ]; then
    while read line ; do
      (( ++myth2kodiCounter ))
      echo -ne "Folder record $myth2kodiCounter: ${DirToCheckCheck:0:20}    \n" 1>&2
      DirToCheck=$line
      if [ -d "$DirToCheck" ]; then
        DirToCheckCheck=`ls "$line"|  sed s/"tvshow.nfo"/""/g |grep -m1 ^`
        test "$DirToCheckCheck" = "" && DirToCheckCheck=`ls "$line" | sed s/"tvshow.nfo"/""/g | grep -m2 ^`
        if [ "$DirToCheckCheck" = "" ]; then
          echo "REMOVING ORPHAN FOLDER:$line">>"$LogFile"
          echo "REMOVING ORPHAN FOLDER:$line"
          test -f "$line/tvshow.nfo" && rm -f "$line/tvshow.nfo"
          rmdir "$line"
        elif [ "$DirToCheckCheck" != "" ]; then
          echo "$DirToCheck" >> "$m2kdir/dir.tracking2"
        fi
      elif [ ! -d "$DirToCheck" ]; then
        echo $DirToCheck >> "$m2kdir/dir.tracking2"
      fi
    done < "$m2kdir"/dir.tracking
    rm -f "$m2kdir/dir.tracking"
    test -f "$m2kdir/dir.tracking2" && mv "$m2kdir/dir.tracking2" "$m2kdir/dir.tracking"
  fi

  #cleanse myth2kodi database folders if in --doMaintenance mode
  if [ "$removedead" = "1" ]; then
    test -f "$m2kdir/cleanup" && rm -f "$m2kdir/cleanup"
    ls -A -1 "$m2kdir" > "$m2kdir/cleanup"

    while read line ; do
      (( ++myth2kodiCounter ))
      echo -ne "Clensing Database:$myth2kodiCounter ${folderToCheck:0:20}    \n" 1>&2
      folderToCheck="$m2kdir/$line"
      if [ -d "$folderToCheck" ]; then
        if [ "$folderToCheck" != "$m2kdir/Daily Report" ]; then
          if [ "$folderToCheck" != "$m2kdir/mythicalSetup" ]; then
            echo "Removing myth2kodi database from:$folderToCheck"
            rm -Rf "$folderToCheck"
          fi
        fi
      fi
    done < "$m2kdir/cleanup"
    rm -f "$m2kdir/cleanup"
  fi
  test ! -d "$m2kdir/mythicalSetup" && mkdir "$m2kdir/mythicalSetup"
}

#####SCAN MODE#####
#TODO: Need to go through this function line-by-line and make sure it can be run without causing damage.
#This function will scan a folder and process the entire library
mythicalScan(){
  local yesorno=""
  DoMythTVPermissionsCheck
  checkext=$InputTitle
  if [ "$UID" = "0" -o "$USER" = "root" ]; then
    #SAK: my fault
    echo "myth2kodi has detected that you are (or were previously)"
    echo "running as a privileged user.  This may lead to permission"
    echo "contamination of normally unprivileged files."
    echo "Do not run this command with sudo."
    read -p "Exit? yes/(no)" exitvalue
    test "$exitvalue" = "y" && exit 1
    test "$exitvalue" = "Y" && exit 1
    test "$exitvalue" = "yes" && exit 1
  fi

  if [ "$checkext" = "" ]; then
    echo "Cannot process blank file extensions"
    echo 'usage: myth2kodi --scan "ext" "/path/to/folder"'
    echo 'usage: myth2kodi --scan "mpg" "/home/mythtv/videos"'
    exit 1
  elif [ "${checkext:0:2}" = "./" ]; then
    echo "please specify the full path to the file"
    echo 'usage: myth2kodi --scan "ext" "/path/to/folder"'
    echo 'usage: myth2kodi --scan "mpg" "/home/mythtv/videos"'
    exit 1
  elif [ ! -d $InputSubtitle ]; then
    echo "This folder does not exist.  "
    echo 'usage: myth2kodi --scan "ext" "/path/to/folder"'
    echo 'usage: myth2kodi --scan "mpg" "/home/mythtv/videos"'
    exit 1
  fi
  local scanpath=$InputSubtitle
  if [ "$scanpath" = "" ]; then
    echo "please supply a path"
    echo 'usage: myth2kodi --scan "ext" "/path/to/folder"'
    echo 'usage: myth2kodi --scan "mpg" "/home/mythtv/videos"'
    exit 1
  fi

  echo "--You have entered scan Mode."
  echo " myth2kodi will conduct a scan of the folder:"
  echo " $scanpath"
  echo " searching for file types:$checkext. Each file will be"
  echo " processed through myth2kodi. This mode will"
  echo " only work when database access is functional."
  echo " please scan a single file to test capabilities before"
  echo " running the scan mode of operation using the following"
  echo " eg. myth2kodi /path/to/file.ext"
  echo " myth2kodi will first run the doovers to prevent"
  echo " clobbering and creation of unnecessary links."
  echo " This operation can be reversed using the following command:"
  echo " sudo myth2kodi --undo"
  echo " Data loss can occur if this operation is interrupted."
  read -n1 -p " Would you like myth2kodi to conduct a scan? (y)/n>" yesorno
  echo ""
  test "$yesorno" = "" && yesorno="y"
  if [ "$yesorno" = "y" ]; then
    myth2kodi --doover
    ls -1 $scanpath/*.$checkext>"$m2kdir/scan.temp"
    echo $scanpath $checkext
    while read line ; do
      if [ "$InputOption" = "--BypassPermissionsCheck" ]; then
        test ! -L "$line" && test ! -S "$line" && test ! -d "$line" && myth2kodi "$line" "--BypassPermissionsCheck"
      else
        test ! -L "$line" && test ! -S "$line" && test ! -d "$line" && myth2kodi "$line"
      fi
    done<"$m2kdir/scan.temp"
    rm -f "$m2kdir/scan.temp"
    exit 0
  else
    echo "you must press 'y' to scan"
    exit 0
  fi
  exit 1
}

setGroupPermissions (){
  #Add read and write permissions for the group to the moved recording.
  chmod g=rw "$MoveDir/$ShowFileName.$OriginalExt"
  #TODO:#NOTE: the above command is slightly inconsistent with the comment as = also implies removal of any unmentioned attributes.
}

#####MYTHICAL DIAGNOSTICS#####
#TODO: Need to go through this function line-by-line and make sure it's still a sensible Diagnostics function.
#TODO: Should use | tee -a "$m2kdir"/diagnostics.log to write diagnostics info to a file
#This function provides a functions check on myth2kodi
mythicalDiagnostics(){
  local checka=""
  local checkb=""
  local checkc=""
  local checkd=""
  local checke=""
  local checkf=""
  local packagecheck=""
  local DBTest=""
  local =""
  echo "--You have entered diagnostic mode"
  echo "myth2kodi will now conduct a series of tests."
  read -n1 -p "press any key to verify installed packages..."
  echo ""
  test `which curl`>/dev/null && echo "package 'curl' is installed" || checkc="curl "
  test `which agrep`>/dev/null && echo "package 'agrep' or 'tre-agrep' is installed" || checkd="agrep "
  test `which notify-send`>/dev/null && echo "package 'libnotify-bin' is installed"  || checke="libnotify-bin "

  if [ `which agrep`>/dev/null ] && [ `which curl`>/dev/null ]  ; then
    packagecheck="***PASSED***"
    echo "Installed packages check ***PASSED***"
  else
    packagecheck="***FAILED***"
    echo "Installed packages check ***FAILED***"
    #TODO: checkf isn't set anywhere in this script... and checkb isn't set until 50-60 lines below here.
    echo "Missing packages are $checkb$checkc$checkd$checke$checkf"
    if [ "$mythicalPlatform" != "Darwin" ] ; then
      echo "Please run 'apt-get install $checkb$checkc$checkd$checke$checkf' or equivalant"
    else
      echo "Please obtain MacPorts and install $checkb$checkc$checkd$checke"
      test $checkf != "" && echo "Python Bindings are missing, please install Python"
  fi
  if [ "$mythicalPlatform" != "Darwin" ]; then
    read -n1 -p "Press any key to perform Desktop Message test..."
    echo ""
    echo "Performing librarian-notify-send test"
    echo "This test verifies that the message was sent to the DBUS."
    echo "This test does not verify the user has a valid desktop open."
    sudo -u "$NotifyUserName" /usr/local/bin/librarian-notify-send "myth2kodi test" "Testing Desktop Communications" "info"
    test "$?" = "0" && notifytest="***PASSED***" || notifytest="***FAILED***"
    echo "Desktop Notifications test $notifytest"
  else
    notifytest="   N/A"
  fi

  if [ "$DatabaseType" = "MythTVPythonBindings" ]; then
    read -n1 -p "Press any key to perform MythTV Database test..."
    echo ""
    echo "Performing MythTV Python Bindings database test"
    #Assuming Python of 2.6+ is fine just not Python 3.*
    if which python ; then
      echo "Python: `which python`"
      python_version=$(python --version 2>&1)  #Python returns version info to stderr
      echo "Version: $python_version"
      pyver=`echo $python_version | sed s/"python\s*"//I | cut -f1-2 -d"." | tr -d '.'`
      if [ $pyver -ge 26 -a $pyver -lt 30 ] ; then
        echo "WARNING: Python older than 2.6 and Python 3 aren't supported."
      fi
    else
      echo "MISSING package python, or path incorrectly set."
    fi

    PythonBindingsCheck="FAILED"
    /usr/local/bin/MythDataGrabber --Diagnostic=True
    test $? = "0" && PythonBindingsCheck="OK"
    if [ "$PythonBindingsCheck" = "OK" ]; then
      echo "MythTV Python Bindings are installed properly"
    else
      python -c 'from MythTV import MythDB';
      if [ $? != "0" ] ; then
        echo "MythTV PythonBindings are not installed properly"
        echo "    Debian Users:  apt-get install libmyth-python python-lxml "
        Python1=1
      fi
      if [ Python1 != 1 ]; then
        /usr/local/bin/MythDataGrabber --Diagnostic=True;
        test $? != 0 && echo "there was a problem connecting to the database, check MythDatabase package" && Python2=1
      fi
    fi
    test "$PythonBindingsCheck" = "OK" && DBTest="***PASSED***"
    if [ "$PythonBindingsCheck" != "OK" ] ; then
      DBTest="***FAILED***"
      packagecheck="***FAILED***"
      checka=" libmyth-python"
      checkb=" python-lxml "
    fi
    echo "MythTV Database Test $DBTest"
  fi

  read -n1 -p "Press any key to perform KODI Notification test..."
  echo ""
  echo "Performing KODI Notifications test"
  for KODIIP in ${KODIIPs[@]} ; do
    echo "SENDING REQUESTED COMMANDS TO:$KODIIP"
    #SAK: REPLACED BELOW, SEE http://forum.kodi.tv/showthread.php?tid=65644&page=65&highlight=json
    local curlPOST='curl -L -s -m3 --connect-timeout 5 -X POST -H "Content-Type: application/json" -d'
    local data=\''{"jsonrpc":"2.0",
                   "method":"GUI.ShowNotification",
                   "params":{"title":"mythical Librarian Test","message":"'$PythonBindingsCheck'"},
                   "id":1}'\'
    local KODIcomm=$($curlPOST $data http://$KODIIP/jsonrpc | tr -d "</html>i^")
    test "$KODIcomm" != "" && echo "TESTING:$KODIcomm" || echo "COMMUNICATIONS NOT ESTABLISHED: $KODIIP"
  done
  #SAK: REPLACED BELOW, SEE http://forum.kodi.tv/showthread.php?tid=65644&page=65&highlight=json
  test "`echo $KODIcomm`" = "{d:1,jsonrpc:2.0,resu:OK}" && KODIcomm="***PASSED***" || KODIcomm="***FAILED***"
  echo "KODI Communications $KODIcomm"
  read -n1 -p "Press any key to test file system permissions..."
  echo ""
  echo "Testing file system permissions"

  if [ "$TargetPathIsInputPath" = "Enabled" ]; then
    echo "TargetPathIsInputPath is selected. Testing with current folder"
    setTargetFolderAsInputPathFolder
  fi

  MoveFileSize="10000"
  MoveFileSize=$((MoveFileSize/1024))
  MoveDirFreeSpace=`df -P "$MoveDir"|sed -n 2p|awk '{print $4}'` || MoveDirFreeSpace=0
  AlternateMoveDirFreeSpace=`df -P "$AlternateMoveDir"|sed -n 2p|awk '{print $4}'`|| AlternateMoveDirFreeSpace=0
  if [ "$Database" = "Enabled" ]; then
    PrimaryMovieDirFreeSpace=`df -P "$PrimaryMovieDir"|sed -n 2p|awk '{print $4}'` || PrimaryMovieDirFreeSpace=0
    AlternateMovieDirFreeSpace=`df -P "$AlternateMovieDir"|sed -n 2p|awk '{print $4}'`|| AlternateMovieDirFreeSpace=0
    PrimaryShowDirFreeSpace=`df -P "$PrimaryShowDir"|sed -n 2p|awk '{print $4}'`|| PrimaryShowDirFreeSpace=0
    AlternateShowDirFreeSpace=`df -P "$AlternateShowDir"|sed -n 2p|awk '{print $4}'`|| AlternateShowDirFreeSpace=0
  fi
  #Call permissions check from function.  Write small file, delete, get results
  checkPermissions "$MoveFileSize" "$MoveDirFreeSpace" "$MoveDir"
  MoveDirWritable=$TMoveDirWritable
  checkPermissions "$MoveFileSize" "$AlternateMoveDirFreeSpace" "$AlternateMoveDir"
  AlternateMoveDirWritable=$TMoveDirWritable
  if [ "$Database" = "Enabled" ]; then
    checkPermissions "$MoveFileSize" "$PrimaryMovieDirFreeSpace" "$PrimaryMovieDir"
    PrimaryMovieDirWritable=$TMoveDirWritable
    checkPermissions "$MoveFileSize" "$AlternateMovieDirFreeSpace" "$AlternateMovieDir"
    AlternateMovieDirWritable=$TMoveDirWritable
    checkPermissions "$MoveFileSize" "$PrimaryShowDirFreeSpace" "$PrimaryShowDir"
    PrimaryShowDirWritable=$TMoveDirWritable
    checkPermissions "$MoveFileSize" "$AlternateShowDirFreeSpace" "$AlternateShowDir"
    AlternateShowDirWritable=$TMoveDirWritable
  fi
  OriginaldirFreeSpace=`df -P "$originaldirname"|sed -n 2p|awk '{print $4}'`
  WorkingDirFreeSpace=`df -P "$m2kdir"|sed -n 2p|awk '{print $4}'`
  checkPermissions "1" "$OriginaldirFreeSpace" "$originaldirname"
  OriginalDirWritable=$TMoveDirWritable
  checkPermissions "5000" "$WorkingDirFreeSpace" "$m2kdir"
  WorkingDirWritable=$TMoveDirWritable
  checkPermissions "5000" "$WorkingDirFreeSpace" "$m2kdir"
  WorkingDirWritable=$TMoveDirWritable

  echo "USER SETTING     |FLAG                       |Folder name"
  echo "MoveDir          |$MoveDirWritable           |$MoveDir "
  echo "AlternateMoveDir |$AlternateMoveDirWritable  |$AlternateMoveDir"
  echo "PrimaryMovieDir  |$PrimaryMovieDirWritable   |$PrimaryMovieDir"
  echo "AlternateMovieDir|$AlternateMovieDirWritable |$AlternateMovieDir"
  echo "PrimaryShowDir   |$PrimaryShowDirWritable    |$PrimaryShowDir"
  echo "AlternateShowDir |$AlternateShowDirWritable  |$AlternateShowDir"
  echo "m2kdir           |$WorkingDirWritable        |$m2kdir"
  if [ "$MoveDirWritable" = "1" ] && [ "$AlternateMoveDirWritable" = "1" ] && [ "$WorkingDirWritable" = "1" ] ; then
    folderchecks="***PASSED***"
  else
    folderchecks="***FAILED***"
  fi
  echo "Critical Filesystem checks $folderchecks"
  if [ "$packagecheck" = "***PASSED***" ] && [ "$folderchecks" = "***PASSED***" ] ; then
    overallchecks="***PASSED***"
  else
    overallchecks="***FAILURE***"
  fi
  if [ "$overallchecks" = "***PASSED***" ]; then
    read -n1 -p "press any key to test myth2kodi..."
    echo ""
    echo " Recordings Database is not used for testing."
    echo " Performing fuzzy logic lookup on database file.  Please wait."
    echo " It may take a moment to build mythical librarian database files "
    echo " executing myth2kodi testfile.ext 'mister rogers' 'show 1332'"
    echo " testing for exit status 0"

    myth2kodi testfile.ext "mister rogers" "show 1332"
    exitstatus=$?
    echo "exited with status $exitstatus"
    if [ "$exitstatus" = "0" ]; then
      mythicaltest="***PASSED***"
    else
      echo "OVERALL FAILURE"
      mythicaltest="COULD NOT COMPLETE"
      overallchecks="***FAILURE***"
    fi
  else
    echo "OVERALL FAILURE"
    mythicaltest="COULD NOT COMPLETE"
  fi
  read -n1 -p "press any key to continue on to the final results..."
  echo ""
  echo -e "  All tests complete        RESULTS"
  test "$DatabaseType"="MythTVPythonBindings" && echo -e "  MythTV Database Test:     $DBTest"
  echo -e "  Installed Packages:       $packagecheck $checka$checkb$checkc$checkd$checke"
  echo -e "  Notifications Test:       $notifytest"
  echo -e "  KODI Communications:      $KODIcomm"
  echo -e "  File System Checks:       $folderchecks"
  echo -e "  mythicalTesting:          $mythicaltest"
  echo -e "  Overall mythicalReadiness:$overallchecks"
  echo -e "-----End of diagnostics-----"

  #Logging for failure messages
  if [ "$DBTest" = "***FAILED***" ]; then
    echo -e " When interfacing MythTV/0.24, myth2kodi uses MythTV's Python"
    echo -e " Bindings.  These must be configured and working for proper access"
    echo -e " to data required by myth2kodi.   "
    test "$Python1" = "1" && echo -e " Missing packages:  apt-get install libmyth-python"
    test "$Python2" = "1" && echo -e " Could not connect to the database.  Specify a username and password"
  #TODO add more information on how to install
  fi

  if [ "$notifytest" = "***FAILED***" ]; then
    echo -e " Notifications to the DBUS have failed. myth2kodi relies upon"
    echo -e " librarian-notify-send and package lib-notify to display messages on"
    echo -e " GNOME desktop interface. These messages will not be displayed. "
  fi
  if [ "$KODIcomm" != "***PASSED***" ]; then
    echo -e " KODI Communications have failed.  Likely causes: Improper IP address,"
    echo -e " or KODI is not equipped to handle external network commands in settings."
    echo -e " myth2kodi will not send messages or library update requests."
  fi
  if [ "$folderchecks" != "***PASSED***" ]; then
    echo -e " The filesystem checks failed.  Likely causes: "
    echo -e " The user named $SUDO_USER does not have permission to use the folder"
    echo -e "  corrective action: sudo chown $SUDO_USER /Name/of/My_failed_folder"
    echo -e " The folder belongs to a different group then the user named $SUDO_USER"
    if [ "$Database" = "Enabled" ] && [ "$DatabaseType" = "MythTV" ] && [ "$SUDO_USER" != "mythtv" ]; then
      echo -e "  corrective action: sudo adduser mythtv $SUDO_USER"
      echo -e "        sudo adduser $SUDO_USER mythtv"
    else
      echo -e "  corrective action: sudo adduser RecordingManagerUser $SUDO_USER"
      echo -e "        sudo adduser $SUDO_USER RecordingManagerUser"
    fi
    echo -e " The folder does not exist"
    echo -e "  corrective action: mkdir /Name/of/My_failed_folder"
  fi
  if [ "$mythicaltest" != "***PASSED***" ]; then
    echo -e " myth2kodi has encountered an error.  This may be due to "
    echo -e " lack of network connection.   If the problem persists, contact"
    echo -e " outleradam here: http://forum.kodi.tv/showthread.php?tid=65644"
  fi
  if [ "$overallchecks" != "***PASSED***" ]; then
    echo -e " "
    echo -e " These issues must be corrected in order for myth2kodi to"
    echo -e " perform correctly"
  fi

  test "$overallchecks" = "***FAILURE***" && exit 1

  exit 0
}

#####DOOVER PROCESSING#####
#This function provides an easy way to redo failed jobs.
executeDoOver(){
  local yesorno=""
  local RunSudo=0
  if [ "$(id -u)" = "0" ]; then
    #TODO: So, if id of user is 0, and thus root, test $SUDO_USER is set as
    #  "root" and if it is assign whoami (which for uid=0 will return root) to
    #  the variable  SUDO_USER... Something is wrong here.
    test "$SUDO_USER" = "root" && SUDO_USER=`whoami`
    RunSudo=1
  fi
  test "$SUDO_USER" = "" && SUDO_USER=`whoami`
  echo "--You have entered doover mode."
  echo " In this mode of operation, myth2kodi will rerun"
  echo " mythicalLibrarain against all files which failed on the"
  echo " last run of myth2kodi.  It is important that this"
  echo " process does not get interrupted or data loss may occur."
  test "$DoOverBypass" != "1" && read -n1 -p "  Press 'y' to continue or 'n' to exit..... y/(n):>" yesorno
  test "$DoOverBypass" = "1" && yesorno="y"

  if [ "$yesorno" = "y" ] && [ -f "$m2kdir/doover.sh" ]; then
    #TODO: Maybe doover.sh.run_YYYY-MM-DD would be better, see $Today
    #preserve permissions
    chmod +x "$m2kdir/doover.sh"
    #NOTE: The first command in doover.sh is to delete the file doover.sh.
    if [ "$RunSudo" = "1" ] ; then
      sudo -u $SUDO_USER cat "$m2kdir/doover.sh" >> "$m2kdir/doover.sh.old"
      sudo -u $SUDO_USER "$m2kdir/doover.sh"
    else
      cat "$m2kdir/doover.sh" >> "$m2kdir/doover.sh.old"
      "$m2kdir/doover.sh"
    fi
    echo "done."
    exit 0
  else
    test -f "$m2kdir/doover.sh" && echo "You must press y to execute Doover." || echo "No Doover jobs exist."
    exit 0
  fi
  exit 1
}

#####UNDO JOBS#####
#This function provides an easy way to undo all myth2kodi jobs
executeUndo(){
  if [ "$(id -u)" != "0" ]; then
    echo "You do not have sufficient privileges to run this script."
    echo "--undo must be executed with the sudo command"
    echo "eg. 'sudo myth2kodi --undo'"
    exit 1
  fi
  test "$SUDO_USER" = "" && SUDO_USER=`whoami`
  echo "--You have entered undo mode."
  echo " In this mode of operation, myth2kodi will reverse"
  echo " file changes created by the current user while running."
  echo " myth2kodi. There will be no indicators while undo"
  echo " is running. It is important that this process is not "
  echo " interrupted or data loss may occur"
  read -n1 -p "  Press 'y' to continue or 'n' to exit..... y/(n):>" yesorno
  echo ""
  if [ "$yesorno" = "y" ]; then
    cp "$m2kdir/undo.sh" "$m2kdir/undo.lock"
    test -f "$m2kdir/undo.sh" && cat "$m2kdir/undo.sh">>"$m2kdir/undo.sh.old"
    test -f "$m2kdir/undo.sh" && chmod +x "$m2kdir/undo.sh"
    test -f "$m2kdir/undo.sh" && sudo -u $SUDO_USER cat "$m2kdir/undo.sh" >> "$m2kdir/undo.sh.old"
    test -f "$m2kdir/undo.sh" && sudo -u $SUDO_USER "$m2kdir/undo.sh"
    #TODO: Change doover.sh.old to doover.sh.old_YYYY-MM-DD would be better, see $Today
    test -f "$m2kdir/doover.sh" && cat "$m2kdir/doover.sh" >> "$m2kdir/doover.sh.old"
    test -f "$m2kdir/doover.sh" && rm -f "$m2kdir/doover.sh"
    removedead=1
    test -f "$m2kdir/created.tracking" && cat "$m2kdir/created.tracking">>"$m2kdir/created.tracking.old"
    test -f "$m2kdir/created.tracking" && rm -f "$m2kdir/created.tracking"
    rm -f "$m2kdir/undo.lock"
    sudo -u $SUDO_USER myth2kodi --doMaintenance
    echo "done."
    exit 0
  else
    echo "You must press y to execute undo"
    exit 0
  fi
  exit 1
}

#####HELP#####
#This function provides a helpful message.
mythicalHelp(){
  if [ "$InputPath" = "%DIR%/%FILE%" ]; then
    UserJobOutsideMythTV
    jobType="GenericUnspecifiedError"
    runJob
  fi
  echo " myth2kodi --:invalid pattern"
  echo ""
  echo "usage: myth2kodi 'path/to/file' ['title'] ['subtitle']"
  echo "usage: myth2kodi --mode [parameter] [parameter]"
  echo " items in brackets are [context sensitive]"

  if [ "$switchhelp" = "1" ]; then
    echo ""
    echo "Author: Adam Outler outleradam(at)hotmail.com"
    echo ""
    echo "-m|--mythicalDiagnostics"
    echo "  diagnostics: tests functions of myth2kodi"
    echo "  eg. myth2kodi --mythicalDiagnostics"
    echo ""
    echo "-s|--scan filetype /path/to/folder"
    echo "  scan: creates a library from an entire folder"
    echo "  eg. myth2kodi --scan mpg /home/mythtv/videos"
    echo ""
    echo "-doMaintenance"
    echo "  doMaintenance: removes FOLDER DISCONNECTED errors from logs"
    echo "  eg. myth2kodi --doMaintenance"
    echo ""
    echo "-u|--update"
    echo "  update: myth2kodi to the current version"
    echo "  eg. sudo myth2kodi --update"
    echo ""
    echo "-d|--doover"
    echo "  doover: reruns previously failed jobs sequentially"
    echo "  eg. sudo myth2kodi --doover"
    echo ""
    echo "--unmanned_doover"
    echo "  unmanned_doover: Same as --doover but for use without human intervention"
    echo "  eg. sudo myth2kodi --unmanned_doover"
    echo ""
    echo "-u|--undo"
    echo "  undo: returns all files to original states"
    echo "  eg. sudo myth2kodi --undo"
    echo ""
    echo "-?|-h|--help"
    echo "  Help: displays this message"
    echo "  example: myth2kodi --help"
    echo ""
    echo "--special"
    echo "  Special Help: displays extended configuration help."
    echo "  example: myth2kodi --special"
    echo ""
    echo " --confidence"
    echo "  Confidence Help: Displays information on improving confidence"
    echo "  example: myth2kodi --confidence"
    echo "======================================================="
  fi
  echo " ensure you have set the user settings set properly and run"
  echo " --mythicalDiagnostics before using myth2kodi"
  echo " in --scan mode or as a UserJob."
  echo " For more information type: myth2kodi --help or --special"
  echo " done."
  exit 1
}

special (){
  echo " ======showTranslations====="
  echo " If you are having problems with incorrect guide data such"
  echo " as improper titling, use showTranslations."
  echo " ShowTranslations can be applied by creating a file called:"
  echo " $m2kdir/showTranslations"
  echo " ##############################################################"
  echo " #My Guide Show Title = www.TheTvDb.com Show Title            #"
  echo " #Battlestar Gallactica = Battlestar Gallactica (2003)        #"
  echo " #The Office = The Office (US)                                #"
  echo " #Millionaire = Who Wants To Be A Millionaire                 #"
  echo " #Aqua teen Hungerforce = Aqua Teen Hunger Force              #"
  echo " ##############################################################"
  echo ""
  echo "======titleIgnore======"
  echo " If wish to ignore all shows with a specific title, use titleIgnore"
  echo " titleIgnore can be applied by creating a file called:"
  echo " $m2kdir/titleIgnore"
  echo " ##############################################################"
  echo " #Show to ignore                                              #"
  echo " #Battlestar Gallactica                                       #"
  echo " #The Office                                                  #"
  echo " #Millionaire                                                 #"
  echo " #Aqua teen Hungerforce                                       #"
  echo " ##############################################################"
  echo ""
  echo "======categoricIgnore======"
  echo " If you wish to ignore all shows with a specific category, use"
  echo " categoricIgnore"
  echo " categoricIgnore can be applied by creating a file called:"
  echo " $m2kdir/categoricIgnore"
  echo " ##############################################################"
  echo " #Category to ignore                                          #"
  echo " #Sports                                                      #"
  echo " #Sports Talk                                                 #"
  echo " #College Sports                                              #"
  echo " #Comedy                                                      #"
  echo " ##############################################################"
  echo ""
  echo "======globalSettings====="
  echo " If you wish to override any settings in mythicalSetup, use"
  echo " globalSettings.  globalSettings allows you to take any setting"
  echo " from the top of the myth2kodi file and make it permanent."
  echo " mythicalSetup will not change this file.  Your settings will"
  echo " remain static after upgrades."
  echo ""
  echo " globalSettings can be applied by creating a file called:"
  echo " /etc/myth2kodi/globalSettings"
  echo " ##############################################################"
  echo " #SYMLINK=Disabled                                            #"
  echo " #AlternateMoveDir=/media/usbDrive                            #"
  echo " #NotifyUserName=adam                                         #"
  echo " #KODIIPs=( user:password@192.168.1.110:8080 )                #"
  echo " #Database=Disabled                                           #"
  echo " ##############################################################"
  echo "Done."
}

improveConfidence(){
  echo -e "About Confidence ratings:"
  echo -e ""
  echo -e " Confidence Ratings are used by myth2kodi."
  echo -e " These ratings serve as a guide to the probability of a"
  echo -e " perfect match. Ratings range from +4 to -6.  Any rating"
  echo -e " at or above 0 should be considered a good match."
  echo -e ""
  echo -e "How can I improve my Confidence Rating?"
  echo -e " 1. myth2kodi --special provides information on how"
  echo -e "    to improve Episode matching confidence by using a "
  echo -e "    showTranslations file to compensate for bad guide data."
  echo -e " 2. Add your favorite show's Zap2it ID to TheTvDb.com."
  echo -e " 3. Add your favorite show's OriginalAirdate to TheTvDb.com."
  echo -e " 4. Add your favorite show's proper Title to TheTvDb.com"
  echo -e "done."
  exit 0
}

getSeriesInfo(){
  #Usage example: myth2kodi --getSeriesInfo "Black Books"
  echo "RUNNING ${FUNCNAME}() for $InputTitle" | tee -a "$LogFile"
  ShowName="$InputTitle"
  local tvdbshowname=`echo $ShowName | sed s/" "/"%20"/g | sed s/"&"/"%26"/g`
  searchTheTvDbAndReturnTxtFileTables
  GetSeriesLineNumberFromTableWithFuzzyLogic
  #if we have a series line number then translate that into a series id
  if [ "$serieslinenumber" != "" ] && [ $serieslinenumber -gt 0 ]; then
    setSeriesIDandNewShowNameBasedOnSeriesLineNumber
    echo "FOUND:$NewShowName ID#:$SeriesID" | tee -a "$LogFile"
    makeShowDirIfNeeded
  else
    echo "WARNING: SeriesID COULD NOT BE DETERMINED" | tee -a "$LogFile"
    return 1
  fi
  downloadInfoAboutMatchedTitleAndCreateTxtFileTables
  echo "TheTVDB information written to: $m2kdir/$NewShowName" | tee -a "$LogFile"
  return 0
}

########################### END FUNCTION DEFINITIONS ###########################


######################### BEGIN MAIN PROGRAM ###################################

#TODO: The permission handling stuff seems a bit convoluted, I also think I've
#  found at least a few bugs. It would seem far simpler to enforce a dedicated
#  user to function as the "Librarian". That is add a Librarian= to the user
#  settings at the start of this file. Probably with the default of
#  Librarian="mythtv" for maximum compatibility with existing expectations of
#  the code... Then simply refuse to run with a helpful error message if the
#  variable $MyUserName doesn't equal $Librarain. The requirement would just be
#  that the user $Librarian be the one running MythTV and that they have write
#  privileges to the MoveDirs that Kodi can see. Then most/all of the need for
#  running commands with sudo and the need for undo to be run as root can be
#  removed... Need to check expectations of MythDataGrabber and other auxiliary
#  functions before making this change.

#####DEFINE ENVIRONMENT AND VARIABLES#####
MyUserName=`whoami`
#Today=`date +%F`
# Set global values
test -f "/etc/myth2kodi/globalSettings" && source /etc/myth2kodi/globalSettings
#make our working dir if it does not exist
if [ ! -d "$m2kdir" ]; then
  mkdir "$m2kdir"
  echo "creating $m2kdir and log file: $LogFile">>"$LogFile"
fi

#setup defaults for searching Series information
SeriesID=""
NewShowName=""
RequiresDoover=0
ConfidenceRating=0
SeriesConfidenceRating=0

#setup defaults for searching Episode information
Exx=""
Sxx=""
GotEpisodeNumber=0
EpisodeConfidenceRating=0
MythicalEpiShow=0

#load variables from a file if required
test -f "$m2kdir"/myth2kodi.conf && source "$m2kdir"/myth2kodi.conf

#TODO: Should allow manual input of season and episode numbers in addition to
#  Title & Subtitle, with full information all searching should be overridden/bypassed...

#TODO: Why the non-sequential order here? does it matter?
InputTitle="$2"
InputSubtitle="$3"
InputPath="$1"
InputOption="$4"
#
test "$InputPath" != "testfile.ext" && test ! -f "$InputPath" && test "$InputTitle" = "" && test "${InputPath:0:1}" != "-" && mythicalHelp
test "$InputPath" = "" && mythicalHelp
MythTVUserJobString="%DIR%/%FILE%"

#####COMMAND LINE SWITCHES#####
#TODO: Add a --commskip option that just re/generates the commskip file for a
#  given show, assuming/checking that show has already been myth2kodi'd. Useful
#  if file was moved before commercial flagging or if commercial flagging needed
#  to be redone
#check for command line switches
case "$InputPath" in

  --scan|-s)
    mythicalScan
  ;;
  --mythicalDiagnostics|-m)
    mythicalDiagnostics
  ;;
  --confidence)
    improveConfidence
    exit 0
  ;;
  --doover|-d)
    executeDoOver
    exit 0
  ;;
  --unmanned_doover)
    DoOverBypass=1
    executeDoOver
    exit 0
  ;;
  --undo)
    executeUndo
    exit 0
  ;;
  --getSeriesInfo)
    #Example usage: myth2kodi --getSeriesInfo "Black Books"
    getSeriesInfo
    exit $?
  ;;
  --help|-?|-h)
    switchhelp=1
    mythicalHelp
    exit 0
  ;;
  --update|--upgrade|--build|-u)
    #mythicalUpdater
    echo "ERROR: NOT MAINTAINING THE UPDATER, SO DON'T BOTHER TRYING TO UPDATE..."
    exit 1
  ;;
  --doMaintenance)
    MaintenanceWarning
    removedead=1
    DoMaintenance
    echo "done."
    exit 0
  ;;
  --special|-s)
    special
    exit 0
  ;;
  --version|-v|-ver|-V)
    echo $mythicalVersion
    exit 0
  ;;
esac
test "${InputTitle:0:1}" = "-" && mythicalHelp

#####ENVIRONMENTAL VARIABLES CONTINUED#####

#Initial log entry
mythicalPlatform="`uname`"
echo "@@@@@@@@@@@NEW SEARCH INITIATED AT `date`@@@@@@@@@@@@@@">>"$LogFile"
echo "$mythicalVersion on $mythicalPlatform">>"$LogFile"
echo "$mythicalVersion"

InputFileBasename=`basename "$InputPath"`

####INSERT PYTHON BINDINGS GENERATION HERE
#If not specified, grab Title and subtitle from database using basename for reference

#####GATHER INFORMATION FROM MythTV DATABASE#####
#Get information if database is enabled
if [ "$Database" = "Enabled" ]; then
  #determine proper database grabber
  case "$DatabaseType" in
    MythTV)
      GetMythTVDatabase
    ;;
    MythTVPythonBindings)
      test "$InputPath" != 'testfile.ext' && GetMythTvPythonBindings
      #TODO:What's the purpose of resetting the DatabaseType here...???
      DatabaseType=MythTV
    ;;
  esac

  #determine appropriate processing for guide data
  case "$GuideDataType" in
    SchedulesDirect)
      echo "Processing MythTV database info as SchedulesDirect."
      ProcessSchedulesDirect
    ;;
    NoLookup)
      echo "Processing MythTV database info as NoLookup."
      ProcessNoLookup
    ;;
    SydFTA)
      echo "Processing MythTV database info as SydFTA."
      ProcessSydFTA
    ;;
    *)
      echo "GuideDataType incorrectly specified, processing MythTV database info assuming SchedulesDirect."
      ProcessSchedulesDirect
    ;;
  esac
fi

#Report found data
echo "RECSTART:$ShowStartTime  DATE:$MovieAirDate $OriginalAirDate"
echo "PROGRAMID:$ProgramID  ShowCategory:$ShowCategory"
test "$InputSubtitle" != "" && echo -n "InputSubtitle:$InputSubtitle  "  || echo -n "InputSubtitle: UNKNOWN  "
test "$Sxx" != "" && echo -n "Sxx:$Sxx  " || echo -n "Sxx: UNKNOWN  "
test "$Exx" != "" && echo "Exx:$Exx" || echo "Exx: UNKNOWN"
echo "PLOT: $Plot"
ShowName=$InputTitle
test "$ShowName" = "" && mythicalHelp

#split on semicolon, there will only be one episode looked up.  Remove non-filesystem-compliant chars.
EpisodeSubtitle=`echo $InputSubtitle | sed 's/;.*//' | tr -d '!|\?*<":>+[]/'`
ExtensionPrep=`basename "$InputPath"`
OriginalExt=`echo "${ExtensionPrep#*.}"`
originaldirname=`dirname "$InputPath"`
FileBaseName=${InputPath##*/}
FileName="$InputPath"

#Check for show Title translations relating to the show in question.
ShowTranslations
#Do not process files in files categoricIgnore or titleIgnore, just exit
ignoreList
SafeShowName=`echo "$ShowName" | sed 's/;.*//' | tr -d '|\?*<":>+[]/'`
#Format Show name for Sending to www.TheTvDb.com and KODI
tvdbshowname=`echo $ShowName | sed s/" "/"%20"/g | sed s/"&"/"%26"/g`
#Setup paths if TargetPathIsInputPath is active.
test "$TargetPathIsInputPath" = "Enabled" && setTargetFolderAsInputPathFolder

#####MAINTENANCE#####
#Loop through the list of created comskip files from dir.tracking, created.tracking and remove orphans.
DoMaintenance

#####SEARCH FOR SHOW AND BUILD INFORMATION#####

if [ "$m2kProgramIDCheck" != "SH" ] && [ "$m2kProgramIDCheck" != "MV" ]; then
  echo "SEARCHING: www.TheTvDb.com SHOW NAME: $ShowName" | tee -a "$LogFile"
  echo "DATE:$MovieAirDate $OriginalAirDate FILE NAME: $InputPath">>"$LogFile"

  #Query thetvdb on show title, then return a list of Zap2itID, ShowName and seriesid.
  searchTheTvDbAndReturnTxtFileTables

  #TODO: This would be better if it could be [ "$GuideDataType" = "SchedulesDirect" ]
  #  Figure out if that's ok with respect to NoLookUp...
  if [ "$GuideDataType" != "SydFTA" ] ; then
    ConfidenceReasoning="$ConfidenceReasoning Attempted Match On Zap2itID:"
    GetSeriesLineNumberFromTableWithZap2itID
    if [ $? = 0 ]; then
      ((++SeriesConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Successful;"
      echo "MATCH FOUND BASED ON Zap2itID:$NewShowName" | tee -a "$LogFile"
    else
      ((--SeriesConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Failed;"
    fi
  fi

  #If the previous if block was skipped or failed to find the SeriesLineNumber
  if [ $SeriesConfidenceRating -le 0 ] ; then
    ConfidenceReasoning="$ConfidenceReasoning Attempted match on Standard Logic:"
    GetSeriesLineNumberFromTableWithStandardLogic
    if [ $? = 0 ]; then
      ConfidenceReasoning="$ConfidenceReasoning Successful;"
    else
      RequiresDoover=1
      ((--SeriesConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Failed; Attempted Title match on Fuzzy Logic:"
      GetSeriesLineNumberFromTableWithFuzzyLogic
      if [ $? = 0 ]; then
        ConfidenceReasoning="$ConfidenceReasoning Successful;"
      else
        ((--SeriesConfidenceRating))
        ConfidenceReasoning="$ConfidenceReasoning Failed; Information not obtainable;"
        MythicalEpiShow=1
      fi
    fi
  fi

  #if we have a series line number then translate that into a series id
  if [ "$serieslinenumber" != "" ] && [ $serieslinenumber -gt 0 ]; then
    setSeriesIDandNewShowNameBasedOnSeriesLineNumber
    echo "FOUND:$NewShowName ID#:$SeriesID WITH CONFIDENCE:$SeriesConfidenceRating" | tee -a "$LogFile"
  else
    echo "WARNING: SERIESID COULD NOT BE DETERMINED" | tee -a "$LogFile"
  fi
fi

#If it's not a recognized episode, then we need to assign the name myth2kodi will use.
test -z "$ShowName" && ShowName=$InputTitle
test -z "$NewShowName" && NewShowName=$ShowName

if [ "$SeriesID" != "" ] ; then
  makeShowDirIfNeeded

  #If database is out of date, download new database
  #TODO: Without internet connection, this fails to run properly even when local
  #  information should be sufficient to properly name episode. Add a flag for
  #  Series that have finished, so we don't keep updating for TV Series that
  #  that finished years ago -- see the Status field for the series in the
  #  ShowName.xml in the $m2kdir dir. Also enable using existing data if update fails.
  determineIfDatabaseIsUpToDate
  if [ "$?" != "0" ]; then
    downloadInfoAboutMatchedTitleAndCreateTxtFileTables
    if [ "$?" != "0" ]; then
      echo "WARNING: COULD NOT DOWNLOAD UP-TO-DATE INFORMATION!" | tee -a "$LogFile"
      RequiresDoover=1
    fi
  fi
#if series id is not obtained send failure message
elif [ -z "$SeriesID" ] && [ "$m2kProgramIDCheck" != "SH" ] && [ "$m2kProgramIDCheck" != "MV" ]; then
  ConfidenceReasoning="$ConfidenceReasoning Failed; "
  echo "SERIES ID WAS NOT FOUND. THETVDB MAY BE DOWN. TRY USING A showTranslations">>"$LogFile"
  if [ "$Database" = "Enabled" ]; then
    echo "DB ENTIRES- RECSTART:$ShowStartTime- MOVIE:$MovieAirDate- ORIGAIRDATE:$OriginalAirDate- CHID:$ChanID- CAT:$ShowCategory-">>"$LogFile"
    test  "${Exx:2:1}" = "" && Exx=$null
  fi
fi

#TODO: Assuming we have identified the Series, but have no Subtitle, try NLP match $Plot against possible plots to guess a subtitle

#####PROCESS EPISODE INFORMATION#####
#If we have a SeriesID but don't already have Season and Episode information
if [ "$SeriesID" != "" ] ; then
  echo "SEARCHING: www.TheTvDb.com information for EPISODE: $EpisodeSubtitle" | tee -a "$LogFile"
  #####GET ABSOLUTE EPISODE NUMBER#####
  if [ "$GuideDataType" = "SchedulesDirect" ] ; then
    ConfidenceReasoning="$ConfidenceReasoning Attempted match on OriginalAirDate:"
    getAbsoluteEpisodeNumberWithOriginalAirdate
    AirdateExitStatus=$?
    test "$AirdateExitStatus" = "1" && test "$EpisodeSubtitle" != "" && ResolveMultipleAirdateMatches
    test "$?" = "0" && AirdateExitStatus=0
    if [ "$AirdateExitStatus" = "0" ]; then
      ((++EpisodeConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Successful; "
      GotEpisodeNumber=1
    else
      echo "AIRDATE FAILED. TITLE MATCH ON ABSOLUTE EPISODE NUMBER: $AbsoluteEpisodeNumber" | tee -a "$LogFile"
      ((--EpisodeConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Failed;"
    fi
  fi

  if [ $GotEpisodeNumber != 1 ] && [ "$EpisodeSubtitle" != "" ]; then
    ConfidenceReasoning="$ConfidenceReasoning  Attempted SubTitle match on Standard logic:"
    getAbsoluteEpisodeNumberWithStandardLogic
    if [ "$?" = "0" ]; then
      ConfidenceReasoning="$ConfidenceReasoning Successful; "
    else
      echo "AIRDATE/STANDARD LOGIC FAILED. FUZZY LOGIC ABSOLUTE: $AbsoluteEpisodeNumber" | tee -a "$LogFile"
      RequiresDoover=1
      ((--EpisodeConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Failed; Attempted SubTitle match on Fuzzy logic:"
      getAbsoluteEpisodeNumberWithFuzzyLogic
      if [ "$?" = "0" ]; then
        ConfidenceReasoning="$ConfidenceReasoning Successful; "
      else
        MythicalEpiShow=1
        ((--EpisodeConfidenceRating))
        ConfidenceReasoning="$ConfidenceReasoning Failed;"
      fi
    fi
  fi

  #update confidence total
  let ConfidenceRating=EpisodeConfidenceRating+SeriesConfidenceRating

  #Verification only makes sense if we got AbsoluteEpisodeNumber from a method
  # other than Standard or Fuzzy logic above.
  if [ $GotEpisodeNumber = 1 ] && [ "$AbsoluteEpisodeNumber" != "" ]; then
    #####VERIFICATION OF CONFIDENCE RATING#####
    #backup AbsoluteEpisodeNumber for tests
    AbsoluteEpisodeNumberBackup=$AbsoluteEpisodeNumber
    if  [ "$InputSubtitle" != "" ] && [ "$OriginalAirDate" != "" ]; then
      #Verify with Standard logic
      getAbsoluteEpisodeNumberWithStandardLogic
      if [ "$AbsoluteEpisodeNumber" != "$AbsoluteEpisodeNumberBackup" ]; then
        StandardLogicDoesNotJiveMessage
        test "$AbsoluteEpisodeNumber" = "" && AbsoluteEpisodeNumber="Nothing"
        ConfidenceReasoning="$ConfidenceReasoning Standard Logic came up with Episode Number $AbsoluteEpisodeNumber. This does not match $AbsoluteEpisodeNumberBackup;"
      else
        #TODO For shows which are way off, we need some sort of doover mechanism.
        #CONFIDENCE:2 LOGIC PATH:  Attempted Match On Zap2itID: Successful; Attempted match on OriginalAirDate: Successful;
        #Standard Logic came up with line 76. This does not match 85; Fuzzy Logic test came up with line 76. This does not match 85;
        #JOB: myth2kodi '/home/mythtv/Videos/1035_20101109001500.mpg' 'Aqua Teen Hunger Force' 'Couple Skate'
        #TARGET SET:/home/mythtv/Videos/Episodes/Aqua Teen Hunger Force/Season 6/Aqua Teen Hunger Force S06E03 (She Creature).mpg
        updateRunningFuzzyLogicErrorCount
        ConfidenceReasoning="$ConfidenceReasoning Verified with Standard logic;"
        (( ++ConfidenceRating ))
      fi

      #Verify with Fuzzy
      getAbsoluteEpisodeNumberWithFuzzyLogic
      if [ "$AbsoluteEpisodeNumber" != "$AbsoluteEpisodeNumberBackup" ]; then
        test "$AbsoluteEpisodeNumber" = "" && AbsoluteEpisodeNumber="Nothing"
        ConfidenceReasoning="$ConfidenceReasoning Fuzzy Logic test came up with Episode Number $AbsoluteEpisodeNumber. This does not match $AbsoluteEpisodeNumberBackup;"
        FuzzyLogicDoesNotJiveMessage
      else
        updateRunningFuzzyLogicErrorCount
        ConfidenceReasoning="$ConfidenceReasoning Verified with Fuzzy logic;"
        (( ++ConfidenceRating ))
      fi
    fi
    #Restore AbsoluteEpisodeNumber after testing
    AbsoluteEpisodeNumber=$AbsoluteEpisodeNumberBackup
  fi

  #Statistical Fuzzy Logic monitoring
  updateRunningTotalMatchesCount
  echo "TOTAL MATCHES:$FuzzyLogicMatches TOTAL VERIFIED FUZZY ERRORS:`test -f "$m2kdir"/FuzzyLogicError.log && cat "$m2kdir"/FuzzyLogicError.log || echo "0"`"
fi

#If we already have Sxx and Exx from MythTV DB, use them. If we also had a Subtitle, then do some verification.
if [ "$Sxx" != "S" ] && [ "$Sxx" != "" ] && [ "$Sxx" != "S00" ] && [ "$Exx" != "E" ] && [ "$Exx" != "" ] && [ "$Exx" != "E00" ] ; then
  #TODO: If the confidence rating from the above is good, and we have an
  #  AbsoluteEpisodeNumber then use it to validate the Sxx, Exx & Subtitle from
  #  the MythTV DB.
  echo "Using episode number: $Sxx$Exx, extracted from the MythTV DB."
  #TODO: Probably should only do the following if the Series confidence rating
  #  is ok.
  #If we don't have a Subtitle, then use Sxx & Exx to get it from the TVDb info.
  if [ "$EpisodeSubtitle" = "" ] ; then
    AbsoluteEpisodeNumberBackup=$AbsoluteEpisodeNumber
    getAbsoluteEpisodeNumberWithSxxExx
    if [ "$?" = "0" ]; then
      EpisodeSubtitle=`sed -n $AbsoluteEpisodeNumber'p' "$m2kdir"/"$NewShowName"/"$NewShowName".actualEname.txt`
      echo "MythTV DB didn't have an EpisodeSubtitle, using '$EpisodeSubtitle' from TheTVDB."
    else
      AbsoluteEpisodeNumber=$AbsoluteEpisodeNumberBackup
    fi
  fi
  SeasonNumber=${Sxx#S}
  SeasonNumber=${SeasonNumber#0}

#If we don't already have EXX and SXX, set them by matching Absolute Episode Number across myth2kodi's database
elif [ "$AbsoluteEpisodeNumber" != "" ]; then
  setSxxAndExxFromAbsoluteEpisodeNumber
else
  echo "WARNING: Couldn't set Sxx and Exx."
  ConfidenceReasoning="$ConfidenceReasoning Could not set Sxx and Exx, Failed; "
fi


#######SANITY CHECKS#####

if [ "$m2kProgramIDCheck" = "EP" ] && [ "$Exx" = "E" -o "$Exx" = "" ]; then
  ConfidenceReasoning="$ConfidenceReasoning Guide Data did not match a specific Episode;"
  MythicalEpiShow=1
  RequiresDoover=1
  #TODO come up with a way to have a variable like DataWasNotObtainable to check and make it a SH later

#If it's a movie or a showing, give it a name.
#TODO: If it's a movie, try using imdb or similar with available $Plot to determine if the Title is correct...
elif [ "$m2kProgramIDCheck" = "MV" ] || [ "$m2kProgramIDCheck" = "SH" ] ; then
  NewShowName="$InputTitle"
  ConfidenceReasoning="$ConfidenceReasoning Guide Data reported this is a $ProgramIDType;"
fi

#if the confidence was low, then show requires a doover
#TODO: Use test for short, if for long, ie: [[ ConfidenceRating <= -4 ]] && RequiresDoover=1
if [ $ConfidenceRating -le -4 ]; then
  RequiresDoover=1
fi

#If file is a link then activate link mode so the original link is not screwed up.
if [ -L "$InputPath" ]; then
  echo "WARNING: FILE IS A LINK FORCING SYMLINK LINK MODE" | tee -a "$LogFile"
  SYMLINK=LINK
fi

#If user wants database data deleted, then we will do that if the match was a good confidence level
#TODO: Use test for short, if for long, ie: [[ "$SYMLINK" = "Disabled" ]] && [[ ConfidenceRating > -4 ]] && RequiresDoover=0
if [ "$SYMLINK" = "Disabled" ]; then
  if [ $ConfidenceRating -gt -4 ]; then
    RequiresDoover=0
  fi
fi

#####INVALID FILE HANDLING####
#If file to be moved does not exist, then report
if [ ! -f "$InputPath" ] && [ "$InputPath" != "testfile.ext" ]; then
  InvalidFileErrorMessage
  if [ $Notify = Enabled ]; then
    sudo -u "$NotifyUserName" /usr/local/bin/librarian-notify-send "myth2kodi Error" "Invalid File supplied" error
  fi
  jobtype=InvalidFileNameSupplied
  RunJob
fi

##TEST FILESYSTEM##
#Get file size and free space
test -f "./$InputPath" && MoveFileSize=`stat "$InputPath" --format=%s` | awk '{print $1}' || MoveFileSize=0
MoveFileSize=$((MoveFileSize/1024))
MoveDirFreeSpace=`df -P "$MoveDir" | sed -n 2p | awk '{print $4}'` || MoveDirFreeSpace=0
AlternateMoveDirFreeSpace=`df -P "$AlternateMoveDir" | sed -n 2p | awk '{print $4}'`|| AlternateMoveDirFreeSpace=0
if [ "$Database" = "Enabled" ]; then
  PrimaryMovieDirFreeSpace=`df -P "$PrimaryMovieDir" | sed -n 2p | awk '{print $4}'` || PrimaryMovieDirFreeSpace=0
  AlternateMovieDirFreeSpace=`df -P "$AlternateMovieDir" | sed -n 2p | awk '{print $4}'`|| AlternateMovieDirFreeSpace=0
  PrimaryShowDirFreeSpace=`df -P "$PrimaryShowDir" | sed -n 2p | awk '{print $4}'`|| PrimaryShowDirFreeSpace=0
  AlternateShowDirFreeSpace=`df -P "$AlternateShowDir" | sed -n 2p | awk '{print $4}'`|| AlternateShowDirFreeSpace=0
fi
#Call permissions check from function.  Write small file, delete, get results
checkPermissions "$MoveFileSize" "$MoveDirFreeSpace" "$MoveDir"
MoveDirWritable=$TMoveDirWritable
checkPermissions "$MoveFileSize" "$AlternateMoveDirFreeSpace" "$AlternateMoveDir"
AlternateMoveDirWritable=$TMoveDirWritable
if [ "$Database" = "Enabled" ]; then
  checkPermissions "$MoveFileSize" "$PrimaryMovieDirFreeSpace" "$PrimaryMovieDir"
  PrimaryMovieDirWritable=$TMoveDirWritable
  checkPermissions "$MoveFileSize" "$AlternateMovieDirFreeSpace" "$AlternateMovieDir"
  AlternateMovieDirWritable=$TMoveDirWritable
  checkPermissions "$MoveFileSize" "$PrimaryShowDirFreeSpace" "$PrimaryShowDir"
  PrimaryShowDirWritable=$TMoveDirWritable
  checkPermissions "$MoveFileSize" "$AlternateShowDirFreeSpace" "$AlternateShowDir"
  AlternateShowDirWritable=$TMoveDirWritable
fi
OriginaldirFreeSpace=`df -P "$originaldirname" | sed -n 2p | awk '{print $4}'`
WorkingDirFreeSpace=`df -P "$m2kdir" | sed -n 2p | awk '{print $4}'`
checkPermissions "1" "$OriginaldirFreeSpace" "$originaldirname"
OriginalDirWritable=$TMoveDirWritable
checkPermissions "5000" "$WorkingDirFreeSpace" "$m2kdir"
WorkingDirWritable=$TMoveDirWritable

#Report naming decisions
echo "CONFIDENCE:$ConfidenceRating LOGIC PATH: $ConfidenceReasoning"

#####DEBUG MODE OUTPUT BLOCK#####
if [ "$DEBUGMODE" = "Enabled" ]; then
  echo "###################DEBUG MODE ENABLED####################">>"$LogFile"
  echo "MY USER NAME:$MyUserName-">>"$LogFile"
  echo "JOB: myth2kodi '$InputPath' '$InputTitle' '$InputSubtitle'"
  echo "LISTING INTERNAL VARIABLES USED BY myth2kodi.">>"$LogFile"
  echo "INTERNET TIMEOUT:$Timeout- TVDB API KEY:$APIkey- myth2kodi WORKING DIR:$m2kdir-">>"$LogFile"
  echo "MOVE DIR:$MoveDir-">>"$LogFile"
  echo "FAILSAFE MODE:$FailSafeMode- FAILSAFE DIR:$FailSafeDir- ALTERNATE MOVE DIR:$AlternateMoveDir-">>"$LogFile"
  echo "USE ORIGINAL DIR:$TargetPathIsInputPath NOTIFICATIONS:$Notify">>"$LogFile"
  echo "INPUT SHOW NAME:$InputTitle- LOCAL SHOW NAME TRANSLATION:${showtranslation}- ShowName:$ShowName">>"$LogFile"
  echo "DATABASE UPDATED:$DatabaseWasUpdated- TVDB LAST UPDATED:$LastUpdated- CURRENT:$TvDbTime-">>"$LogFile"
  echo "RESOLVED SERIES ID:$SeriesID- RESOVED SHOW NAME:$NewShowName-">>"$LogFile"
  echo "INPUT EPISODE NAME:$InputSubtitle- Absolute EPISODE NUMBER:$AbsoluteEpisodeNumber- RESOLVED EPISODE NAME:$EpisodeSubtitle-">>"$LogFile"
  echo "SEASON:$Sxx- EPISODE:$Exx- SYMLINK MODE:$SYMLINK- FILESIZE: $MoveFileSize""kB-">>"$LogFile"
  echo "CONFIDENCE:$ConfidenceRating LOGIC PATH: $ConfidenceReasoning">> "$LogFile"
  echo "CREATE AND DELETE FLAGS: ORIGINALDIR:$OriginalDirWritable- FREE:$OriginaldirFreeSpace""kB- WORKINGDIR:$WorkingDirWritable FREE:$WorkingDirFreeSpace""kB""-">>"$LogFile"
  echo "MOVEDIRWRITABLE:$MoveDirWritable- FREE:$MoveDirFreeSpace""kB- ALTERNATEMOVEDIR:$AlternateMoveDirWritable- FREE:$AlternateMoveDirFreeSpace""kB-">>"$LogFile"
  if [ "$Database" = "Enabled"  ]; then
    echo "PRIMARYSHOWDIRWRITABLE:$PrimaryShowDirWritable-  FREE:$PrimaryShowDirFreeSpace""kB-""ALTERNATESHOWDIRWRITABLE:$AlternateShowDirWritable- FREE:$AlternateShowDirFreeSpace""kB-">>"$LogFile"
    echo "PRIMARYMOVIEDIRWRITABLE:$PrimaryMovieDirWritable- FREE:$PrimaryMovieDirFreeSpace""kB""- ALTERNATEMOVIEDIR:$AlternateMoveDirWritable- FREE:$AlternateMovieDirFreeSpace""kB""-">>"$LogFile"
    echo "DATABASE TYPE:$XMLTVGrabber-">>"$LogFile"
    echo " RECSTART:$ShowStartTime- MOVIE YEAR:$MovieAirDate- ORIGINAL SERIES DATE:$OriginalAirDate-">>"$LogFile"
    echo " PROGRAMID:$ProgramID- CHANNEL ID:$ChanID- CATEGORY:$ShowCategory- GOFORDOOVER:$GoForDoover-">>"$LogFile"
    echo " EXTRAPOLATED DATA DETERMINED THIS RECORDING AS A:$ProgramIDType- STARS:$Stars RATING:$rating">> "$LogFile"
    echo " ZAP2IT SERIES ID:$Zap2itSeriesID- MATCHED TVDB SERIES ID:$MatchedSeriesID-" >>"$LogFile"
    echo PLOT: "$Plot" >>"$LogFile"
  fi
  echo "####################END OF DEBUG LOG#####################">>"$LogFile"
fi

######PRE-NAMING CHECKS#####
#if no episode data and it's not a movie or a test
if [ "$Exx" = "" ] && [ "$InputPath" != "testfile.ext" ] ; then
  if [ "$ChanID" = "" ] && [ "$InputPath" ]; then
    echo "This episode could not be matched based on supplied Title and SubTitle."
    jobType="NameCouldNotBeAssigned"
    runjob
  elif [ "$m2kProgramIDCheck" = "MV" ]; then
    #Ensures the doover value was not set for the movie and use safe show name
    RequiresDoover=0
    NewShowName=$SafeShowName
  #If user has determined that they do not want unrecognisable tv shows in their library
  elif [ "$ShowStopper" = "Enabled" ]; then
    tvDbIsIncomplete
    writeJobToDooverQue
    jobtype=NameCouldNotBeAssigned
    runjob
  elif [ "$m2kProgramIDCheck" = "SH" ]; then
    #Ensures the doover value was not set for the show and use safe show name
    NewShowName=$SafeShowName
    DisplayShowWarning
  else
    #This marks Episodes as shows.  AKA EpiShows.  Episodes for which no information cannot be obtained currently.
    MythicalEpiShow=1
    #change the show to a Generic type
    NewShowName=$SafeShowName
    DisplayEpiShowMessage
  fi
fi

#Figure out if the file can go in the movedir, or if the alternate should be used
determinePrimaryOrAlternateFolderUsage

#####OUTPUT FILE NAME FORMATTING#####
#universally not accepted file system characters:  |\?*<":>+[]/
#Format Shows
EpisodeSubtitle=`echo $EpisodeSubtitle | tr -d '!|\?*<":>+[]/'"'"`
NewShowName=`echo $NewShowName | tr -d '!|\?*<":>+[]/'"'"`
ShowName=`echo $ShowName | tr -d '!|\?*<":>+[]/'"'"`

#Format Episodes showname=show name Sxx=season number Exx=episode number EpisodeSubtitle=episode name
if [ "$NamingConvention" = "" ]; then
  TraditionalNamingConventions
else
  test "$NewShowName" = "" && NewShowName=$ShowName
  CategoricNamingConventions
  RequiresNFO=1
fi

#####MAKE THE FOLDER#####
MakeFolder

#check to see if output folder exists
test -d "$MoveDir" && echo "TARGET SET:$MoveDir/$ShowFileName.$OriginalExt" || echo "ERROR: COULD NOT CREATE FOLDER:$MoveDir/$ShowFileName"

#####FAILSAFE HANDLING#####
#If failsafe state is set then create link in FailSafeMode
if [ $FailSafeState = "1" ]; then
  #doFailSafeMode activates movedir = failsafe dir and link mode is used
  doFailSafeMode
  #--doover will reprocess the show
  writeJobToDooverQue
  jobtype=FailSafeModeComplete
  RunJob
fi

#####ANTI-CLOBBER#####
#If file exists then make a new name for it
if [ -f "$MoveDir/$ShowFileName.$OriginalExt" ]; then
  myth2kodiCounter=0
  NameCheck=0
  while [ $NameCheck = '0' ]; do
    ((++myth2kodiCounter))

    #If file does not exist, then it is a valid target
    if [ ! -e "$MoveDir/$ShowFileName-$myth2kodiCounter.$OriginalExt" ]; then
      NameCheck="1"
      ShowFileName=`echo "$ShowFileName"-"$myth2kodiCounter"`
      echo "FILE NAME EXISTS.  FILE WILL BE KNOWN AS: $ShowFileName"
    fi
  done
fi

#If this is a test file, then exit now.
test "$InputPath" = "testfile.ext" && test "$Exx" != "E07" && echo 'FUZZY FAILURE' && exit 1
test "$InputPath" = "testfile.ext" && DoTestFileExit

#If the user is not mythtv and the settings are set for mythtv only, then exit, display a clear status message.
DoMythTVPermissionsCheck

#If the show is generic programming, this is the best myth2kodi can do.
test  "$m2kProgramIDCheck" = "SH" && DisplayShowWarning

#####MOVE MODE HANDLING#####
#If symlink is not in LINK mode, Move and rename the file.
if [ "$SYMLINK" != "LINK" ]; then
  #Send notifications, Move the file and rename
  echo "MOVING FILE: '$InputPath' to '$MoveDir/$ShowFileName.$OriginalExt'">>"$LogFile"
  test "$Notify" = "Enabled" && sudo -u "$NotifyUserName" /usr/local/bin/librarian-notify-send "myth2kodi Moving" "Moving and renaming $ShowFileName" drive-harddisk
  mv "$InputPath" "$MoveDir/$ShowFileName.$OriginalExt"

  #Check and report if file was moved
  if [ -e "$MoveDir/$ShowFileName.$OriginalExt" ]; then
    if [ -f "$MoveDir/$ShowFileName.$OriginalExt" ]; then
      #Create Commercial skip data with file
      if [ "$CommercialMarkup" = "Created" ]; then
        mv "$m2kdir/markupframes.txt" "$MoveDir/$ShowFileName.txt"
        echo "'$MoveDir/$ShowFileName.txt'" "'$MoveDir/$ShowFileName.$OriginalExt'">>"$m2kdir"/created.tracking
      fi
      #Make symlink back to original file
      if [ "$SYMLINK" = "MOVE" ]; then
        echo CREATING SYMLINK IN MOVE MODE
        ln -s  "$MoveDir/$ShowFileName.$OriginalExt" "$InputPath"
        test ! -L "$InputPath" && echo "ERROR CREATING SYMLINK: FILESYSTEM MAY NOT SUPPORT SYMLINKS" | tee -a "$LogFile"
      fi
      DisplayCompletedMoveMessage

      #If symlink=disabled, remove database entries
      if [  "$SYMLINK" = "Disabled" ]; then
        chmod 775 "$MoveDir/$ShowFileName.$OriginalExt"
        if [ "$RequiresDoover" != "1" ]; then
          DeleteRelevantDatabaseFilesAndPictures
        else
          echo CREATING SYMLINK IN SYMLINK=DISABLED MODE
          ln -s  "$MoveDir/$ShowFileName.$OriginalExt" "$InputPath"
          test ! -L "$InputPath" && echo "ERROR CREATING SYMLINK: FILESYSTEM MAY NOT SUPPORT SYMLINKS" | tee -a "$LogFile"
        fi
      fi

      #Send notification of completion and exit
      test $Notify = "Enabled" && sudo -u "$NotifyUserName" /usr/local/bin/librarian-notify-send "myth2kodi Success" "$ShowFileName moved to $MoveDir" info

      #Additional features, notifications, rss, daily report.
      test  "$RequiresNFO" = "1" && GenerateTVShowNFO
      test  "$RequiresNFO" = "1" && GenerateEpisodeNFO
      KODIAutomate
      performLoggingForMoveMode
      dailyreport
      generaterss
      test "$SYMLINK" = "Disabled" && setGroupPermissions
      jobtype=MoveModeSuccessful
      RunJob

    #if file was not moved, then fail
    elif [ ! -s "$MoveDir/$ShowFileName.$OriginalExt" ]; then
      rm -f "$MoveDir/$ShowFileName.$OriginalExt"
      writeJobToDooverQue
      Wrote0LengthFile
      jobtype=PermissionError0Length
      RunJob

    fi
  elif [ ! -f "$MoveDir/$ShowFileName.$OriginalExt" ]; then
    writeJobToDooverQue
    PermissionErrorWhileMoving
    jobtype=PermissionErrorWhileMoving
    RunJob
  fi

#####LINK MODE HANDLING#####
#If symlink is in LINK mode then create symlink
elif [ "$SYMLINK" = "LINK" ]; then
  echo "CREATING LINK IN LINK MODE WITH CONFIDENCE:$ConfidenceRating"

  ln -s "$InputPath" "$MoveDir/$ShowFileName.$OriginalExt"

  #if file was created
  if [ -L "$MoveDir/$ShowFileName.$OriginalExt" ]; then
    echo "Symlink created $MoveDir/$ShowFileName.$OriginalExt">>"$LogFile"
    echo "@@@@@@@@@@@@@OPERATION COMPLETE" `date` "@@@@@@@@@@@@@@@@">>"$LogFile"
    if [ "$Notify" = "Enabled" ]; then
      sudo -u "$NotifyUserName" /usr/local/bin/librarian-notify-send "myth2kodi Success" "$ShowFileName linked to $MoveDir" info
    fi

    #Move comskip data to proper folder
    if [ "$CommercialMarkup" = "Created" ]; then
      mv "$m2kdir"/markupframes.txt "$MoveDir/$ShowFileName.txt"
      echo "$MoveDir/$ShowFileName.txt">>"$m2kdir"/created.tracking
    fi

    #Additional features, notifications, rss, daily report.
    test  "$RequiresNFO" = "1"  && GenerateTVShowNFO
    test  "$RequiresNFO" = "1"  && GenerateEpisodeNFO
    KODIAutomate
    performLoggingForLinkMode
    dailyreport
    generaterss
    test "$SYMLINK" = "Disabled" && setGroupPermissions
    jobtype=LinkModeSuccessful
    RunJob

    #If link failure, send notification and fail
  elif [ ! -L "$MoveDir/$ShowFileName.$OriginalExt" ]; then
    echo "myth2kodi '$1' '$2' '$3'">>$m2kdir/doover.sh
    SymlinkNotCreated
    writeJobToDooverQue

  fi
  jobtype=LinkModeFailed
  RunJob

fi

#####GENERIC UNSPECIFIED ERROR#####
#if no match is found then send error messages
test "$Exx" = "" &&  genericUnspecifiedError

#send notification if enabled
if [ "$Notify" = "Enabled" ] ; then
  sudo -u "$NotifyUserName" /usr/local/bin/librarian-notify-send "myth2kodi error" "myth2kodi operation failed See $LogFile for more information" error
if
writeJobToDooverQue
jobtype=GenericUnspecifiedError
RunJob

exit 4
