#! /bin/bash

# ***** WELCOME! Scroll further down to set the user settings. *****

#myth2kodi is a modified version of mythicalLibrarian by Adam Outler
#
# mythicalLibrarian Author: Adam Outler
# email: adamoutler gmail.com
# mythicalLibrarian Originally Written: 2009ish
#
# myth2kodi Author: Stuart A. Knock
# myth2kodi Originally Written: 2015-11
#
#Software the way it should be: Free and Open Source
#
#mythicalLibrarian Tech Support: http://forum.kodi.tv/showthread.php?pid=470402
#

#TODO: Review text under: Output Files; Database-external; Database-internal;
#      Dependencies; .

#TODO: Contact original author before moving to a public GitHub repo...

#TODO: If making a tar ball as a "Release", include the following:
#    myth2kodi
#    bashlogging
#    MythDataGrabber
#    m2k_notify
#    showTranslations.SydFTA

#TODO: Make use of TMDb (https://www.themoviedb.org/) when the recorded
#  program is identified as being a Movie... Or http://omdbapi.com/, eg
#  http://www.omdbapi.com/?t=Casino&y=&plot=short&r=xml

#TODO: A number of the long "test" lines would be much easier to read/debug
#  if they were rewritten as "if ; then else" blocks.

#TODO: Clean up the name space by using "local" for variable declarations
#  that are only used within functions.

#TODO: Go through and check for variables that aren't initialised before
#  first use -- prefer initialising everything as it avoids cruft from
#  the environment, though should check interaction with global settings.

#TODO: Consider replacing all echo statements with corresponding printf, as
#  it's apparently preferred for compatibility/portability reasons. See,
#    http://wiki.bash-hackers.org/commands/builtin/printf

#TODO: Review logging statements throughout... Add consistent stack-trace
#      information to all Warn and Err statements (maybe in bash-logging).
#      Move some of the Inform statements to Debug, to avoid lots of
#      repetition with Inform (level 2) logging.

#TODO: Consider changing default binpath from "/usr/local/bin" to 
#      "/home/$Librarian/bin". We really want to avoid root/sudo requirements
#      as much as possible.

#TODO: really need to review doover and undo usage...

#Intention:
#  This program automates the mapping of MythTv recordings to a Kodi library.
#  It is designed to be a user job in MythTV. It can also be run manually from
#  a command line. It must have access to your MythTV recordings. The program
#  generates file names compatible with Kodi, then moves or links recordings
#  based on user settings. Commskip and NFO files are also generated from your
#  MythTV database, as required, so that Kodi can make use of them.
#
#Installation:
#  The myth2kodi file should be placed in the users path, see the binpath
#  variable in user settings (Default: /usr/local/bin). Some of the
#  functionality of this script is provided in other files, these will also
#  need to be placed in $binpath along with this script. They are:
#  MythDataGrabber -- Uses MythTV python bindings to access database information.
#  m2k_notify -- A script for sending notifications to Gnome Desktop.
#  bashlogging -- A set of bash functions that provide the logging mechanism
#                 used throughout myth2kodi.
#
#Usage:
#  The MythTV user job should be called as follows:
#    $binpath/myth2kodi "%DIR%/%FILE%"
#  where "$binpath" is replaced by the full explicit path from USER SETTINGS.
#  At the command line, the script can be called with the following form:
#    myth2kodi "Input File" "show name" "episode name"
#  for example:
#    myth2kodi "/home/myth/recordings/2308320472023429837.mpg" "South Park" "Here Comes the Neighborhood"
#  for additional functionality type:
#    myth2kodi --help
#  To function on your system, some of the variables specified in the
#  USER SETTINGS section below may need to be modified from their defaults.
#  For example, to avoid permission issues, myth2kodi should be run as the
#  same user running MythTV (see USER SETTING, Librarian).
#
#Output-target:
#  If an error occurs and the file cannot be moved, then no change will occur to
#  the original file. If the MoveDir is full or not available, such as when
#  running a NAS and the computer is disconnected from the network, the
#  AlternateMoveDir will be used. If both of these dirs fail, the show will be
#  SymLinked in the FailSafeDir. You may elect to run the user job at a later
#  time when the issue has been resolved. Output dir and link type will depend
#  on user settings. The file name is preset to the most acceptable standard:
#    Show Title - SxxExx (Episode Title).ext
#
#Symlinking:
#  When Symlinking is enabled, myth2kodi will follow its normal mode of
#  operation. In MOVE mode, myth2kodi will create a symlink from the new
#  file in the same name and location of the old file. In LINK mode,
#  myth2kodi will not move the file, LINK mode creates a new symlink to
#  the original file. Both approaches enable Kodi to access the recording
#  while still allowing MythTV to keep track of it. If Symlinking is set
#  to "Disabled" then, when myth2kodi moves a recording, it will also
#  delete it from MythTV's database.
#
#Output-Files:
#  myth2kodi will create several files in it's working folder. This is a
#  list of the files and their functions:
#    +created.tracking keeps track of created comskip.txt and NFO files so they
#      can be deleted in the future if their video file is deleted.
#    +doover.sh is designed to keep track of failed jobs. It is designed to be
#      executable. #Commented commands are those which are determined to be
#      questionable. This file can be made executable and run after a problem is
#      corrected which caused the problem. Questionable commands are those which
#      will require you to add an episode title and set the myth2kodi
#      Database=Disabled setting. Questionable files do not have sufficient
#      guide data.
#    +markupstart.txt and markupstop.txt are files which contain information
#      from the last comskip generation. Deletion will cause no adverse effects.
#    +output.log keeps track of operations and can be used to determine problems.
#    +shn.txt, sid.txt, and working.xml are used each time to determine the name
#      and show id of the last show identified.
#    +DailyReport directory is used to log the files which were moved that day.
#      It can be used as a "program guide" of sorts to keep track of what has
#      been added to your library.
#
#Logging:
#  Log files can be generated to show information for troubleshooting. You can
#  find the log file in myth2kodi's working folder (see USER SETTING, m2kdir).
#  For configuration options, see, the "Logging settings" section of
#  USER SETTINGS below. The default location of the main log file is:
#    /home/<Librarian>/.myth2kodi/output.log
#
#Database-external:
#  This program will make 3 calls to TheTVDB for every episode. The first one is
#  to obtain the series ID and verify the show name is correct. The second is to
#  check if the internally managed database is up-to-date. The third call will
#  only be made if the internal database is not up-to-date. The third call will
#  download a larger file which contains all information about the show which is
#  known on TheTVDB.
#
#Database-internal:
#  While myth2kodi maintains and requires it's own external file/folder
#  database in the working directory, there is also support for integration with
#  MythTV's internal database. MythTV Database is required for movies to be
#  recognized and handled by myth2kodi. Also, in the event that the
#  integrated fuzzy logic cannot make a determination of the correct show name,
#  myth2kodi will pull the original air date from the MythTV database
#  and attempt to make an exact match to TheTVDB.com supplied data. In addition,
#  the type of program is extracted from the mythtv database and a determination
#  is made weather or not there is sufficient information available to identify
#  the show based upon guide data. In order to make myth2kodi work to
#  it's full potential, all settings must be filled out correctly under the
#  database section of the user settings. Currently, the only guide data
#  supported is schedulesdirect through mythtv. When updating myth2kodi
#  it is best to delete all database folders to ensure proper data formatting.
#
#Dependencies:
#  "curl" -- downloads webpages and sends commands to Kodi;
#  "jq" -- parses json files, used for tvmaze data.
#  "agrep" -- provides fuzzy logic;
#  "libnotify-bin" -- allows GNOME desktop notifications;
#  "mythbackend" -- Access the MythTV database.
#
#  These should all be available through the package manager for your Linux
#  distribution. For example:
#    "apt-get install curl"
#  or
#    "zypper install curl"
#
#Gnome Notifications:
#  In order for myth2kodi to send notifications to the GNOME desktop, it
#  must have no-password sudo access. It uses this access strictly to send
#  complete, moving and failure status notifications. Because this program is
#  launched by the user $Librarian under normal circumstances, $Librarian must
#  temporarily become your user name in order to send a notification to your
#  desktop. This requires the use of a separate script, and for $Librarian to
#  have a sudoers group with no password option. Notifications are an optional
#  feature and will only work on the MythTV backend computer. The m2k_notify
#  script should be located in $binpath.
#
#KODI Notifications:
#   If options are enabled, myth2kodi will send a http requests to a
#   specified KODI Server to display library updates, to update the library and
#   to clean out the library. In order for this to work KODI you must ensure
#   that the setting in KODI under System->Network->Services->Allow control of
#   KODI via HTTP and Allow programs on other systems to control KODI are
#   enabled.
#
#Show Name Translation:
#  The user may elect to create a file in the myth2kodi working folder
#  which will then translate any recorded show name into the desired show name.
#  This is useful for adding a year to distinguish between a new series and an
#  older series and/or typos in your guide data. By default it should be called
#  "showTranslations" and it will be in your $m2kdir folder. Correct show titles
#  can be determined by manually searching www.TheTVDB.com. The showTranslations
#  file is not needed by most SchedulesDirect users and the file should only be
#  created if it is needed. However, it is almost essential when using digital
#  free to air guide data, such as SydFTA (See USER SETTING, "GuideDataType").
#  An example file, "showTranslations.SydFTA", should be bundled with this script.
#  The format of showTranslations is (NB: no "#" or space at the start of a
#  line, only one space either side of "=", and no trailing space or any other
#  characters):
#    Filename: $m2kdir/showTranslations
#      My Guide Show Title = www.TheTVDB.com Show Title
#      Battlestar Gallactica = Battlestar Gallactica (2003)
#      The Office = The Office (US)
#      Millionaire = Who Wants To Be A Millionaire
#      Aqua teen Hungerforce = Aqua Teen Hunger Force
################################################################################


########################### BEGIN USER SETTINGS ################################
###Stand-alone mode values###
#Specify the name of the user running mythtv, myth2kodi should always be run by that user.  Default="mythtv"
Librarian="librarian"
#SYMLINK has 3 modes.  MOVE|LINK|Disabled: Default=MOVE
#Create symlink at InputPath after 'MOVE' | Do not move, just create a sym'LINK' | move the file, symlinking is 'Disabled'
SYMLINK="MOVE"
#MoveDir is the folder which myth2kodi will move the file. No trailing / is accepted eg. "~/videos"
MoveDir="/media/video/tv"  #<------THIS VALUE MUST BE SET-------
#AlternateMoveDir will act as a secondary MoveDir if the primary MoveDir fails.  No trailing / is accepted eg. "~/videos"
AlternateMoveDir="/home/librarian/recordedTV"
#If TargetPathIsInputPath is Enabled, original dir will override MoveDir. Useful
#for multiple recording dirs. TargetPathIsInputPath will separate generic shows
#from episodes and movies. Enabled|Disabled
TargetPathIsInputPath="Disabled"
#Internet access Timeout in seconds: Default Timeout=50 (seconds)
Timeout=50
#Update database time in seconds, Longer duration means faster processing time and less strain on TheTVDB. Default='88920' (1 day + eps)
UpdateDatabase=88920
#The path which contains myth2kodi and associated scripts default=/usr/local/bin
binpath="/usr/local/bin"
#myth2kodi working directory: Default=$HOME/.myth2kodi (ie, /home/username/.myth2kodi)
m2kdir="$HOME/.myth2kodi"
#FailSafe mode will enable symlinks to be formed in FailSafeDir if the move or symlink operation fails. Enabled|Disabled
FailSafeMode="Disabled"
#FailSafeDir is used when the file cannot be moved to the MoveDir. FailSafe will not create folders. eg. /home/username
FailSafeDir="/home/librarian/FailSafe"  #<------THIS VALUE MUST BE SET-------
#DirTracking will check for and remove the folders created by myth2kodi
DirTracking="Enabled"
#the following line contains the API key from www.TheTVDB.Com. Default project code: 6DF511BB2A64E0E9
APIkey="6DF511BB2A64E0E9"
#TODO: If I ever put this on GitHub I should register a fresh APIkey - http://thetvdb.com/?tab=apiregister
#Language setting
Language="en"

#StorageGroupFallback can be used to enable/disable a bit of code that, if Guide Data identified the
#input file as a show or episode, but no episode or series information was found, then it checks if
#the MythTV DB's storagegroup is movie[s] or film[s] and uses this to reset the recording type as Movie.
#To function it requires that you have created a MythTV storagegroup called something like 'Movies'
#and selected that storagegroup when making the rule for the recording. This works for my setup SAK.
#Options: ['Enabled'|'Disabled']
StorageGroupFallback="Enabled"

#PlotMatchFallback can be used to enable/disable a bit of code that, if a SeriesID has been determined,
#but no subtitle, nor Season & Episode numbers have been identified, falls back to fuzzy matching the
#Plot field from the Guide data in MythTV DB against the Plot data for the series, which we retrieved from
#TheTVDB.
#Options: ['Enabled'|'Disabled']
PlotMatchFallback="Enabled"

###Database settings###
#MythTV MYSQL access allows addition of movies, comskip data, and improves accuracy of episode recognition.
#Database access Enabled|Disabled
Database="Enabled"
#Database Type MythTV|MythTVPythonBindings  Default=MythTVPythonBinding
DatabaseType="MythTVPythonBindings"
#Guide data type: SchedulesDirect currently covers DataDirect, MC2XML and others.  NoLookup will bypass tvdb scanning
#Options: SchedulesDirect|NoLookup|SydFTA
GuideDataType="SydFTA"
#The IP address or name of the server for MythTV Database (used in python bindings only)
#TODO: This doesn't seem to be being used, at least, having it set incorrectly (192.168.1.42 while testing on borg (.78)) doesn't seem to cause a problem...
DBHostName="192.168.1.78"
#MySQL User name: Default="mythtv"
MySQLuser="mythtv"
#MySQL Password: Default="mythtv"
MySQLpass="mythtv" #<------THIS VALUE MUST BE SET-------
#MythTV Backend server: Default=localhost
#SAK: NOT USED ###MythTVBackendServer=localhost
#The Database Pin for the MythTV Database (used in python bindings only)
DBPin=8446
#MySQL Myth Database: Default="mythconverg"
#If utilizing mythconverg with Python Bindings, then it would be MySQLMythDb=PythonBindingsmythconverg
MySQLMythDb="mythconverg"
#Primary Movie Dir. myth2kodi will attempt to move to this dir first. No trailing / is accepted eg. "~/videos"
PrimaryMovieDir="/media/video/movies" #<------THIS VALUE MUST BE SET-------
#AlternateMovieDir will act as a Secondary move dir if the primary movie dir fails
AlternateMovieDir="/home/librarian/recordedMovies"
#ShowStopper = Enabled prevents generic shows and unrecognized episodes from being processed
ShowStopper="Enabled"
#Primary Show Dir. myth2kodi will attempt to move to this dir first. No trailing / is accepted eg. "~/videos"
PrimaryShowDir="/media/video/recordedShows" #<------THIS VALUE MUST BE SET-------
#AlternateMoveDir will act as a Seccondary move dir if the primary move dir fails
AlternateShowDir="/home/librarian/recordedShows"
#CommercialMarkup will generate comskip files for recordings when they are moved. Enabled|Disabled
CommercialMarkup="Enabled"
#CommercialMarkupCleanup if "Enabled", when DoMaintenance() is run, removes comskip & NFO files if the associated .mpg file can't be found.
CommercialMarkupCleanup="Enabled"

###Reporting/Communications###
#DailyReport provides a local log of shows added to your library per day. Enabled|Disabled
DailyReport="Enabled"
#Notify tells myth2kodi to send a notification to GNOME Desktop upon completion. Enabled|Disabled
Notify="Disabled"
#If notifications are enabled, NotifyUserName should be the same as the user logged into the GNOME Session. (your username)
NotifyUserName="librarian" #<------THIS VALUE MUST BE SET-------
#Send a notification to KODI to Update library upon Successful move job Enabled|Disabled
KODIUpdate="Enabled"
#PREVENT CLOBBERING ON RECURSIVE CALLS#[[ -z "$KODIUpdate" ]] && KODIUpdate="Enabled"
#Send a notification to KODI to cleanup the library upon Successful move job Enabled|Disabled
#TODO:#NOTE:Don't fully trust the automated call of clean, and currently it doesn't even
#  seem to be invoked at the times that would make sense, so for now I'm disabling it. See
#  the TODO in KODIAutomate().
KODIClean="Disabled"
#Send Notifications to KODI UI when library is updated Enabled|Disabled
KODINotify="Enabled"
#Ip Address and port for KODI Notifications Eg.KODIIPs=( "192.168.1.110:8080" "192.168.1.111:8080" "XBOX:8080" )
#NOTE: If you've set username and password for remote access to kodi then you'll need to prepend user:password@ to the ip addresses
KODIIPs=( "kodi:supersecurekodi@192.168.1.78:8080" ) #<------THIS VALUE MUST BE SET-------
#RSSmaxItems controls the number of items in the RSS. RSS Can be activated by creating a folder in /var/www/myth2kodi-rss.
#NOTE: setting this to 0 will essentially be ignored as generateRSS() considers it unset and uses the default of 8
declare -i RSSmaxItems=8

###Logging settings###
#These settings are for the bashlogging script which provides the configurable
#logging functionality used in myth2kodi.
#LogLevel provides control over the amount of information myth2kodi reports.
#    0=Only Errors;
#    1=adds warnings;
#    2=adds more information;  --> DEFAULT
#    3=provides debugging output.
#Recommend 2 to start with or if you want to keep track of what myth2kodi is doing.
#Recommend 1 for usual operation, once you're confident that everything is working fine.
#Only use 3 if you have a particular problem that you're trying to track down, it significantly increases the output.
LogLevel=2
#LogFileName is the name of the log file, this will be placed in myth2kodi's
#working directory, $m2kdir set above, and have the suffix '.log' appended.
#DEFAULT: 'output' #NOTE: LogFile is overridden in special contexts, such as running Diagnostics.
#TODO: Consider changing default to "myth2kodi" => "/home/<Librarian>/.myth2kodi/myth2kodi.log"
LogFileName='output'
#LogType defines where to direct logging messages ['stdout|'logfile'|'both'(DEFAULT)]:
#NOTE: This is made read only within the bashlogging script.
LogType='both'
########################## END USER SETTINGS ###################################
#TODO: Consider disabling stdout logging, ie LogType='logfile', when run as a mythtv user-job.

m2kVersion="myth2kodi Version 0.9.4; mythicalLibrarian 953ish+"

#The full path version of the file to which logging output will be sent:
LogFile="$m2kdir/${LogFileName}.log"
#When running diagnostics mode, output will instead be sent to this file:
declare -r DiagnosticsFile="$m2kdir/diagnostics.log"
#A file containing a list of possible duplicate recordings:
declare -r DuplicatesFile="$m2kdir/duplicates.log"
#A file containing a list of possible duplicate recordings:
declare -r UnrecognizedSeriesFile="$m2kdir/unrecognizedseries.log"

#TODO: Add ability to compress LogFile (either time(eg. Monthly) or size(~8MB)) and start a fresh one.
#if [ -f $LogFile ]; then
#  LogFileSize=$(wc --bytes < "$LogFile")
#  if ((LogFileSize > 8000000)); then
#    Inform "Moving and compressing LogFile"
#    mv "$LogFile" "$m2kdir/$LogFileName_${FileNameNow}.log"
#    gz "$m2kdir/$LogFileName_${FileNameNow}.log"
#    #createlogfile
#  fi
#fi

if [ -f "$binpath"/bashlogging ] ; then
  source "$binpath"/bashlogging "$LogType"
else
  printf 'ERROR: %s\n' "$binpath/bashlogging doesn't exist." | tee -a "$LogFile"
  exit 1
fi

########################### BEGIN USER JOBS ####################################
#The ExitJob function is a place where you can put your custom script to be run
#at the end of execution. Though it may be at the top, this is actually the end
#of the program.
ExitJob(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  DebugCont "Called with $# arguments"
  local -i i=0; local var; for var in "$@"; do ((++i)); DebugCont "arg $i = ${var}"; done
  local jobtype="$1"
  case "$jobtype" in
  #Successful Completion of myth2kodi
    LinkModeSuccessful|MoveModeSuccessful)
      Inform "SUCCESSFUL COMPLETION TYPE: $jobtype"
      #Insert Custom User Job here

      #
      exit 0
      ;;

  #Information was not obtainable
    TheTVDBIsIncomplete|GenericShow)
      Warn "INSUFFICIENT INFORMATION WAS SUPPLIED: $jobtype"
      #Insert Custom User Job here

      #
      exit 0
      ;;

  #File system error occurred
    PermissionError0Length|InvalidFileNameSupplied|PermissionErrorWhileMoving|FailSafeModeComplete|LinkModeFailed)
      Err "IN: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(). FILE SYSTEM ERROR: $jobtype"
      #Insert Custom User Job here

      #
      exit 1
      ;;

  #File name we're trying to move to already exists
    FileAlreadyExists)
      Err "IN: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(). NOT MOVING RECORDING: $jobtype"
      #Insert Custom User Job here

      #
      exit 1
      ;;

  #Generic error occurred
    GenericUnspecifiedError)
      Err "IN: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(). UNKNOWN ERROR OCCOURED: $jobtype"
      #Insert Custom User Job here

      #
      exit 3
      ;;

  #User elected not to process jobs which can not be properly categorized
    NameCouldNotBeAssigned)
      Warn "NAME COULD NOT BE ASSIGNED BASED UPON DATA SUPPLIED"
      #Insert Custom User Job here

      #
      exit 3
      ;;

  #User elected to use a title/category ignore file
    titleIgnore|categoricIgnore)
      Warn "Show Was ignored based on $jobtype"
      #Insert Custom User Job Here

      #
      exit 0
      ;;
  esac
  #
  exit 4
}

#TODO: Drop update entirely, however, consider repurposing mythicalSetup as myth2kodi --setup
# myth2kodi --update (mythicalSetup) will merge user jobs into myth2kodi automagically.
# Put your desired commands into one of the following files.  You may need to create the folder
# /etc/myth2kodi/JobSuccessful
# /etc/myth2kodi/JobInformationNotComplete
# /etc/myth2kodi/JobGenericError
# /etc/myth2kodi/JobFilesystemError
# /etc/myth2kodi/JobInsufficientData
# /etc/myth2kodi/JobIgnoreList
# /etc/myth2kodi/JobUnspecified
# After running mythicalSetup, the user job will be incorporated into the
# myth2kodi script and  Executed when the job is run.

### EXAMPLE JOB (Leading "# " should be removed) ###
# /etc/myth2kodi/JobSuccessful:
# #Transcode your file using the myth2kodi variables
# ffmpeg -i S:"$MoveDir/$ShowFileName.$OriginalExt" -target ntsc-svcds:"$MoveDir/$ShowFileName.mp4"
# #remove the myth2kodi symlink
# rm "$InputPath"
# #make a new symlink
# ln -s  "$MoveDir/$ShowFileName.mp4" "$InputPath"
# #Set the new file extension
# OriginalExt=mp4
# #Create tracking entry for the file
# performLoggingForMoveMode
# ####Move the .txt(comskip) and .nfo(Information) files if needed.
# enable the KODI communications
# KODIUpdate=Enabled
# KODIClean=Enabled
# KODINotify=Enabled
# #Tell myth2kodi to do KODI communications
# KODIAutomate

#Suggested examples are:
# 1.string together multiple versions of myth2kodi configured for
#   different languages. Set a different Language for each, then on failure,
#   call the next job.
# 2.custom name replacement of certain programming
# 3.custom file moving of certain programming
# 4.set custom folders based upon recorded channel
# 5.set custom user jobs based upon who ran the file
# 6.make a "new movies" "old movies" folder.
#The limits are endless.

#The following is a list of variables which can be used as a part of user jobs
#at the end of myth2kodi:
#####ALL RECORDINGS####
#$MoveDir/$ShowFileName.$OriginalExt = location of moved file.
#$ShowName = Processed Title
#$InputTitle = actual database title
#$MoveDir = the folder to which the file was moved ie. "/home/mythtv/videos/Episode"
#$ShowFileName = the name of the show moved, not including extension eg. "simpsons S01E02 (foo)" or "MovieTitle(year)"
#$OriginalExt = original file extension  eg "mpg"
#$NewShowName = Successfully resolved show name
#$ChanID = ChannelID
#$ProgramID= The Program IDentification information found in the MythTV DB
#$ShowStartTime = begin recording time
#$ShowCategory = category like children or sports also specifies Movie in SydFTA data
#$m2kProgramIDCheck = "SH" for SHow or sports - "MV" for MoVie - "EP" for EPisode
#$Plot = Plot
#$Stars = Stars
#$FileBaseName = name of the file to be moved without ext
#$XMLTVGrabber = your guide data type
#$ProgramIDType= Generic episode with no data, Movie, or Series With Episode Data
#$Zap2itSeriesID= Zap2it ID with SH, MV or EP stripped
#$MyUserName = name of user running myth2kodi
#$SafeShowName = title of show after showTranslations formatted for filesystem use

####EPISODES AND GENERIC SHOWS####
#$OriginalAirDate = original air date  Generic programming will be the first episode ever, for episodes it will be the first aired date
#$EpisodeSubtitle = Subtitle or EPisode Name

#####EPISODES####
#$Exx = Episode Number or "Movie" in case of a movie
#$Sxx = Season number or blank in case of movie
#$SeriesID = TheTVDB series ID
#$TvDbTime = current tvdb time
#$LastUpdatedTVDB = last updated time from TheTVDB (for Episodes only others will be blank)
# = tvdb order numbering

####MOVIES####
#$MovieAirDate = the original year the movie aired

############################## END USER JOBS ###################################




################################################################################
#################### ADEPT PERSONNEL ONLY BEYOND THIS POINT ####################
################################################################################

######################### BEGIN FUNCTION DEFINITIONS ###########################
TraditionalNamingConventions(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Format Episodes showname=show name Sxx=season number Exx=episode number EpisodeSubtitle=episode name
  if [[ -n "$Exx" && "$Exx" != "E" ]]; then
    Debug "Naming as episode"
    ShowFileName="$NewShowName $Sxx$Exx ($EpisodeSubtitle)"
  #Format Movies
  elif [ "$m2kProgramIDCheck" = "MV" ]; then
    Debug "Naming as movie"
    Exx="Movie"
    MoveDir="$PrimaryMovieDir"
    #TODO: If adding a year then we really want original release date so the Kodi metadata lookup works reliably.
    if [[ -n "$MovieAirDate" ]]; then
      Warn "${FUNCNAME[0]}() Currently forcing bypass of adding MovieAirDate to Movie file names."
      ShowFileName="$NewShowName" # ShowFileName="$NewShowName ($MovieAirDate)"
    else
      ShowFileName="$NewShowName"
    fi
  #Format generic Shows
  else
    Debug "Naming as generic show"
    Exx="Generic"
    MoveDir="$PrimaryShowDir"
    ShowFileName="$ShowName S0E0 ($EpisodeSubtitle Recorded $datehour on $ChanID)"
    RequiresNFO=1
    [[ "$m2kProgramIDCheck" = "EP" ]] && RequiresDoover=1
  fi
  Inform "Set file name as: $ShowFileName"
}

CategoricNamingConventions(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Method1 - use airdate for season
  if [[ "${OriginalAirDate:0:4}" != "0000" && -n "${OriginalAirDate:0:4}" && "$UseMethod2" != "1" ]]; then
    EventYear="${OriginalAirDate:0:4}"
    Sxx="$EventYear"
    EventMonthDay="$(echo "${OriginalAirDate:5:5}" | tr -d "-" | sed 's/0*//')"
    Exx="$EventMonthDay"
    [[ -z "$NewShowName" ]] && NewShowName="$ShowName"
  else #Flag failure of Method1
    testedmethod1=0
  fi
  #Slight further testing of Method1 results
  if [[ -n "$EventMonthDay" ]] && ((EventYear > 1900)) && ((EventMonthDay > 0)); then
    testedmethod1=1
  else
    testedmethod1=0
  fi

  #Method2 -
  if [ "$testedmethod1" != "1" ]; then
    if [[ "${ShowStartTime:0:4}" != 0000 && -n "${ShowStartTime:0:4}" ]] ; then
      EventYear="${ShowStartTime:0:4}"
      EventMonthDay="$(echo "${ShowStartTime:5:5}" | tr -d "-" | sed 's/0*//')"
    fi
    Exx="$EventMonthDay"
    Sxx="$EventYear"
    #Check validity of Method2
  fi

  #Test final result and assign ShowFileName
  ((EventYear > 1900)) && ((EventMonthDay > 0)) && ShowFileName="$NewShowName S$EventYear""E$EventMonthDay ($InputSubtitle Recorded $datehour)"

  RequiresNFO=1
  HasSxxExx=1
  Inform "Set file name as: $ShowFileName"
}

######DAILY REPORT#####
#This function reports all shows processed based on date
dailyreport(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [ "$DailyReport" = "Enabled" ]; then
    [[ ! -d "$m2kdir/DailyReport" ]] && mkdir "$m2kdir/DailyReport"
    local reporttime=$(date +%T)
    Inform "Writing to DailyReport file: ${Today}"
    printf '%s\n' "$reporttime - $ShowFileName" >> "$m2kdir/DailyReport/${Today}"
  fi
  return 0
}

#####CHECK PERMISSIONS#####
#CheckPermissions by writing a small file then deleting it, checking along the way.
#CheckPermissions takes file size, free space on dir, and the dir, then it performs
#tests. The result will be $TMoveDirWritable as a 1 or a 0 for writable or not.
#$1=filesize $2=freespace $3=folder to check
#TODO: Consider making this function return non-zero on error
checkPermissions(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  DebugCont "Called with $# arguments"
  local -i i=0 ; local var ; for var in "$@"; do ((++i)) ; DebugCont "arg $i = ${var}" ; done
  #set Test variable to 0.  It will be a 1 if everything passes.
  TMoveDirWritable=0
  if [[ -n "$2" ]]; then
    if [[ -n "$1" ]]; then
      if [ -d "$3" ]; then
        if (($1 < $2)); then
          printf '%s\n' "Testing write permission on $3" > "$3/arbitraryfile.ext"
          if [ -f "$3/arbitraryfile.ext" ] ; then
            if [ -s "$3/arbitraryfile.ext" ]; then
              rm -f "$3/arbitraryfile.ext"
              if [[ ! -f "$3/arbitraryfile.ext" ]]; then TMoveDirWritable=1; else TMoveDirWritable=0; fi
            else
              TMoveDirWritable=0
              Err "${FUNCNAME[0]}() CREATED $3/arbitraryfile.ext BUT COULD NOT WRITE DATA INTO THE FILE"
            fi
          else
            Err "${FUNCNAME[0]}() $MyUserName TRIED TO WRITE TO $3 --FAILED"
            [[ ! -r "$3" ]] && Inform "QUICK FIX: sudo chmod a+r \"$3\""
            [[ ! -w "$3" ]] && Inform "QUICK FIX: sudo chmod a+w \"$3\""
            Inform "QUICK FIX: sudo chown $MyUserName \"$3\""
          fi
        elif [ -z "$2" ] || (( $1 >= $2 )); then
          TMoveDirWritable=0
          Err "${FUNCNAME[0]}() INSUFFICIENT FREE SPACE ON $3"
          Inform "QUICK FIX: Remove unnecessary files"
        fi
      else
        Err "${FUNCNAME[0]}() FOLDER DOES NOT EXIST: $3"
        Inform "QUICK FIX: mkdir \"$3\""
      fi
    else
      Warn "${FUNCNAME[0]}() COULD NOT READ FILESIZE ON $InputPath"
      Inform "QUICK FIX: chmod -R 775 \"$InputPath\""
    fi
  else
    Warn "${FUNCNAME[0]}() COULD NOT READ FREE SPACE on \"$3\""
    Inform "QUICK FIX: mkdir \"$3\" ; chmod -R 775 \"$3\""
  fi

  return 0
}

#####COMSKIP FILES#####
#Function GenComSkip creates a comskip.txt file from MythTV database
#information for use by Kodi.
GenComSkip(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local -i Counter=0
  local StartData
  local StopData
  #Set up comskip file
  #TODO: can we make the "FILE PROCESSING COMPLETE" line more descriptive???
  #TODO: the rm is sort of redundant, also consider using the multiple print format: {...} > "$m2kdir/markupframes.txt"
  [[ -f "$m2kdir/markupframes.txt" ]] && rm -f "$m2kdir/markupframes.txt"
  printf '%s\n' "FILE PROCESSING COMPLETE" >  "$m2kdir"/markupframes.txt
  printf '%s\n' "------------------------" >> "$m2kdir"/markupframes.txt
  #TODO: markupstop.txt is being read into line and then subsequently ignored...
  while read -r line ; do
    ((++Counter))
    StartData=$(sed -n "$Counter"p "$m2kdir/markupstart.txt")
    StopData=$(sed -n "$Counter"p "$m2kdir/markupstop.txt")
    if [ ! -z "$StopData" ]; then
      printf '%s\n' "$StartData $StopData" >> "$m2kdir"/markupframes.txt
      CommercialMarkup="Created"
      Debug "COMMERCIAL DATA START:$StartData STOP:$StopData"
    fi
  done <"$m2kdir/markupstop.txt"
  return 0
}

#####KODI COMMUNICATIONS#####
#This function Automates communication with KODI
KODIAutomate(){
  #TODO: there must be a better way to do this neatly than using eval...
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local data=""
  #Send notification to KODI, Update Library, Clean Library
  if [[ "$KODINotify" = "Enabled" || "$KODIUpdate" = "Enabled" || "$KODIClean" = "Enabled" ]]; then
    Inform 'COMMUNICATING WITH KODI INSTANCES...'
    #SEE: http://kodi.wiki/view/HOW-TO:Remotely_update_library and 'man curl'
    local curlPOST='curl --silent --max-time 8 --connect-timeout 5 -H "Content-Type: application/json;" --data-binary'
    for KODIIP in "${KODIIPs[@]}" ; do
      Inform "SENDING REQUESTED COMMANDS TO: $KODIIP"
      #Request Kodi update its library
      if [[ "$KODIUpdate" = "Enabled" && "$m2kScanMode" != "True" ]] ; then
        data=\''{"jsonrpc": "2.0", "method": "VideoLibrary.Scan", "id": "myth2kodi"}'\'
        eval "$curlPOST $data http://$KODIIP/jsonrpc" > /dev/null 2>&1
        Inform 'SENT: VideoLibrary.Scan request.'
      fi
      #Send a message to Kodi that a new show has been added
      if [ "$KODINotify" = "Enabled" ] ; then
        data=\''{"jsonrpc": "2.0", 
                 "method": "GUI.ShowNotification",
                 "params": {"title": "myth2kodi added", "message": "'$ShowName'"},
                 "id": "myth2kodi"}'\'
        eval "$curlPOST $data http://$KODIIP/jsonrpc" > /dev/null 2>&1
        Inform "SENT: GUI.ShowNotification for $ShowName"
      fi
      #TODO: Requesting Kodi to Clean its Library doesn't seem to make sense in the same
      #  context as Update & Notify, that is, cleaning after adding a new show makes
      #  little sense and has the potential danger of completely clearing out Kodi's
      #  Library information if for example a network drive is temporarily unavailable
      #  due to a network problem. It does, however, seem to make sense to request
      #  Kodi to run Clean of its Library after myth2kodi runs undo, doover, or any
      #  other means of removing or renaming a file of which Kodi is aware... Perhaps
      #  split KODIAutomate() into KodiNewShow() and KodiCleanup()...
      #Request Kodi remove any no-longer reachable files from its library. 
      if [[ "$KODIClean" = "Enabled" && "$m2kScanMode" != "True" ]] ; then
        data=\''{"jsonrpc": "2.0", "method": "VideoLibrary.Clean", "id": "myth2kodi"}'\'
        eval "$curlPOST $data http://$KODIIP/jsonrpc" > /dev/null 2>&1
        Inform 'SENT: VideoLibrary.Clean request.'
      fi
    done
  else
    Debug 'No communication with Kodi requested.'
  fi
  return 0
}

#####GENERATE RSS ENTRY#####
#This function generates an RSS feed for use on the web server. This can be used
#in /home/<kodi-user>/.kodi/userdata/RssFeeds.xml, replace or add to the default
#feeds with:
#  <feed updateinterval="30">http://[youripaddress]/myth2kodi-rss/rss.xml</feed>
#SAK: You'll probably need a webserver enabled for this to work, if it's only on
#     the local machine then just use:
#  <feed updateinterval="30">/var/www/myth2kodi-rss/rss.xml</feed>
#Big thanks to barney_1!
#TODO: return codes from this function aren't captured...
generaterss(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #user settings:
  #TODO: this probably should be a setting at the top of file...
  local rssDir="/var/www/myth2kodi-rss"
  ((RSSmaxItems == 0)) && RSSmaxItems=8  #maximum number of items to read into the feed

  #script settings
  OLDrssFile="rss.xml"
  TEMPrssFile="rss.temp"

  #HTML line break code for nice formatting
  lineBreak="&lt;br /&gt;"

  #test if rssFile directory is writeable
  if [ ! -w "$rssDir" ]; then
    Err "${FUNCNAME[0]}() RSS generation failed: Directory not writeable ($rssDir)"
    return 5
  fi

  #test if rssFile is writeable
  if [ -e "$rssDir/$OLDrssFile" ] && [ ! -w "$rssDir/$OLDrssFile" ]; then
    Err "${FUNCNAME[0]}() RSS generation failed: File exists but is not writeable: $rssDir/$OLDrssFile"
    return 6
  fi

  #Setup the rss file
  {
    echo -e '<?xml version="1.0" encoding="ISO-8859-1" ?>'
    echo -e '<rss version="2.0">'
    echo -e '<channel>'
    echo -e '\t<title>Recently added by myth2kodi</title>'
    echo -e '\t<link>http://kodi.tv</link>'
    echo -e '\t<description>myth2kodi Daily Report Information</description>'
  } > "$rssDir/$TEMPrssFile"

  #TODO: Need to make the call to ifconfig more portable, maybe just revert to straight call and add /sbin to librarians path.
  #  The below assumed the first inet addr was the correct one, but that can lead to the loopback, using m2 and removing 127.0.0.1 avoids this problem,
  #  though it's probably better to just set myip in the configuration at top of file
  which /sbin/ifconfig >/dev/null && myip="$(/sbin/ifconfig | grep 'inet addr' -m2 | cut -d: -f2 | awk '{ print $1}' | grep -v "127.0.0.1")"
  rssEpisodeSubtitle="$(sed s/"&"/"&amp;"/g <<< "$EpisodeSubtitle")"
  rssNewShowName="$(sed s/"&"/"&amp;"/g <<< "$NewShowName")"
  rssPlot="$(sed s/"&"/"&amp;"/g <<< "$Plot")"
  mythicalGUID="$(echo "$MyUserName@$myip""$MoveDir/$ShowFileName.$OriginalExt" | sed s/"("/"%28"/g | sed s/")"/"%29"/g | sed s/"\ "/"%20"/g)" #TODO: Check that "\ " in the final sed is correct and shouldn't just be " "

  #write current recording information to first item.
  {
    echo -e "\t\t<item>"
    echo -e "\t\t\t<title>$rssNewShowName $Sxx$Exx $rssEpisodeSubtitle</title>"
  } >> "$rssDir/$TEMPrssFile"
  if [ "$m2kProgramIDCheck" = "EP" ]; then
    echo -e "\t\t\t<link>http://www.thetvdb.com/?tab=series&amp;id=$SeriesID</link>" >> "$rssDir/$TEMPrssFile"
  elif [ "$m2kProgramIDCheck" = "MV" ]; then
    echo -e "\t\t\t<link>http://www.imdb.com/search/title?release_date=,$MovieAirDate&amp;title=$ShowName&amp;title_type=feature</link>" >> "$rssDir/$TEMPrssFile"
  else
    tvdotcomshowname="$(sed s/" "/"%20"/g <<< "$ShowName")"
    echo -e "\t\t\t<link>http://www.tv.com/search.php?type=11&amp;stype=all&amp;tag=search%3Bfrontdoor&amp;qs=$tvdotcomshowname </link>" >> "$rssDir/$TEMPrssFile"
  fi
  {
    echo -e "\t\t\t<guid>sftp://$mythicalGUID</guid>"
    echo -e "\t\t\t<pubDate>$(date -R -d "$ShowStartTime")</pubDate>"
    echo -e "\t\t\t<description>"
    echo -e "\t\t\t\tEpisode Title: $rssEpisodeSubtitle$lineBreak"
    echo -e "\t\t\t\tProgram: $rssNewShowName$lineBreak"
    echo -e "\t\t\t\tSeason: $Sxx$lineBreak"
    echo -e "\t\t\t\tEpisode: $Exx$lineBreak$lineBreak"
    echo -e "\t\t\t\tPlot: $rssPlot"
    echo -e "\t\t\t</description>"
    echo -e "\t\t</item>"
  } >> "$rssDir/$TEMPrssFile"

  #If there is an old RSS file
  if [ -e "$rssDir/$OLDrssFile" ]; then
    #test for number of </item> tags using grep
    RssItemCount=$(grep -c "</item>" "$rssDir/$OLDrssFile")

    #if $RSSmaxItems is greater than this number
    if ((RSSmaxItems > RssItemCount)); then
      #set a variable to track this number + 1 for the new entry
      itemLimit=$((RssItemCount+1))
    else
      #set tracking variable to $RSSmaxItems
      itemLimit=$RSSmaxItems
    fi

    #get the line number for the first <item> tag
    firstLine="$(grep -n -m 1 "<item>" "$rssDir/$OLDrssFile" | cut -d ":" -f 1)"
    #get the line number for our last </item> tag
    lastLine="$(grep -n -m $((itemLimit-1)) "</item>" "$rssDir/$OLDrssFile" | tail -n1 | cut -d ":" -f 1)"
    #set IFS to use line break as a delineator
    local IFS=$'\n'
    #Read in the old RSS file
    declare -a old_rss_data=( $(cat "$rssDir/$OLDrssFile") )
    #arrayLen=${#old_rss_data[@]}
    #iterate through the array
    for index in $(seq $((firstLine-1)) $((lastLine-1))) ; do
      echo "${old_rss_data[$index]}" >> "$rssDir/$TEMPrssFile"
    done
    #copy line from old to new
    #if copied line is </item>
      #increment counter
    #if counter is great than tracking variable
      #break
  fi

  #close the file.
  {
    echo -e '</channel>'
    echo -e '</rss>'
  } >> "$rssDir/$TEMPrssFile"

  #move fully formed temp file on top of the old file
  mv "$rssDir/$TEMPrssFile" "$rssDir/$OLDrssFile"
  Inform "RSS ENTRY SUCCESSFULLY CREATED: $rssDir/$OLDrssFile"
  return 0
}

#####MOVE MODE LOGGING#####
#This function provides logging for move mode
#TODO: This function doesn't really provide logging so much as it creates the undo and doover entries for this recording...
performLoggingForMoveMode(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Create undo and doover file if not present, the first command of these scripts is to remove themselves.
  test ! -f "$m2kdir/undo.sh"   && echo "rm -f \"$m2kdir/undo.sh\""   >> "$m2kdir/undo.sh"   && chmod 666 "$m2kdir/undo.sh"
  test ! -f "$m2kdir/doover.sh" && echo "rm -f \"$m2kdir/doover.sh\"" >> "$m2kdir/doover.sh" && chmod 666 "$m2kdir/doover.sh"

  if [ "$SYMLINK" != "Disabled" ] ; then
    { #Write undo.sh line that removes link:
      printf '%s'    "test -L \"$InputPath\" &&"
      printf ' %s'   "rm -f \"$InputPath\" &&"
      printf ' %s\n' "echo removed \"$InputPath\""
    } >> "$m2kdir/undo.sh"

    { #Write undo.sh line that moves already-moved-file back to original location:
      printf '%s'    "test -f \"$MoveDir/$ShowFileName.$OriginalExt\" &&"
      printf ' %s'   "mv \"$MoveDir/$ShowFileName.$OriginalExt\" \"$InputPath\" &&"
      printf ' %s\n' "echo moved \"$MoveDir/$ShowFileName.$OriginalExt\" to \"$InputPath\""
    } >> "$m2kdir/undo.sh"
  fi

  if [ "$SYMLINK" = "MOVE" ]; then
    if [ "$RequiresDoover" = "1" ] ; then
      { #Write doover.sh line that removes link:
        printf '%s'    "test -f \"$MoveDir/$ShowFileName.$OriginalExt\" &&"
        printf ' %s'   "test -L \"$InputPath\" &&"
        printf ' %s'   "rm -f \"$InputPath\" &&"
        printf ' %s\n' "echo Moving \"$InputPath\" to original location"
      } >> "$m2kdir/doover.sh"
      
      { #Write doover.sh line that moves already-moved-file back to original location:
        printf '%s'    "test -f \"$MoveDir/$ShowFileName.$OriginalExt\" &&"
        printf ' %s\n' "mv \"$MoveDir/$ShowFileName.$OriginalExt\" '$InputPath'"
      } >> "$m2kdir/doover.sh"

      #Write doover.sh line that recalls myth2kodi:
      printf '%s\n' "myth2kodi \"$InputPath\" \"$InputTitle\" \"$InputSubtitle\"" >> "$m2kdir/doover.sh"
    fi
  fi
}

#####LINK MODE LOGGING#####
#This function performs logging for link mode
performLoggingForLinkMode(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Create undo and doover file if not present, the first command of these scripts is to remove themselves.
  test ! -f "$m2kdir/undo.sh"   && echo "rm -f \"$m2kdir/undo.sh\""   >> "$m2kdir/undo.sh"   && chmod 666 "$m2kdir/undo.sh"
  test ! -f "$m2kdir/doover.sh" && echo "rm -f \"$m2kdir/doover.sh\"" >> "$m2kdir/doover.sh" && chmod 666 "$m2kdir/doover.sh"

  if [ "$RequiresDoover" = "1" ]; then
    { #Write doover.sh lines that remove a link to a recording then reruns myth2kodi
      printf '%s\n' "test -L \"$MoveDir/$ShowFileName.$OriginalExt\" && rm -f \"$MoveDir/$ShowFileName.$OriginalExt\""
      printf '%s\n' "myth2kodi \"$InputPath\" \"$InputTitle\" \"$InputSubtitle\""
    } >> "$m2kdir/doover.sh"
  fi
  echo "test -L \"$MoveDir/$ShowFileName.$OriginalExt\" && rm -f \"$MoveDir/$ShowFileName.$OriginalExt\"" >> "$m2kdir/undo.sh"
  echo "'$MoveDir/$ShowFileName.$OriginalExt'" "'$InputPath'" >> "$m2kdir"/created.tracking
}

writeJobToDooverQue(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  DebugCont "Called with $# arguments"
  local -i i=0 ; local var ; for var in "$@"; do ((++i)) ; DebugCont "arg $i = ${var}" ; done
  DebugCont "m2kdir: $m2kdir"
  DebugCont "InputPath: $InputPath"
  Inform "Writing job to doover queue: $m2kdir/doover.sh"
  [[ ! -f "$m2kdir/doover.sh" ]] && printf '%s\n' "rm -f \"$m2kdir/doover.sh\"" >> "$m2kdir/doover.sh" && chmod 666 "$m2kdir/doover.sh"
  [[ -n "$InputPath" ]] && echo "myth2kodi '$1' '$2' '$3'" >> "$m2kdir"/doover.sh
}

doFailSafeMode(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Warn "FAILSAFE FLAG WAS SET CHECK PERMISSIONS AND FOLDERS"
  Warn "PERMISSION ERROR OR DRIVE FULL"
  if [ "$FailSafeMode" = "Enabled" ]; then
    Warn "ATTEMPTING SYMLINK TO FAILSAFE DIR: $FailSafeDir"
    Inform "FailSafe link name set as: $FailSafeDir/$ShowFileName.$OriginalExt"
    ln -s "$InputPath" "$FailSafeDir/$ShowFileName.$OriginalExt"
    if [ -f "$FailSafeDir/$ShowFileName.$OriginalExt" ]; then
      Inform "FAILSAFE MODE COMPLETE: SYMLINK CREATED"
    else
      Err "FAILSAFE MODE FAILURE CHECK PERMISSIONS AND FREE SPACE IN $FailSafeDir"
    fi
  else
    Inform "FailSafeMode Disabled, we won't try and make a link as a fallback."
  fi

  [[ "$Notify" = "Enabled" ]] && sudo -u "$NotifyUserName" "$binpath"/m2k_notify "myth2kodi FAILSAFE" "FAILSAFE mode active See $LogFile for more information" error
}

dbselect(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  DebugCont "Called with $# arguments"
  local -i i=0 ; local var ; for var in "$@"; do ((++i)) ; DebugCont "arg $i = ${var}" ; done
  mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; SELECT $1 FROM recorded WHERE basename LIKE '$InputFileBasename' ; "
}

#####MYTHTV DATABASE#####
#This function gathers information from the MythTV database for use in the program
GetMythTVDatabase(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  DebugCont "m2kdir: $m2kdir"
  DebugCont "InputFileBasename: $InputFileBasename"
  DebugCont "MySQLMythDb: $MySQLMythDb"
  DebugCont "MySQLuser: $MySQLuser"
  DebugCont "MySQLpass: $MySQLpass"
  DebugCont "InputTitle: $InputTitle"
  DebugCont "InputSubtitle: $InputSubtitle"
  DebugCont "InputSeasonNum: $InputSeasonNum"
  DebugCont "InputEpisodeNum: $InputEpisodeNum"

  #Obtain MythTV Database Information
  Inform "Accessing MythTV DataBase Using mysql Commands:"
  Inform "Attempting to pull database information on $InputPath"
  #NOTE: Previously the info retrieved from the MythTV-DB was also passed through additional sed commands
  #  where "/", the thing being selected (eg "title") and occasionally spaces were stripped. At least for
  #  mythtv 0.27.5 and "mysql  Ver 15.1 Distrib 10.0.22-MariaDB, for Linux (x86_64) using readline 5.2",
  #  these seem to be redundant. In case there was an old DB schema or older mysql version that required
  #  this additional processing, if the below isn't working for you try adding the additional sed commands
  #  back in, something like: 
  #    | sed s/"\/"/""/g | sed -n "2p" | sed s/"chanid"/""/g | sed s/" "/""/g
  #  to replace the 
  #    | sed -n "2p"
  #  found below. Finally, if any of the above processing turns out to be SchedulesDirect specific then it
  #  should be moved to ProcessSchedulesDirect().
  [[ -z "$InputTitle" ]]      && InputTitle="$(     dbselect title    | sed -n "2p")"
  [[ -z "$InputSubtitle" ]]   && InputSubtitle="$(  dbselect subtitle | sed -n "2p")"
  [[ -z "$InputSeasonNum" ]]  && InputSeasonNum="$( dbselect season   | sed -n "2p")"
  [[ -z "$InputEpisodeNum" ]] && InputEpisodeNum="$(dbselect episode  | sed -n "2p")"
  ChanID="$(         dbselect chanid          | sed -n "2p")"
  ProgramID="$(      dbselect programid       | sed -n "2p")"
  LocalSeriesID="$(  dbselect seriesid        | sed -n "2p")"
  Plot="$(           dbselect description     | sed -n "2p")"
  Stars="$(          dbselect stars           | sed -n "2p")"
  ShowStartTime="$(  dbselect starttime       | sed -n "2p")"
  ShowCategory="$(   dbselect category        | sed -n "2p")"
  StorageGroup="$(   dbselect storagegroup    | sed -n "2p")"
  OriginalAirDate="$(dbselect originalairdate | sed -n "2p")"
  [[ "$OriginalAirDate" = "0000-00-00" ]] && OriginalAirDate=''

  #TODO: Clean up all the following mysql commands, like we've done for the above.
  #get DataType
  XMLTVGrabber=$(mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select xmltvgrabber from videosource ; " | sed s/"xmltvgrabber"/""/g | sed s/"\/"/""/g | sed -n "2p" | sed s/" "/""/g)
  #get year for movies
  MovieAirDate=$(mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select airdate from recordedprogram where programid like '$ProgramID' and chanid like '$ChanID' ; " | sed s/"\/"/""/g | sed s/"airdate"/""/g | sed -n "2p" | sed s/" "/""/g)
  #Blank year if it is invalid
  if [ ! -z "$MovieAirDate" ] && (( MovieAirDate < 1900 )); then
    MovieAirDate=''
  fi

  #####COMSKIP DATA#####
  #Set up counter, remove old markup data and generate new markup file from markupstart and stop
  if [ "$CommercialMarkup" = "Enabled" ]; then
    #Remove old and generate a comskip Start list
    echo "">"$m2kdir/markupstart.txt"
    mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select mark from recordedmarkup where starttime like '$ShowStartTime' and chanid like '$ChanID' and type like "4" ; " | sed s/"mark"/""/g | sed s/" "/""/g>>"$m2kdir/markupstart.txt"
    #Remove old and generate comskip Stop list
    echo "">"$m2kdir/markupstop.txt"
    mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; select mark from recordedmarkup where starttime like '$ShowStartTime' and chanid like '$ChanID' and type like "5" ; " | sed s/"mark"/""/g | sed s/" "/""/g>>"$m2kdir/markupstop.txt"
    #Combine commercial data into a single comskip file and remove the initial files
    GenComSkip
  fi
  return 0
}

#####UTILIZE PYTHON BINDINGS TO GET MYTHTV DB##### Requires dependency
#TODO: Check functionality of and if necessary clean-up MythDataGrabber
GetMythTvPythonBindings(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  DebugCont "m2kdir: $m2kdir"
  DebugCont "binpath: $binpath"
  DebugCont "InputFileBasename: $InputFileBasename"
  DebugCont "DBPin: $DBPin"
  DebugCont "DBHostName: $DBHostName"
  DebugCont "MySQLMythDb: $MySQLMythDb"
  DebugCont "MySQLuser: $MySQLuser"
  DebugCont "MySQLpass: $MySQLpass"
  DebugCont "InputTitle: $InputTitle"
  DebugCont "InputSubtitle: $InputSubtitle"
  DebugCont "InputSeasonNum: $InputSeasonNum"
  DebugCont "InputEpisodeNum: $InputEpisodeNum"
  Inform "Accessing MythTV DataBase Using PythonBindings:"
  Inform "Attempting to pull database information on $InputPath"
  #make a named pipe for database output
  test ! -p "$m2kdir/mythicalDbOut" && mkfifo "$m2kdir/mythicalDbOut"

  #NOTE: the declare also makes them local, so we'd need to mark them for export
  #      with -x to access them outside of the function, but not sure we want to push them to the environment just for this...
  # declare -a mdb_startdata
  # declare -a mdb_stopdata
  # declare mdb_title
  # declare mdb_subtitle
  # declare mdb_season
  # declare mdb_episode
  # declare mdb_airdate
  # declare mdb_originalairdate
  # declare mdb_storagegroup
  # declare mdb_stars
  # declare mdb_description
  # declare mdb_seriesid
  # declare mdb_programid
  # declare mdb_chanid
  # declare mdb_starttime

  #run the python bindings and output to named pipe
  "$binpath"/MythDataGrabber --filename="$InputFileBasename" \
                             --DBPin="$DBPin"                \
                             --DBHostName="$DBHostName"      \
                             --DBName="$MySQLMythDb"         \
                             --DBUserName="$MySQLuser"       \
                             --DBPassword="$MySQLpass" >"$m2kdir/mythicalDbOut" &
  pythonExitStatus=$?
  if [ "$pythonExitStatus" != "0" ] ; then
    Err "${FUNCNAME[0]}() DATABASE ACCESS ERROR: COULD NOT OBTAIN INFORMATION"
    Debug "Check DBInfo in mythicalSetup, verify file is mythtv file"
  fi

  #read values from named pipe, remove quotes and declare $Variable=$Value
  Debug "Guide data as extracted by: ${FUNCNAME[0]}()"
  while read -r var equals value ; do
    value="$(tr -d \" <<< "$value")"
    #[[ "$equals" = "=" ]] && declare -r "mdb_$var=$value" && DebugCont "mdb_$var$equals$value"
    [[ "$equals" = "=" ]] && declare "$var=$value" && DebugCont "$var$equals$value"
  done < "$m2kdir/mythicalDbOut" > /dev/null 2>&1

  if [ "$CommercialMarkup" = "Enabled" ]; then
    #Output commercial data to initial files
    printf '%s\n' "${startdata[@]}" >"$m2kdir/markupstart.txt"
    printf '%s\n' "${stopdata[@]}"  >"$m2kdir/markupstop.txt"
    #Combine commercial data into a single comskip file and remove the initial files
    GenComSkip
  fi

  #TODO: Consider making all the vars set here readonly "declare -r ", even if that means renaming
  #  and tracking down the various inconsistent uses... NOTE: must do in non-python GetMythTv... as well.
  #GuideTitle InputTitle => Title #Can be Series or Movie or ...
  #GuideSubtitle InputSubtitle ExtractPlotSubtitle SxxExxSubtitle FuzzyPlotSubtitle nlpPlotSubtitle => EpisodeTitle
  #GuideSeasonNum InputSeasonNum LogicSubtitleSeasonNum FuzzySubtitleSeasonNum FuzzyPlotSeasonNum nlpPlotSeasonNum => EpisodeSeasonNum
  #GuideEpisodeNum InputEpisodeNum LogicSubtitleEpisodeNum FuzzySubtitleEpisodeNum FuzzyPlotEpisodeNum nlpPlotEpisodeNum => EpisodeEpisodeNum

  Inform "Setting the following variables based on MythTV-DB guide data:"
  #Import mythtv values into myth2kodi values, don't clobber title, subtitle, season-number, or episode-number.
  [[ -z "$InputTitle" ]]      && InputTitle="$title"        && InformCont "InputTitle=$title"
  [[ -z "$InputSubtitle" ]]   && InputSubtitle="$subtitle"  && InformCont "InputSubtitle=$subtitle"
  [[ -z "$InputSeasonNum" ]]  && InputSeasonNum="$season"   && InformCont "InputSeasonNum=$season"
  [[ -z "$InputEpisodeNum" ]] && InputEpisodeNum="$episode" && InformCont "InputEpisodeNum=$episode"

  #redefine database var names into myth2kodi var names
  MovieAirDate="$airdate"            && InformCont "MovieAirDate=$airdate"
  OriginalAirDate="$originalairdate" && InformCont "OriginalAirDate=$originalairdate"
  ShowCategory="$category"           && InformCont "ShowCategory=$category"
  StorageGroup="$storagegroup"       && InformCont "StorageGroup=$storagegroup"
  Stars="$stars"                     && InformCont "Stars=$stars"
  Plot="$description"                && InformCont "Plot=$description"
  LocalSeriesID="$seriesid"          && InformCont "LocalSeriesID=$seriesid"
  ProgramID="$programid"             && InformCont "ProgramID=$programid"
  ChanID="$chanid"                   && InformCont "ChanID=$chanid"
  ShowStartTime="$starttime"         && InformCont "ShowStartTime=$starttime"

  #cleanup, remove the fifo named pipe
  test -p "$m2kdir/mythicalDbOut" && rm -f "$m2kdir/mythicalDbOut"
}

#####PROCESS DATABASE INFORMATION#####
#Function ProcessSchedulesDirect processes Zap2it/SchedulesDirect/Tribune data for use in the program
ProcessSchedulesDirect(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Inform "Processing MythTV database info as SchedulesDirect."
  #Check for database permissions
  [[ "$ChanID" = "" ]] && Err "%%%% NO DATABASE INFORMATION. CHECK LOGIN/PASS OR FILE %%%%"
  #disqualify invalid movie airdates
  [[ ! -z "$MovieAirDate" ]] && ((MovieAirDate < 1900 )) && MovieAirDate=''

  [[ "$OriginalAirDate" = "None" ]] && OriginalAirDate=""
  [[ "$OriginalAirDate" = "none" ]] && OriginalAirDate=""

  #Get rating from Stars
  rating=$(printf "%0.f" "$Stars")
  [[ "$rating" != "" ]] && let rating=$rating*2
  [[ "$rating" = "" ]] && rating=1

  #Create MV/EP/SH Identification Type from ProgramID
  m2kProgramIDCheck="${ProgramID:0:2}"

  #Extrapolate data from Programid
  test "$m2kProgramIDCheck" = "SH" && ProgramIDType="Generic Episode With No Data"
  test "$m2kProgramIDCheck" = "MV" && ProgramIDType="Movie"
  test "$m2kProgramIDCheck" = "EP" && ProgramIDType="Series With Episode Data"
  test "$m2kProgramIDCheck" = "SP" && ProgramIDType="Sports Programming" && m2kProgramIDCheck=SH

  #account for .0123's in EITonly data type
  ProgramID="$(cut -f1 -d"." <<< "$ProgramID")"

  #Check if database contains enough information to put into doover que
  GoForDoover=0
  test "${x:0:2}" = "EP" && echo woot
  test "$EpisodeSubtitle" != "" && GoForDoover=1

  #Get barebones zap2it series id.
  Zap2itSeriesID=$(echo "$ProgramID" | tr -d MVSHEP | sed 's/0*//' | sed 's/.\{4\}$//')

  #strip needless chars from date
  datehour=$(echo "$ShowStartTime" | tr ":" "." | tr " " "@")
  #get 4 digit year
  seasonyear="${ShowStartTime:0:4}"

  #predefined naming conventions
  if [[ "$ShowCategory" = "Sports event" || "$ShowCategory" = "News" || "$ShowCategory" = "Newsmagazine" ]]; then
    NamingConvention="$ShowCategory"
  fi

  #If news, bypass Categoric naming convention 1
  test NamingConvention="News" && UseMethod2=1

  return 0
}

ExtractSxxExxFromPlot(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  DebugCont "SeasonEpisode: $SeasonEpisode"
  DebugCont "InputSeasonNum: $InputSeasonNum"
  DebugCont "InputEpisodeNum: $InputEpisodeNum"
  DebugCont "Plot: $Plot"
  #TODO: Maybe add warning in the case of 4x4 in case it's not actually an SxxExx
  #If available use the season and episode fields from MythTV database, otherwise,
  #use or attempt to determine $SeasonEpisode
  #extract a season number Sxx and episode number Exx
  #Assumes season and episode numbers in range 1-99
  if [[ -z "$SeasonEpisode" && -z "$InputSeasonNum" && -z "$InputEpisodeNum" ]]; then
    Debug "Searching Plot for season & episode information."
    #Check the Plot field for the SeasonEpisode info, SBS is big on
    #including it in the plot/description field instead of where it belongs
    #The below should work for any of the following forms:
    #S01E42 | (01x42) | s01e42 | 1X2 | S1E4 | (S01Ep42) | (S1Ep42) | 42x1 | (S.01Ep.42) | (S.01,Ep.42) | S1 E42
    SeasonEpisode="$(grep -E -i --only-matching '(s\.?[0-9]?[0-9]\,?\s?(e|ep)\.?[0-9][0-9]?)|([0-9]?[0-9]x[0-9][0-9]?)' <<< "$Plot")"
  fi
  if [[ -n "$InputSeasonNum" && -n "$InputEpisodeNum" ]]; then
    Debug "Using season & episode information from MythTV DB season & episode fields."
    Sxx="$InputSeasonNum"
    Exx="$InputEpisodeNum"
  elif [[ -n "$SeasonEpisode" ]]; then
    Debug "Extracted season & episode information from Plot."
    Sxx="$(echo "$SeasonEpisode" | grep -E -i --only-matching '(s\.?[0-9]?[0-9])|([0-9]?[0-9]x)' | sed 's/s\.\?\|x//I')"
    Exx="$(echo "$SeasonEpisode" | grep -E -i --only-matching '((e|ep)\.?[0-9][0-9]?)|(x[0-9][0-9]?)' | sed 's/\(E\.\?\|Ep\.\?\)\|x//I')"
    #Strip leading zero
    Sxx="${Sxx#0}"
    Exx="${Exx#0}"
  else
    Warn "${FUNCNAME[0]}() No Season & Episode number information is available."
    return 1
  fi
  #Single digit episode and show names are not allowed Ex and Sx replaced with Sxx Exx
  if (( Sxx < 10 )); then Sxx="S0$Sxx"; else Sxx="S$Sxx"; fi
  if (( Exx < 10 )); then Exx="E0$Exx"; else Exx="E$Exx"; fi
  Inform "Found Season ($Sxx) & Episode ($Exx) information."
  return 0
}

RemoveSeasonEpisodeFromPlot(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [[ -n "$SeasonEpisode" ]]; then
    #Check if it's in the leading position and if so, remove it
    local SEstring
    SEstring="$(grep -E -i --only-matching '(\(?s\.?[0-9]?[0-9]\,?\s?(e|ep)\.?[0-9][0-9]?\)?)\s*|(\(?[0-9]?[0-9]x[0-9][0-9]?\)?)\s*' <<< "$Plot")"
    if [[ -n "$SEstring" ]]; then
      Warn "${FUNCNAME[0]}() SeasonEpisode was in the leading position of the Plot field, removing it to simplify subsequent processing."
      Plot="$(sed s/"$SEstring"/""/ <<< "$Plot")"
      #Also remove any left over leading hyphen, colon, or space 
      Plot="$(sed s/^"\s*[-|:]\?\s*"/""/ <<< "$Plot")"
      #Remove any trailing space from the Plot
      Plot="${Plot%%*([[:space:]])}"
    fi
  else
    Debug "SeasonEpisode isn't currently set:"
    DebugCont "So, either it's not there or we haven't extracted it yet, either way, not going to discard it from Plot field."
  fi
}

#Try to extract a subtitle from the plot field (Luv Ya SBS)
ExtractSubtitleFromPlot(){
  #This function works under the assumption that a Subtitle (EpisodeTitle) is prepended to
  #the Plot field of the guide data and that it is separated from the actual plot by either
  #' -' or ':'. This is often the case for FTA guide data from SBS Australia, and occasionally
  #for other Australian stations as well.
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: Allowing for a colon as well as the hyphen here causes problems for the various "NCIS: some other place"
  #TODO: Probably should do things conditionally based on whether or not we actually managed
  #  to extract a Subtitle. And maybe return failure state.
  InputSubtitle="$(grep -E --only-matching '^((((\w+)(.?\s*))|(\&\s*)){1,7})( -|\:)' <<< "$Plot")"
  #if [[ -n "$InputSubtitle" ]]; then
  #Clean off the trailing " -" or ":" that we're using to identify it
  InputSubtitle="$(grep -E --only-matching '(((\w+)(.?\s*))|(\&\s*)){,7}(\w+)' <<< "$InputSubtitle")"
  Inform "Attempt to extract Subtitle from Plot field gave '$InputSubtitle'"
  #TODO: consider calling RemoveSubtitleFromPlot() from here, instead of return 1 below.
  return 0
  #else
    #Inform "No Subtitle extracted from Plot field.
    #return 1
  #fi
}

#Called after ExtractSubtitleFromPlot(), it uses the same logic to...
RemoveSubtitleFromPlot(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: If we extracted a subtitle from Plot variable then remove that text from Plot.
  if [[ -n "$InputSubtitle" ]]; then
    local STstring
    STstring="$(grep -E --only-matching '^((((\w+)(.?\s*))|(\&\s*)){1,7})( -|\:)\s*' <<< "$Plot")"
    if [[ -n "$STstring" ]]; then
      Warn "${FUNCNAME[0]}() Episode subtitle was in the Plot field, removing it to simplify subsequent processing."
      Plot="$(sed s/"$STstring"/""/ <<< "$Plot")"
    fi
  else
    Debug "InputSubtitle isn't currently set, so not going to discard it from Plot field."
  fi
}

#Some Australian channels (ABC, I'm looking at you), put cast info at the end of the Plot. 
RemoveCastFromPlot(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #
  local CastString
  CastString="$(grep -iE --only-matching '\. CAST: ((\w+)(.?\s*)){1,8}$' <<< "$Plot")"
  if [[ -n "$CastString" ]]; then
    Warn "${FUNCNAME[0]}() Plot field appears to contain Cast information, removing it to simplify subsequent processing."
    Debug "Removing: '$CastString' from:"
    DebugCont "$Plot"
    Plot="$(sed s/"$CastString"/"."/ <<< "$Plot")"
  fi
}

#A Process function compatible with Sydney over the air data...
ProcessSydFTA(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Inform "Processing MythTV database info as SydFTA."
  #Check for database permissions
  [[ -z "$ChanID" ]] && Err "IN: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}(). NO DATABASE INFORMATION. CHECK LOGIN/PASS OR FILE"
  #disqualify invalid movie airdates
  [[ -n "$MovieAirDate" ]] && (( MovieAirDate < 1900 )) && MovieAirDate=''

  #We don't use these, but if they're "none" we still want them changed to ""
  [[ "${OriginalAirDate,,}" = "none" ]] && OriginalAirDate=""

  #TODO:#NOTE: Stars field in SydFTA data tends to be empty, consider what to do here.
  #Get rating from Stars
  rating=$(printf "%0.f" "$Stars")
  [[ -n "$rating" ]] && let rating=$rating*2
  [[ -z "$rating" ]] && rating=1

  #TODO: Does this need to be more general, accounting for 00 | S0 | S00 | etc
  #  On the other hand, if it's reliably 0, then remove this and just
  #  change the conditionals to check for 0
  #  ((InputSeasonNum == 0))
  #Default value for season and episode numbers is 0, not $null or ""
  test "$InputSeasonNum" = 0 && InputSeasonNum=''
  test "$InputEpisodeNum" = 0 && InputEpisodeNum=''

  #Current (2016-08) issue from 7flix: description in Subtitle field, all-caps cast in Plot... (Longest actual subtitle I've seen so far is 84)
  #TODO: exclude subtitles longer than some number of characters from being considered as Subtitles.
  #      If we can identify Plot as garbage then replace with long content of Subtitle...
  # if (( $(wc --chars <<< "$InputSubtitle") > 88 )) ; then
  #   PossiblePlot="$InputSubtitle"
  #   Warn "${FUNCNAME[0]}() InputSubtitle field appears to contain Plot information."
  #   Warn "Resetting  InputSubtitle to ''"
  #   InputSubtitle=''
  # fi


  ###The ProgramID field from FTA EPG data in Sydney?Australia? doesn't specify MV/EP/SH,
  ###the Movie specification is "almost-always" found in the Category field of
  ###the MythTV database. So, we'll use that.
  if [ "$ShowCategory" = "Movie" ]; then
    Inform "Guide data for $InputTitle indicates a Movie."
    m2kProgramIDCheck="MV"
    if [[ -n "$InputSubtitle" ]]; then
      Warn "${FUNCNAME[0]}() Guide data indicates that $InputTitle is a Movie, but has an InputSubtitle: $InputSubtitle"
      Warn "Resetting  InputSubtitle to ''"
      InputSubtitle=''
    fi
  else #For now assume that if it's not a Movie it's an episode of a series
    #TODO: For now we mainly/only record Movies and Episodes of TV series,
    #  so, this is an ok approximation, but should look through more EPG data
    #  and determine whether the Category field reliably distinguishes things
    #  like news, sport, etc
    m2kProgramIDCheck="EP"
  fi

  #TODO: Check the SeriesID field in MythTV DB & see if we can make more
  #  sensible use of whatever it contains...

  #If the information is already available, set the Sxx & Exx variables
  if [ "$m2kProgramIDCheck" = "EP" ]; then
    Debug "The MythTV Guide data Plot before we messed with it:"
    DebugCont "$Plot"
    ExtractSxxExxFromPlot
    RemoveSeasonEpisodeFromPlot
    #If we haven't set a Subtitle yet, try and get one from $Plot
    if [[ -z "$InputSubtitle" ]]; then
      ExtractSubtitleFromPlot
      #TODO: Only makes sense to call RemoveSubtitleFromPlot if ExtractSubtitleFromPlot found one.
      RemoveSubtitleFromPlot
    fi
  fi

  #Remove hashtag reference/s from the Plot field #TODO: Will probably need to check and extend this.
  Plot="$(sed s/"\s#\w\{2,16\}"/""/g <<< "$Plot")"
  #And @mentions, at least SBS2 does this '@SBS2'
  Plot="$(sed s/"\s@\w\{2,16\}"/""/g <<< "$Plot")"
  #Some channels, particularly ABC, put cast info in the end of the plot field which can mess up fuzzy Plot matching
  RemoveCastFromPlot

  #Only keep Alpha-numeric characters and the four basic punctuation chars & , . -
  Plot="$(sed -r s'/[^[:alnum:]|^&,.-]/ /'g <<< "$Plot")"

  #Strip the Movie: tag that some stations very helpfully put in the title field...
  if [ "$m2kProgramIDCheck" = "MV" ]; then
    InputTitle="$(sed s/"Movie:\s*"/""/I <<< "$InputTitle")"
  fi

  #TODO: If it's a movie, check Title and Plot for a release year, assuming format (YYYY) seems reasonable.
  #  If we find it, check its between 1942 & ThisYear, then store it and remove it from where we found it,
  #  especially important to remove from Title -- to avoid repetition in NewFileName if we use it to generate that name.

  #Extrapolate data from m2kProgramIDCheck
  test "$m2kProgramIDCheck" = "SH" && ProgramIDType="Generic Episode With No Data"
  test "$m2kProgramIDCheck" = "MV" && ProgramIDType="Movie"
  test "$m2kProgramIDCheck" = "EP" && ProgramIDType="Series With Episode Data"
  test "$m2kProgramIDCheck" = "SP" && ProgramIDType="Sports Programming" && m2kProgramIDCheck=SH

  #FTA stations providing a ProgramID use CRID: https://en.wikipedia.org/wiki/Crid
  #Remove the leading CRID://
  ProgramID="$(sed s/"crid:\/\/"//I <<< "$ProgramID")"
  #Extract the Authority, ie the station broadcasting the show
  ProgramAuthority="$(cut -f1 -d"/" <<< "$ProgramID")"
  #Extract the show specific information, removing the leading /
  ProgramData="$(sed s/$ProgramAuthority"\/"// <<< "$ProgramID")"
  #Populate the ProgramID variable with the ProgramData field of CRID
  ProgramID="$ProgramData"
  #TODO: figure out if anything useful can actually be done with this ProgramID.

  #strip needless chars from date
  datehour="$(echo "$ShowStartTime" | tr ":" "." | tr " " "@")"

  #predefined naming conventions
  [[ "$ShowCategory" =~ ^(Sports event|News|Newsmagazine)$ ]] && NamingConvention="$ShowCategory"

  #If news, bypass Categoric naming convention 1
  test NamingConvention="News" && UseMethod2=1

  return 0
}

#####PROCESS DATABASE INFORMATION#####
####NoLookup is an alternate mode where TheTVDB is not used for lookups
ProcessNoLookup(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Inform "Processing MythTV database info as NoLookup."
  #Check for database permissions
  test "$ChanID" = "" && Err "%%%% NO DATABASE INFORMATION. CHECK LOGIN/PASS OR FILE %%%%"
  #disqualify invalid movie airdates
  [[ -n "$MovieAirDate" ]] && (( MovieAirDate < 1900 )) && MovieAirDate=''

  #Get rating from Stars
  rating=$(printf "%0.f" "$Stars")
  test "$rating" != "" && let rating=$rating*2
  test "$rating" = "" && rating=1

  #Create MV/EP/SH Identification Type from ProgramID
  m2kProgramIDCheck=${ProgramID:0:2}

  #Spoof show as episode to avoid programid
  test "$m2kProgramIDCheck" = "EP" && ProgramIDType="Generic Episode With No Data" && m2kProgramIDCheck="SH"
  #Extrapolate data from Programid
  test "$m2kProgramIDCheck" = "SH" && ProgramIDType="Generic Episode With No Data"
  test "$m2kProgramIDCheck" = "MV" && ProgramIDType="Movie"
  test "$m2kProgramIDCheck" = "SP" && ProgramIDType="Sports Programming" && m2kProgramIDCheck=SH

  #account for .0123's in EITonly data type
  ProgramID=$(cut -f1 -d"." <<< "$ProgramID")

  #This probably isn't necessary, but adding it for the time-being match previous state. #SAK
  Zap2itSeriesID="$LocalSeriesID"

  #strip needless chars from date
  datehour=$(echo "$ShowStartTime" | tr ":" "." | tr " " "@")
  #get 4 digit year
  seasonyear="${ShowStartTime:0:4}"

  #predefined naming conventions
  [[ "$ShowCategory" =~ ^(Sports event|News|Newsmagazine)$ ]] && NamingConvention="$ShowCategory"

  #If news, bypass Categoric naming convention 1
  test NamingConvention="News" && UseMethod2=1

  return 0
}

#####REMOVE ENTRIES FROM LIBRARY#####
#remove mythtv recording's pictures and database entries.  Thanks to barney_1.
DeleteRelevantDatabaseFilesAndPictures(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Make sure we got input arguments and file is valid
  if [ ! -e "$InputPath" ]; then
    #Remove recording entry from mysql database
    Warn "${FUNCNAME[0]}() REMOVING - $FileBaseName - THUMBNAILS - DATABASE ENTRIES"
    mysql -u$MySQLuser -p$MySQLpass -e "use '$MySQLMythDb' ; delete from recorded where basename like '$FileBaseName'; "
    #TODO: Capture return state of mysql command so we can log success/failure.
    #Remove thumbnails
    rm -f "$originaldirname/$FileBaseName".*
  fi
  return 0
}

#####USE AbsoluteEpisodeNumber TO SET SXX AND EXX#####
setSxxAndExxFromAbsoluteEpisodeNumber(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #if line match is obtained, then gather new episode name, Sxx and Exx
  EpisodeSubtitle="$(sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir"/"$NewShowName"/"$NewShowName".actualEname.txt)"

  #gather series and episode names from files created earlier.
  Exx="$(sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir"/"$NewShowName"/"$NewShowName".E.txt)"
  Sxx="$(sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir"/"$NewShowName"/"$NewShowName".S.txt)"
  [[ -n "$Sxx" ]] && SeasonNumber="$Sxx"

  #Single digit episode and show names are not allowed Ex and Sx replaced with Exx Sxx
  if ((Exx < 10)); then Exx="E0$Exx"; else Exx="E$Exx"; fi
  if ((Sxx < 10)); then Sxx="S0$Sxx"; else Sxx="S$Sxx"; fi
  Inform "EPISODE:$EpisodeSubtitle EPISODE NUMBER:$AbsoluteEpisodeNumber $Sxx$Exx WITH CONFIDENCE: $EpisodeConfidenceRating"
}

determineIfDatabaseIsUpToDate(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Return state = 1 means the local database should be updated from TheTVDB
  #Return state = 0 means the local database is up to date with TheTVDB
  #Initialise a default CurrentTimeTVDB
  [[ -z "$CurrentTimeTVDB" ]] && CurrentTimeTVDB=99999999
  #Clean up any old TheTVDB_current.time file
  [[ -f "$m2kdir/$NewShowName/TheTVDB_current.time" ]] && rm -f "$m2kdir/$NewShowName/TheTVDB_current.time"
  #Get current server time
  curl -L -s -m"$Timeout" "http://www.thetvdb.com/api/Updates.php?type=none" > "$m2kdir/$NewShowName/TheTVDB_current.time"

  #Get the time from the file
  if [[ -f "$m2kdir/$NewShowName/TheTVDB_current.time" ]]; then
    CurrentTimeTVDB=$(grep '<Time>' "$m2kdir/$NewShowName/TheTVDB_current.time" | sed s/"<\/\?Time>"/""/g)
  fi

  #If file exist for last updated time, then get value
  if [ -f "$m2kdir/$NewShowName/lastupdated.time" ]; then
    LastUpdatedTVDB=$(cat "$m2kdir/$NewShowName/lastupdated.time")

  #If no last updated time, then assign a never updated value and update now
  elif [ ! -f "$m2kdir/$NewShowName/lastupdated.time" ]; then
    Inform "Seems we've never updated $NewShowName from TheTVDB -- can't find lastupdated.time file."
    LastUpdatedTVDB=42
    return 1
  fi

  #if time server is down, then just update
  ((CurrentTimeTVDB == 99999999)) && Warn "${FUNCNAME[0]}() TheTVDB TIME SERVER WAS DOWN" && return 1

  #Apply Database Update interval to last update time  LastUpdatedTVDB = NextUpdated
  local -i NextUpdate=0
  let NextUpdate=$LastUpdatedTVDB+$UpdateDatabase

  #if episode information is out of date or not created
  if ((CurrentTimeTVDB > NextUpdate)); then
    curl -L -s -m"$Timeout" "http://www.thetvdb.com/api/Updates.php?type=all&time=$LastUpdatedTVDB" >> "$m2kdir/$NewShowName/UpdatesList.txt"
    #TODO: SeriesID isn't being found in UpdatesList for Grey's Anatomy, Marvel's Agents of S.H.I.E.L.D., and possibly others, so the the local data isn't being updated
    if grep -q "$SeriesID" "$m2kdir/$NewShowName/UpdatesList.txt" ; then
      Inform "DATABASE IS OUT OF DATE. NEXT UPDATE $NextUpdate Current $CurrentTimeTVDB"
      return 1
    else
      Inform "DATABASE DOESN'T APPEAR TO BE OUT OF DATE. BUT UNFORTUNATELY WE CURRENTLY HAVE A BUG HERE SO ARE FORCING UPDATE ANYWAY..."
      #return 0
      return 1
    fi
  #Send report to the log if database was not updated.
  elif ((CurrentTimeTVDB <= NextUpdate)); then
    Inform "DATABASE IS MAINTAINED. TIME IS:$CurrentTimeTVDB NEXT UPDATE IS:$NextUpdate"
    return 0
  fi
  #some other condition was present. update anyways.
  return 1
}


#TODO: Add jq to requirements and check for it in Diagnostics
#####GET EPISODE INFORMATION#####
downloadInfoAboutMatchedTitleAndCreateTxtFileTables(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Download information from server
  Inform "Downloading Series: $SeriesID"
  local -i GotNewInformation=0
  local -i ProcessingSuccesful=0
  local TheTVDBShowXML="http://www.thetvdb.com/api/$APIkey/series/$SeriesID/all/$Language.xml"
  local FieldsWeWant="(</?Series>|</?seriesid>|</?Status>|</?lastupdated>|</?Episode>|</?SeasonNumber>|</?EpisodeNumber>|</?EpisodeName>|</?Overview>|</?FirstAired>)"
  curl -L -s -m"$Timeout" "$TheTVDBShowXML" | grep -E "$FieldsWeWant" > "$m2kdir/$NewShowName/$NewShowName.xmlTest"
  [[ $? = 0 ]] && echo "$CurrentTimeTVDB" > "$m2kdir/$NewShowName/lastupdated.time" && chmod 666 "$m2kdir/$NewShowName/lastupdated.time"

  local -i tvmaze_id
  tvmaze_id=$(curl -L -s -m"$Timeout" http://api.tvmaze.com/lookup/shows?thetvdb="$SeriesID" | jq '.id')
  local tvmazeJsonFile="$m2kdir/$NewShowName/${NewShowName}_tvmaze.json"
  # to get the matching tvmaze id, then
  if [[ -n "$tvmaze_id" ]] ; then
    local tvmazeShowJson="http://api.tvmaze.com/shows/$tvmaze_id/episodes"
    [[ -f "$tvmazeJsonFile" ]] && mv "$tvmazeJsonFile" "$m2kdir/$NewShowName/${Today}_${NewShowName}_tvmaze.json"
    curl -L -s -m"$Timeout" "$tvmazeShowJson" > "$tvmazeJsonFile"
  fi

  #Validate that the show has at least one EpisodeName tag and is a valid download before clobbering our old download.
  if grep -q "EpisodeName" "$m2kdir/$NewShowName/$NewShowName.xmlTest"; then
    #Check the new info is actually new, if there was no old info then it must be new.
    if [ -f "$m2kdir/$NewShowName/$NewShowName.xml" ] ; then
      diff "$m2kdir/$NewShowName/$NewShowName.xmlTest" "$m2kdir/$NewShowName/$NewShowName.xml" &> /dev/null
      GotNewInformation=$?  #NOTE: No-diff = 0; diff = 1; error = 2
    else
      GotNewInformation=1
    fi
    if [ "$GotNewInformation" = "1" ] ; then
      #Clear out the old
      Inform "Downloaded new information for $NewShowName"
      Inform 'Cleaning up old information before processing.'
      test -f "$m2kdir/$NewShowName/$NewShowName.xml" && mv "$m2kdir/$NewShowName/$NewShowName.xml" "$m2kdir/$NewShowName/${Today}_$NewShowName.xml"
      mv "$m2kdir/$NewShowName/$NewShowName.xmlTest" "$m2kdir/$NewShowName/$NewShowName.xml"
      test -f "$m2kdir/$NewShowName/$NewShowName.actualEname.txt" && rm -f "$m2kdir/$NewShowName/$NewShowName.actualEname.txt"
      test -f "$m2kdir/$NewShowName/$NewShowName.Ename.txt"       && rm -f "$m2kdir/$NewShowName/$NewShowName.Ename.txt"
      test -f "$m2kdir/$NewShowName/$NewShowName.FAired.txt"      && rm -f "$m2kdir/$NewShowName/$NewShowName.FAired.txt"
      test -f "$m2kdir/$NewShowName/$NewShowName.S.txt"           && rm -f "$m2kdir/$NewShowName/$NewShowName.S.txt"
      test -f "$m2kdir/$NewShowName/$NewShowName.E.txt"           && rm -f "$m2kdir/$NewShowName/$NewShowName.E.txt"
      test -f "$m2kdir/$NewShowName/$NewShowName.Plot.txt"        && rm -f "$m2kdir/$NewShowName/$NewShowName.Plot.txt"

      #create a folder/file "database" Strip XML tags.  Series, Exx and Sxx are separated into different files
      local Ename=""
      local actualEname=""
      local FAired=""
      local SeasonNr=""
      local EpisodeNr=""
      local EpisodeOverview=""
      local -i recordNumber=-1
      Inform "Parsing Downloaded information: $NewShowName.xml"
      while read -r line ; do
        if ((recordNumber < 0)); then
          #TODO:Check for a Status line and if it exists and says Ended then touch
          #  a file called Status.Ended in the $m2kdir/$NewShowName/
          #  directory, then add a check for this before we bother trying to
          #  download information again. Also, use the lastupdated field if present.
          #Skip lines until the end series block tag is found, then start processing the episode info
          [[ "$line" == "</Series>" ]] && recordNumber=0
        elif [[ "$line" == "</Episode>" ]]; then
          (( ++recordNumber ))
          #Write Episode info to files
          Debug "Building Record:$recordNumber -${actualEname}-"
          printf '%s\n' "$actualEname"     >> "$m2kdir/$NewShowName/$NewShowName.actualEname.txt"
          printf '%s\n' "$Ename"           >> "$m2kdir/$NewShowName/$NewShowName.Ename.txt"
          printf '%s\n' "$FAired"          >> "$m2kdir/$NewShowName/$NewShowName.FAired.txt"
          printf '%s\n' "$SeasonNr"        >> "$m2kdir/$NewShowName/$NewShowName.S.txt"
          printf '%s\n' "$EpisodeNr"       >> "$m2kdir/$NewShowName/$NewShowName.E.txt"
          printf '%s\n' "$EpisodeOverview" >> "$m2kdir/$NewShowName/$NewShowName.Plot.txt"
        #Get actual show name
        elif [[ "$line" == "<EpisodeName>"* ]]; then
          line="${line/"</EpisodeName>"/}"
          line="${line/<EpisodeName>/}"
          line="${line//&lt;/}"
          line="${line//&gt;/}"
          line="${line//&quot;/}"
          line="${line//&amp;/&}"
          line="${line//&ndash;/-}"
          actualEname="${line}"
          #Only keep Alpha-numeric characters and the four basic punctuation chars & , . -
          actualEname="$(sed -r s'/[^[:alnum:]|^&,.-]/ /'g <<< "$actualEname")"
          Ename="${actualEname/;*/}" #TODO: This strips everything following the first ";" (semi-colon). Is that intentional because there are sometimes multiple EpisodeNames separated by semi-colons???
          #Only keep Alpha-numeric characters and the four basic punctuation chars & , . -
          Ename="$(sed -r s'/[^[:alnum:]|^&,.-]/ /'g <<< "$Ename")"
        #Get OriginalAirDate
        elif [[ "$line" == "<FirstAired>"* ]]; then
          line="${line/"</FirstAired>"/}"
          line="${line/<FirstAired>/}"
          FAired="$line"
        #Get Season number
        elif [[ "$line" == "<SeasonNumber>"* ]]; then
          line="${line/"</SeasonNumber>"/}"
          line="${line/<SeasonNumber>/}"
          SeasonNr="$line"
        #Get Episode number
        elif [[ "$line" == "<EpisodeNumber>"* ]]; then
          line="${line/"</EpisodeNumber>"/}"
          line="${line/<EpisodeNumber>/}"
          EpisodeNr="$line"
        #Get Episode Overview
        elif [[ "$line" == "<Overview>"* ]]; then
          line="${line/"</Overview>"/}"
          line="${line/<Overview>/}"
          line="${line//&lt;/}"
          line="${line//&gt;/}"
          line="${line//&quot;/}"
          line="${line//&amp;/&}"
          line="${line//&ndash;/-}"
          #Only keep Alpha-numeric characters and the four basic punctuation chars & , . -
          line="$(sed -r s'/[^[:alnum:]|^&,.-]/ /'g <<< "$line")"
          line="$(sed -r s'/\s{2,}/ /'g <<< "$line")"
          #Remove any trailing space
          line="${line%%*([[:space:]])}"
          EpisodeOverview="$line"
        fi
      done < "$m2kdir/$NewShowName/$NewShowName.xml"

      #If we also have a json file from tvmaze, then append that info 
      if [[ -f "$tvmazeJsonFile" ]] ; then
        jq -r '.[] | .name' "$tvmazeJsonFile" >> "$m2kdir/$NewShowName/$NewShowName.actualEname.txt"
        jq -r '.[] | .name' "$tvmazeJsonFile" >> "$m2kdir/$NewShowName/$NewShowName.Ename.txt"
        jq -r '.[] | .season' "$tvmazeJsonFile" >> "$m2kdir/$NewShowName/$NewShowName.S.txt"
        jq -r '.[] | .number' "$tvmazeJsonFile" >> "$m2kdir/$NewShowName/$NewShowName.E.txt"
        local -i EpisodeCount
        EpisodeCount=$(jq -r '.[] | .name' "$tvmazeJsonFile" | wc -l)
        for i in $(seq 0 $((EpisodeCount-1))); do
          jq -r ".[$i] | .summary" "$tvmazeJsonFile" |  tr -d "\n" | sed s/"<\/\?p>"/""/g | sed -r s'/[^[:alnum:]|^&,.-]/ /'g | sed -r s'/\s{2,}/ /'g >> "$m2kdir/$NewShowName/$NewShowName.Plot.txt"
          printf '\n' >> "$m2kdir/$NewShowName/$NewShowName.Plot.txt"
        done
      fi

      chmod 666 "$m2kdir/$NewShowName/$NewShowName".actualEname.txt
      chmod 666 "$m2kdir/$NewShowName/$NewShowName".Ename.txt
      chmod 666 "$m2kdir/$NewShowName/$NewShowName".FAired.txt
      chmod 666 "$m2kdir/$NewShowName/$NewShowName".S.txt
      chmod 666 "$m2kdir/$NewShowName/$NewShowName".E.txt
      chmod 666 "$m2kdir/$NewShowName/$NewShowName".Plot.txt
      ProcessingSuccesful=1

    elif [ "$GotNewInformation" = "2" ]; then
      Err "${FUNCNAME[0]}() UNEXPECTED ERROR comparing new to old information for $NewShowName"
      return 1
    elif [ "$GotNewInformation" = "0" ]; then
      Inform "TheTVDB information for $NewShowName hasn't changed since last download."
      return 0
    fi
  else
    Warn "${FUNCNAME[0]}() COULD NOT DOWNLOAD: $TheTVDBShowXML"
  fi
  #check if files were created and generate message
  if ((ProcessingSuccesful == 1)) ; then
    Inform "LOCAL DATABASE UPDATED: $m2kdir/$NewShowName"
    return 0
  elif [ ! -f "$m2kdir/$NewShowName/$NewShowName.Ename.txt" ]; then
    Err "${FUNCNAME[0]}() PERMISSION ERROR for $m2kdir/$NewShowName"
    return 1
  fi
  return 1
}

#####MATCH ZAP2ITID TO TVDB#####
GetSeriesLineNumberFromTableWithZap2itID(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [ -n "$Zap2itSeriesID" ] ; then
    serieslinenumber=0
    #loop through all show names received by TheTVDB and match Zap2it ID.
    while read -r line ; do
      (( ++serieslinenumber ))
      Info "TESTING FOR ZAP2ITID MATCH:$line $(sed -n "$serieslinenumber"'p' "$m2kdir"/shn.txt)"
      Zap2ItTest="$(echo "$line" | tr -d MVSHEP | sed 's/0*//')"
      if [[ -n "$Zap2itSeriesID" && "$Zap2ItTest" = "$Zap2itSeriesID" ]]; then
        return 0
        break
      fi
    done < "$m2kdir"/zap2it.txt
    return 1
  else
    Warn "${FUNCNAME[0]}() called, with no Zap2itSeriesID"
    return 1
  fi
}

#####FUZZY LOGIC RECOGNITION OF SERIES#####
#This function provides fuzzy logic matching of a show name and returns a seriesid
GetSeriesLineNumberFromTableWithFuzzyLogic(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: Why the restriction to the first 27 characters for matching here???
  serieslinenumber=$(agrep -Byn "${ShowName:0:27}" "$m2kdir/shn.txt" | sed 's/:.*//' | grep -m1 ^)
  #Correct for serieslinenumber = ""
  [[ -z "$serieslinenumber" ]] && serieslinenumber=0

  #Get the seriesid based on the showname
  if ((serieslinenumber > 0)); then
    Debug "Determined serieslinenumber for ShowName: $ShowName"
    return 0
  fi
  Err "${FUNCNAME[0]}() FAILED to determine serieslinenumber for ShowName: $ShowName"
  return 1
}

#####STANDARD TITLE RECOGNITION OF SERIES#####
GetSeriesLineNumberFromTableWithStandardLogic(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  serieslinenumber="$(grep -nix "$ShowName" "$m2kdir/shn.txt" | sed 's/:.*//' | grep -m1 ^)"

  #Correct for serieslinenumber = ""
  [[ -z "$serieslinenumber" ]] && serieslinenumber=0
  #Get the seriesid based on the showname
  if ((serieslinenumber >= 1)); then
    return 0
  fi
  return 1
}

##### RESOLUTION OF MULTIPLE AIRDATE MATCHES #####
#ResolveMultipleAirdateMatches is used in the event of multiple matches on the same airdate
#It resolves a conflict by matching the matched airdate by title.
ResolveMultipleAirdateMatches(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local NewShowBasename="$m2kdir/$NewShowName/$NewShowName"
  #Cleanup from last instance match if required
  ConfidenceReasoning="$ConfidenceReasoning Conflict; Multiple Airdates Detected- Parsed results; Attempted to resolve conflict with Standard Logic:"
  test -f "$NewShowBasename.InstanceEnames.txt"            && rm "$NewShowBasename.InstanceEnames.txt"
  test -f "$NewShowBasename.InstanceFAiredLineNumbers.txt" && rm "$NewShowBasename.InstanceFAiredLineNumbers.txt"
  test -f "$NewShowBasename.InstanceLineNumbers.txt"       && rm "$NewShowBasename.InstanceLineNumbers.txt"
  #Create a list of line numbers which match original airdate
  grep -n "$OriginalAirDate" "$NewShowBasename.FAired.txt" | sed 's/:.*//'>>"$NewShowBasename.InstanceFAiredLineNumbers.txt"
  #Loop through list and create instance matching files
  while read -r line ; do
    echo "$line" >>"$NewShowBasename.InstanceLineNumbers.txt"
    sed -n "$line"'p' "$NewShowBasename.Ename.txt" >> "$NewShowBasename.InstanceEnames.txt"
  done < "$NewShowBasename.InstanceFAiredLineNumbers.txt"

  #get instance line number
  IntermediateEpisodeNumber=$(grep -ni "$EpisodeSubtitle" "$NewShowBasename.InstanceEnames.txt" | grep -m1 ^ | sed 's/:.*//')
  #translate instance line number to actual line number
  if [[ -n "$IntermediateEpisodeNumber" ]]; then
    AbsoluteEpisodeNumber=$(sed -n "$IntermediateEpisodeNumber"'p' "$NewShowBasename.InstanceLineNumbers.txt")
  fi
  if [[ -n "$AbsoluteEpisodeNumber" ]]; then
    ConfidenceReasoning="$ConfidenceReasoning Successful;"
    return 0
  else
    ConfidenceReasoning="$ConfidenceReasoning Failed; Attempted to resolve conflict with Fuzzy Logic:"
    #get instance line number
    IntermediateEpisodeNumber=$(agrep -Byn "${EpisodeSubtitle:0:29}" "$NewShowBasename.InstanceEnames.txt" | grep -m1 ^ | sed 's/:.*//')
    #translate instance line number to actual line number
    if [[ -n "$IntermediateEpisodeNumber" ]]; then
      AbsoluteEpisodeNumber=$(sed -n "$IntermediateEpisodeNumber"'p' "$NewShowBasename.InstanceLineNumbers.txt")
    fi
    if [[ -n "$AbsoluteEpisodeNumber" ]]; then
      ConfidenceReasoning="$ConfidenceReasoning Successful;"
      return 0
    else
      ConfidenceReasoning="$ConfidenceReasoning Failed;"
      return 1
    fi
  fi
  return 1
}

#####CREATE SHOW FOLDER#####
makeShowDirIfNeeded(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [ ! -d "$m2kdir/$NewShowName" ]; then
    mkdir "$m2kdir/$NewShowName"
    chmod 777 "$m2kdir/$NewShowName" #TODO: consider chmod 755
    Inform "Created myth2kodi Database Folder: $m2kdir/$NewShowName"
  fi
}

#####SET THE SERIESID AND SHOW NAME#####
setSeriesIDandNewShowNameBasedOnSeriesLineNumber(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Get the seriesid based on the showname
  SeriesID="$(sed -n "$serieslinenumber"'p' "$m2kdir"/sid.txt | grep -m1 ^)"
  NewShowName="$(sed -n "$serieslinenumber"'p' "$m2kdir"/shn.txt | grep -m1 ^ | sed s/"&amp;"/"\&"/g)"

  #Cleanup files to prevent mismatch next time
  test -f "$m2kdir"/sid.txt && rm -f "$m2kdir"/sid.txt
  test -f "$m2kdir"/shn.txt && rm -f "$m2kdir"/shn.txt
  test -f "$m2kdir"/Zap2it.txt && rm -f "$m2kdir"/Zap2it.txt
}

#####AIRDATE MATCH#####
getAbsoluteEpisodeNumberWithOriginalAirdate(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  AbsoluteEpisodeNumber=""
  if [[ -n "$OriginalAirDate" ]]; then
    AbsoluteEpisodeNumber="$(grep -n "$OriginalAirDate" "$m2kdir/$NewShowName/$NewShowName.FAired.txt" | grep -m1 ^ | sed 's/:.*//')"
  fi
  #Account for original series airdate
  if [[ -n "$AbsoluteEpisodeNumber" ]] && ((AbsoluteEpisodeNumber > 0)); then
    #Account for original show airdate = first air date
    NumberOriginalAirdates=$(grep --count "$OriginalAirDate" "$m2kdir/$NewShowName/$NewShowName.FAired.txt")
    ((NumberOriginalAirdates > 1)) && return 1
    Inform "Absolute Exx NR:$AbsoluteEpisodeNumber BASED ON AIRDATE:$OriginalAirDate"
    return 0
  fi
  return 2
}

#Get the AbsoluteEpisodeNumber corresponding to Sxx and Exx
getAbsoluteEpisodeNumberWithSxxExx(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  DebugCont "AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber"
  DebugCont "NewShowName: $NewShowName"
  DebugCont "Sxx: $Sxx"
  DebugCont "Exx: $Exx"

  AbsoluteEpisodeNumber=""
  local -a AENs
  #Strip the leading "S" and any leading "0" from Sxx
  local Snum=${Sxx#S} ; Snum=${Snum#0}
  #Strip the leading "E" and any leading "0" from Exx
  local Enum=${Exx#E} ; Enum=${Enum#0}
  local SxxAENs
  local ExxAENs
  SxxAENs=$(grep -nix "$Snum" "$m2kdir/$NewShowName/$NewShowName.S.txt" | sed s/:.*//)
  ExxAENs=$(grep -nix "$Enum" "$m2kdir/$NewShowName/$NewShowName.E.txt" | sed s/:.*//)
  #With multiple data sources we can get multiple AENs, just take the first data source:
  AENs=($(sort --numeric-sort <<< "$(comm -12 <(sort <<< "$SxxAENs") <(sort <<< "$ExxAENs"))"))
  AbsoluteEpisodeNumber="${AENs[0]}"
  if [[ -n "$AbsoluteEpisodeNumber" ]] && ((AbsoluteEpisodeNumber > 0)); then
    Inform "Using SxxExx, determined AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber"
    return 0
  fi
  Warn "${FUNCNAME[0]}() Failed to determine AbsoluteEpisodeNumber"
  return 1
}

#TODO: Need to check that additional data source doesn't lead to multiple AEN matches that are then interpreted as faulty due to non-singular identification...
#TODO: Need to clean up redundancy or otherwise refactor this function to make it cleaner...
getAbsoluteEpisodeNumberWithFuzzyPlotMatch(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  DebugCont "AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber"
  DebugCont "NewShowName: $NewShowName"
  DebugCont "Plot: $Plot"
  AbsoluteEpisodeNumber=""
  #set IFS to use line break as a delineator -- necessary for separating multiple agrep matches below.
  local IFS=$'\n'
  local -i PlotLength
  local -a FuzzyPlot=()
  local -a AENguess=()
  local -a cost=()
  #Length of the plot we're trying to match
  PlotLength=$(wc --chars <<< "$Plot")
  DebugCont "PlotLength: $PlotLength"
  #If Plot length is short this really won't work well, so give up #TODO: figure out what length is genuinely too short...
  ((PlotLength<42)) && Warn "${FUNCNAME[0]}() - Plot is too short to attempt fuzzy guess." && return 1
  #Fuzzy guess at plot, prepended with: "AbsoluteEpisodeNumber:cost:"
  FuzzyPlot=($(agrep -ikByns "$Plot" "$m2kdir/$NewShowName/$NewShowName.Plot.txt"))
  [[ -z "${FuzzyPlot[0]}" ]] && Warn "${FUNCNAME[0]}() - No fuzzy match on Plot" && return 1
  #Extract our guessed AbsoluteEpisodeNumber
  AENguess=($(cut -f1 -d":" <<< "$(printf '%s\n' "${FuzzyPlot[@]}")"))
  DebugCont "$( IFS=','; printf '%s' "AbsoluteEpisodeNumber guess: ${AENguess[*]}" )"
  cost=($(cut -f2 -d":" <<< "$(printf '%s\n' "${FuzzyPlot[@]}")"))
  DebugCont "$( IFS=','; printf '%s' "Cost: ${cost[*]}" )"
  local -a MatchedPlot=()
  for (( i = 0; i < ${#AENguess[@]}; i++ )) ; do
    MatchedPlot[i]="$(sed -n "${AENguess[i]}"'p' "$m2kdir"/"$NewShowName"/"$NewShowName".Plot.txt)"
    DebugCont "MatchedPlot $i: ${MatchedPlot[i]}"
  done
  #TODO: Should check that MatchedPlot is longer than PlotLength, which is essentially what we're assuming below.
  #If the cost is greater than a 1/3 of characters in the plot we're trying to match #TODO: figure out the critical ratio here.
  #TODO: Should have this compare across all costs... No, multiple results from agrep only occur for equal costs...
  if (( cost[0] > (PlotLength / 3) )) ; then
    Warn "${FUNCNAME[0]}() - AbsoluteEpisodeNumber guess from full Plot too fuzzy, trying chunked match."
    #Some Plots miss on match simply because the text is reordered or the middle is chopped out,
    #something as simple as chopping up the Plot into 8 word blocks, overlapping by 2-4, and testing
    #the agrep cost for each chunk, if at least a couple of the chunks match with a cost < say 10%
    #then we could be fairly confident that it's actually a matching Plot.
    local -i PlotWords
    PlotWords=$(wc --words <<< "$Plot")
    local chunk=""
    local -i chunck_size=8
    local -i chunk_overlap=4
    local -i numchunks
    numchunks=$((PlotWords/(chunck_size-chunk_overlap)))
    local -i len10per=0
    local -a fuzzychunk=()
    local -a FuzzyChunks=()
    local -a ChunkGuesses=()
    local -a ChunkCosts=()
    local -a ChunkLengths=()
    local -a GoodChunkGuesses=()
    Debug "Attempting chunked fuzzy match."
    DebugCont "PlotWords=$PlotWords"
    DebugCont "chunck_size=$chunck_size"
    DebugCont "chunk_overlap=$chunk_overlap"
    DebugCont "numchunks=$numchunks"
    local -i Counter=0
    for (( i = 0; i < numchunks; i++ )) ; do
      DebugCont "i=$i"
      n=$(((i)*(chunck_size-chunk_overlap)+1))
      DebugCont "n=$n"
      m=$((n+chunck_size-1))
      DebugCont "m=$m"
      chunk="$(cut -d" " -f$n-$m <<< "$Plot")"
      DebugCont "chunk=$chunk"
      ChunkLengths[i]=$(wc --chars <<< "$chunk")
      DebugCont "ChunkLengths[$i]=${ChunkLengths[i]}"
      len10per=$(( ChunkLengths[i] / 10 ))
      fuzzychunk=($(agrep -ikByns "$chunk" "$m2kdir/$NewShowName/$NewShowName.Plot.txt"))
      FuzzyChunks[i]="${fuzzychunk[0]}"
      DebugCont "FuzzyChunks[$i]=${FuzzyChunks[i]}"
      ChunkGuesses[i]=$(cut -f1 -d":" <<< "${FuzzyChunks[i]}")
      DebugCont "ChunkGuesses[$i]=${ChunkGuesses[i]}"
      ChunkCosts[i]=$(cut -f2 -d":" <<< "${FuzzyChunks[i]}")
      DebugCont "ChunkCosts[$i]=${ChunkCosts[i]}"
      ((ChunkCosts[i] < len10per)) && GoodChunkGuesses[Counter]=${ChunkGuesses[i]} && ((++Counter))
    done
    #TODO: This needs to be changed to actually check that they refer to the same episode, 
    #      with multiple data sources the current test is still sufficient but not necessary...
    #If all ChunkGuess with ChunkCost < 10% are the same Absolute Episode Number
    AENguess=($(printf '%s\n' "${GoodChunkGuesses[@]}" | sort -u))
    if (( ${#AENguess[@]} == 1 )) ; then
      AbsoluteEpisodeNumber="${AENguess[0]}"
      Inform "${FUNCNAME[0]}() - Identified AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber using chunked Plot."
      return 0
    elif (( ${#AENguess[@]} > 1 )); then
      Debug "Multiple AbsoluteEpisodeNumber guesses matched plot, confirming they're the same episode before using."
      #If we've identified multiple AbsoluteEpisodeNumbers make sure they refer to the same episode.
      local -a SxxGuesses=()
      local -a ExxGuesses=()
      for (( i = 0; i < ${#AENguess[@]}; i++ )) ; do
        #gather series and episode numbers for each AENguess.
        ExxGuesses[i]="$(sed -n "${AENguess[i]}"'p' "$m2kdir"/"$NewShowName"/"$NewShowName".E.txt)"
        SxxGuesses[i]="$(sed -n "${AENguess[i]}"'p' "$m2kdir"/"$NewShowName"/"$NewShowName".S.txt)"
      done
      local -i uniqExxcount
      local -i uniqSxxcount
      uniqExxcount=$(printf '%s\n' "${ExxGuesses[@]}" | uniq | wc -l)
      uniqSxxcount=$(printf '%s\n' "${SxxGuesses[@]}" | uniq | wc -l)
      if (( uniqSxxcount == 1 )) && (( uniqExxcount == 1 )); then
        #With multiple data sources we can get multiple AENs for the same episode, just take the first:
        AbsoluteEpisodeNumber=$(cut -f1 -d" " <<< "${AENguess[0]}")
        Inform "${FUNCNAME[0]}() - Identified AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber using chunked Plot."
        Debug "$( IFS=','; printf '%s' "${FUNCNAME[0]}() - The following ${#AENguess[@]} AENguesses were identified as the same episode: ${AENguess[*]}." )"
        return 0
      fi
    fi

    Warn "${FUNCNAME[0]}() - Chunked Plot match is still too fuzzy, failed to guess AbsoluteEpisodeNumber."
    return 1
  fi

  #Guess at fuzzy Plot match is probably ok, we'll use it, but first need to confirm multiple results
  if (( ${#AENguess[@]} > 1 )); then
    #If we've identified multiple AbsoluteEpisodeNumbers make sure they refer to the same episode.
    local -a SxxGuesses=()
    local -a ExxGuesses=()
    for (( i = 0; i < ${#AENguess[@]}; i++ )) ; do
      #gather series and episode numbers for each AENguess.
      ExxGuesses[i]="$(sed -n "${AENguess[i]}"'p' "$m2kdir"/"$NewShowName"/"$NewShowName".E.txt)"
      SxxGuesses[i]="$(sed -n "${AENguess[i]}"'p' "$m2kdir"/"$NewShowName"/"$NewShowName".S.txt)"
    done
    local -i uniqExxcount
    local -i uniqSxxcount
    uniqExxcount=$(printf '%s\n' "${ExxGuesses[@]}" | uniq | wc -l)
    uniqSxxcount=$(printf '%s\n' "${SxxGuesses[@]}" | uniq | wc -l)
    if (( uniqSxxcount == 1 )) && (( uniqExxcount == 1 )); then
      #With multiple data sources we can get multiple AENs for the same episode, just take the first:
      AbsoluteEpisodeNumber=$(cut -f1 -d" " <<< "${AENguess[0]}")
      Inform "${FUNCNAME[0]}() - Identified AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber using full Plot."
      Debug "$( IFS=','; printf '%s' "${FUNCNAME[0]}() - The following ${#AENguess[@]} AENguesses were identified as the same episode: ${AENguess[*]}." )"
      return 0
    else
      Warn "${FUNCNAME[0]}() - Fuzzy Plot match is too fuzzy, as we matched two or more different episodes."
      Err "${FUNCNAME[0]}() - This function needs refactoring as bad match on full plot should lead to chunked plot attempt."
      Debug "$( IFS=','; printf '%s' "${FUNCNAME[0]}() - The following ${#AENguess[@]} AENguesses were identified: ${AENguess[*]}." )"
      return 1
    fi
  fi
  AbsoluteEpisodeNumber="${AENguess[0]}"
  Inform "${FUNCNAME[0]}() - Identified AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber using full Plot."
  return 0
}

######STANDARD LOGIC EPISODE MATCH#####
##TODO we need some sort of regex to account for matches like
##'The Office' 'The Delivery, Part 1'   -guide data
##'The Office' 'The Delivery (1)'       -TvDb data
getAbsoluteEpisodeNumberWithStandardLogic(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  AbsoluteEpisodeNumber=""
  AbsoluteEpisodeNumber=$(grep -nix "$EpisodeSubtitle" "$m2kdir/$NewShowName/$NewShowName.Ename.txt" | grep -m1 ^ | sed 's/:.*//')
  if [[ -n "$AbsoluteEpisodeNumber" ]] && ((AbsoluteEpisodeNumber > 0)); then
    return 0
  fi
  return 1
}

######FUZZY LOGIC EPISODE MATCH#####
getAbsoluteEpisodeNumberWithFuzzyLogic(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  AbsoluteEpisodeNumber=""
  AbsoluteEpisodeNumber=$(agrep -Byn "${EpisodeSubtitle:0:29}" "$m2kdir/$NewShowName/$NewShowName.Ename.txt" | grep -m1 ^ | sed 's/:.*//')
  if [[ -n "$AbsoluteEpisodeNumber" ]] && ((AbsoluteEpisodeNumber > 0)); then
    return 0
  fi
  return 1
}

#####SEARCH TheTVDB AND CREATE DATA FILES#####
searchTheTVDBAndReturnTxtFileTables(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local -i NextShow=0
  Inform "SEARCHING www.TheTVDB.com FOR $tvdbshowname"
  #TODO: Instance searching rather then global.  Need to create an instance variable based on time and chanid.
  #Search TheTVDB and return an XML file with results
  curl -L -s -m"$Timeout" "www.thetvdb.com/api/GetSeries.php?seriesname=$tvdbshowname" > "$m2kdir/working.xml"

  #Separate the XML into textual DBs containing SeriesID, ShowName and Zap2it IDs
  grep "<seriesid>" "$m2kdir/working.xml" | sed -e s/"<\/\?seriesid>"//g \
                                                -e s/'&quot;'/'"'/g      \
                                                -e s/"&amp;"/"\&"/g      \
                                                -e s/'&ndash;'/'-'/g     \
                                                -e s/"&lt;"/"<"/g        \
                                                -e s/"&gt;"/">"/g >"$m2kdir/sid.txt"
  grep "<SeriesName>" "$m2kdir/working.xml" | sed -e s/"<\/\?SeriesName>"//g \
                                                  -e s/'&quot;'/'"'/g        \
                                                  -e s/"&amp;"/"\&"/g        \
                                                  -e s/'&ndash;'/'-'/g       \
                                                  -e s/"&lt;"/"<"/g          \
                                                  -e s/"&gt;"/">"/g >"$m2kdir/shn.txt"

  #parse the XML for shows with Zap2ItIDs
  test -f "$m2kdir/zap2it.txt" && rm -f "$m2kdir/zap2it.txt"
  while read -r line ; do
    test "$line" = "<Series>" && NextShow=1
    if [[ "$line" = "</Series>" ]] && ((NextShow==1)); then
      printf '\n' >> "$m2kdir/zap2it.txt"
      NextShow=0
    fi

    if [[ "$line" =~ '<zap2it_id>'* ]] ; then
      echo "$line" | sed -e s/"<\/\?zap2it_id>"//g \
                       -e s/'&quot;'/'"'/g       \
                       -e s/"&amp;"/"\&"/g       \
                       -e s/'&ndash;'/'-'/g      \
                       -e s/"&lt;"/"<"/g         \
                       -e s/"&gt;"/">"/g >> "$m2kdir/zap2it.txt"
      NextShow=0
    fi
  done < "$m2kdir/working.xml"
}

DoTestFileExit(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  [[ -d ./Episodes ]] && [[ ! "$(ls -A ./Episodes)" ]] && rmdir ./Episodes
  [[ -d ./Movies ]]   && [[ ! "$(ls -A ./Movies)" ]]   && rmdir ./Movies
  [[ -d ./Showings ]] && [[ ! "$(ls -A ./Showings)" ]] && rmdir ./Showings
  exit 0
}

updateRunningFuzzyLogicErrorCount(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #additional logging for statistical purposes
  test ! -f "$m2kdir"/FuzzyLogicError.log && echo "0" > "$m2kdir"/FuzzyLogicError.log
  local -i FuzzyLogicError
  FuzzyLogicError="$(cat "$m2kdir"/FuzzyLogicError.log)"
  (( ++FuzzyLogicError ))
  #TODO: pretty sure this rm is redundant.
  rm -f "$m2kdir"/FuzzyLogicError.log
  echo "$FuzzyLogicError" > "$m2kdir"/FuzzyLogicError.log
}

updateRunningTotalMatchesCount(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #additional logging for statistical purposes
  test ! -f "$m2kdir"/TotalEpisodeMatches.log && echo "0" > "$m2kdir"/TotalEpisodeMatches.log
  FuzzyLogicMatches="$(cat "$m2kdir"/TotalEpisodeMatches.log)"
  (( ++FuzzyLogicMatches ))
  #TODO: pretty sure this rm is redundant.
  rm -f "$m2kdir"/TotalEpisodeMatches.log
  echo "$FuzzyLogicMatches" > "$m2kdir"/TotalEpisodeMatches.log
}

#Function DoMythTVPermissionsCheck will check to see if the file is
#owned by mythtv and cause myth2kodi to exit with a descriptive
#message if certain criteria are met.
DoMythTVPermissionsCheck(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  # if no bypass, and file is owned by mythtv, and username is not mythtv
  # and system is set to use mythtv database, and symlink is move
  #TODO: This might not work
  #TODO: Probably should change explicit "mythtv" here to a variable designating
  #  a single authorised librarian, eg Librarian="mythtv", then adding a simple
  #  check of $MyUserName and bailing with an ERROR message if != $Librarian,
  #  this should avoid most/all permission issues.
  if [[ "$InputOption" != "--BypassPermissionsCheck" || -z "$InputOption" && -z "$InputSubtitle" && "$InputTitle" != "--BypassPermissionsCheck" ]]; then
    #TODO: during --scan the find here gets $InputPath "--scan" which obviously doesn't work...
    if [ "$(find "$InputPath" -printf %u)" = "$Librarian" ] && [ "$MyUserName" != "$Librarian" ] && [ "$SYMLINK" = "MOVE" ]; then
      UserName="$USER"
      Err "IN: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
      ErrCont "########################################################################"
      ErrCont "##############################  ERROR  #################################"
      ErrCont "########################################################################"
      ErrCont "USER NAME:$UserName ATTEMPTED TO RENAME A $Librarian OWNED FILE."
      ErrCont "myth2kodi HAS PREVENTED THIS UNAUTHORIZED FILE ACTION."
      ErrCont "THIS IS A SAFETY FEATURE TO PRESERVE FILE PERMISSIONS."
      ErrCont "PLEASE RUN THE FOLLOWING TO SET PROPER PERMISSIONS WHEN RENAMING FILES:"
      ErrCont "    sudo su $Librarian"
      ErrCont "    myth2kodi \"$InputPath\" \"$InputTitle\" \"$InputSubtitle\""
      ErrCont "OR AT YOUR OWN RISK BYPASS THIS CHECK BY ADDING --BypassPermissionsCheck"
      ErrCont "AT THE END OF THE LINE YOU JUST RAN."
      ErrCont ""
      ErrCont "Done."
      ExitJob 'PermissionErrorWhileMoving'
    fi
  fi
}

UserJobOutsideMythTV(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Err ""
  ErrCont "MythTV User Job is only valid when run as a user job by MythTV."
  ErrCont "When outside MythTV call the file directly, EG."
  ErrCont "  myth2kodi /path_to/file.ext"
  ErrCont "--OR when looking up a non database Episode--"
  ErrCont "  myth2kodi /path_to/file.ext \"Title of Show\" \"Subtitle of show\""
  ErrCont "done."
  ExitJob 'GenericUnspecifiedError'
}

DisplayShowWarning(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Inform     "ONLY GENERIC GUIDE DATA WAS SUPPLIED."
  InformCont "TYPE: $ProgramIDType- $InputTitle, $InputSubtitle"
  Warn "%%%%%%%% PROGRAM GUIDE DATA IS NOT COMPLETE %%%%%%%%"
}

DisplayCompletedMoveMessage(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Inform "@@@@@@@@ OPERATION COMPLETE $(date) @@@@@@@@"
  Inform "MOVED: $InputPath"
  Inform "TO: $MoveDir/$ShowFileName.$OriginalExt"
}

DisplayEpiShowMessage(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Warn     "SHOW WAS CONSIDERED AN EPISODE BUT INFORMAITON WAS NOT OBTAINABLE"
  WarnCont "%%%% Please consider helping out and adding to TheTVDB %%%%"
  WarnCont "HANDLING EPISODE AS GENERAL SHOWING & DUMPING INTO --doover USER JOB"
}

FuzzyLogicDoesNotJiveMessage(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Warn     "%%%% AIRDATE MATCH AND FUZZY LOGIC ARE IN DISAGREEMENT %%%%"
  WarnCont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
  WarnCont "%%%%%%%%%% GUIDE DATA AND TVDB DATA DO NOT MATCH %%%%%%%%%%"
  WarnCont "%%%% Possible causes: small variations in episode name %%%%"
  WarnCont "%%%%%%%%%%%%%%%%%%%%% bad guide data %%%%%%%%%%%%%%%%%%%%%%"
  WarnCont "%%%%%%%%%%%%%%%%%%%%% bad tvdb airdate %%%%%%%%%%%%%%%%%%%%"
  WarnCont "%%%%%%%%%%%%%%%%%%%%% bad tvdb episode name %%%%%%%%%%%%%%%"
  WarnCont "%%%%%%%%%%%%%%%%%%%%% bad tvdb zap2it id %%%%%%%%%%%%%%%%%%"
  WarnCont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
  Inform "Setting LogLevel=3 (Debug) DUE TO AIRDATE/FUZZY-LOGIC DISAGREEMENT."
  LogLevel=3 #Enable debug level logging
}

StandardLogicDoesNotJiveMessage(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Warn     "%% AIRDATE MATCH AND STANDARD LOGIC ARE IN DISAGREEMENT. %%"
  WarnCont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
  WarnCont "%%%%%%%%%%% GUIDE DATA AND TVDB DATA DO NOT MATCH %%%%%%%%%"
  WarnCont "%%%% Possible causes: small variations in episode name %%%%"
  WarnCont "%%%%%%%%%%%%%%%%%%%%% bad guide data %%%%%%%%%%%%%%%%%%%%%%"
  WarnCont "%%%%%%%%%%%%%%%%%%%%% bad tvdb airdate %%%%%%%%%%%%%%%%%%%%"
  WarnCont "%%%%%%%%%%%%%%%%%%%%% bad tvdb episode name %%%%%%%%%%%%%%%"
  WarnCont "%%%%%%%%%%%%%%%%%%%%% bad tvdb zap2it id %%%%%%%%%%%%%%%%%%"
  WarnCont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
  Inform "Setting LogLevel=3 (Debug) DUE TO AIRDATE/STANDARD-LOGIC DISAGREEMENT."
  LogLevel=3 #Enable debug level logging
}

InvalidFileErrorMessage(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Err     "%%%%%%%%%%%%%%%%%%%%%%%% OPERATION FAILED %%%%%%%%%%%%%%%%%%%%%%%%%%%%"
  ErrCont "%%%% INPUT FILE NAME NON EXISTANT CHECK FILE NAME AND PERMISSIONS %%%%"
  ErrCont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
}

tvDbIsIncomplete(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Err     "%% OPERATION FAILED, INFORMATION COULD NOT BE OBTAINED %%"
  ErrCont "%% TheTVDB information is incomplete for $InputTitle, ${InputSubtitle}."
  ErrCont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
  ErrCont "%% Please consider helping out and adding to TheTVDB %%"
  ErrCont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
  ErrCont "TO PROCESS THIS FILE & PREVENT THIS ERROR IN THE FUTURE, ENABLE HANDLING OF UNRECOGNIZED SHOWS."
  local errtype="myth2kodi Error"
  local errmsg="Could not obtain information from server about: $InputTitle. TheTVDB is incomplete"
  if [ "$Notify" = "Enabled" ] ; then
    sudo -u "$NotifyUserName" "$binpath"/m2k_notify "$errtype" "$errmsg" web-browser
  fi
}

Wrote0LengthFile(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Err "%%%% OPERATION FAILED: WROTE 0 LENGTH FILE %%%%"
  local errtype="myth2kodi Failure"
  local errmsg="$ShowFileName could not be moved to $MoveDir"
  if [ "$Notify" = "Enabled" ] ; then
    sudo -u "$NotifyUserName" "$binpath"/m2k_notify "$errtype" "$errmsg" stop
  fi
}

PermissionErrorWhileMoving(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Err "%%%% OPERATION FAILED: PERMISSION ERROR WHILE MOVING $ShowFileName %%%%"
  local errtype="myth2kodi Failure"
  local errmsg="$ShowFileName could not be moved to $MoveDir"
  if [ "$Notify" = "Enabled" ] ; then
    sudo -u "$NotifyUserName" "$binpath"/m2k_notify "$errtype" "$errmsg" stop
  fi
}

SymlinkNotCreated(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Err "%%%% OPERATION FAILED: LINK PERMISSION ERROR: SYMLINK NOT CREATED %%%%"
  ErrCont "PERMISSION ERROR OR FILE SYSTEM DOES NOT SUPPORT SYMLINKS: $MoveDir"
  local errtype="myth2kodi Error"
  local errmsg="Failure while creating link. Check permissions"
  if [ "$Notify" = "Enabled" ] ; then
    sudo -u "$NotifyUserName" "$binpath"/m2k_notify "$errtype" "$errmsg" stop
  fi
}

#####GENERIC UNSPECIFIED ERROR#####
#TODO: Use consistent naming for message only functions, eg prepend or append  Msg
#This function provides an error message on generic errors
genericUnspecifiedError(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Err  "%%%% OPERATION FAILED: genericUnspecifiedError %%%%"
  ErrCont "NO MATCH FOUND.  TROUBLESHOOTING: Check TheTVDB TO SEE IF $InputTitle EXISTS."
  ErrCont "CHECK EPISODE NAME $InputSubtitle. CHECK INTERNET CONNECTION. CHECK API KEY."
  ErrCont "NOT ENOUGH INFORMATION PULLED FROM DATABASE TO IDENTIFY FILE AS MOVIE OR EPISODE"
  ErrCont "CHECK www.TheTVDB.com  RUN myth2kodi LINK COMMAND PROMPT."
  ErrCont "FOR MORE INFORMATION SEE http://kodi.wiki/index.php?title=mythicalLibrarian" #TODO: If I ever make this public, remember to make a thread.
  ErrCont "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
}

MaintenanceWarning(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local yesorno=""
  Inform "  --You have entered Maintenance mode."
  InformCont "  myth2kodi will perform maintenance on it's records."
  InformCont "  Please ensure that All network attached storage and removable"
  InformCont "  storage drives are connected and mounted properly before continuing"
  read -r -n1 -p "Would you like myth2kodi to conduct a scan? y/(n)>" yesorno
  printf '\n'
  if [ "$yesorno" != "y" ]; then
    Inform "You must press 'y' to continue"
    return 1
  fi
  return 0
}

determinePrimaryOrAlternateFolderUsage(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Command line, no database Episodes: Determine where File will fit
  FailSafeState=0
  [[ -z "$m2kProgramIDCheck" && "$MoveDirWritable" != "1" ]] && MoveDir="$AlternateMoveDir"
  [[ -z "$m2kProgramIDCheck" && "$MoveDirWritable" != "1" && "$AlternateMoveDirWritable" != "1" ]] && FailSafeState=1

  #Episode handling: Determine where File will fit
  [[ "$m2kProgramIDCheck" = "EP" && "$MoveDirWritable" != "1" ]] && MoveDir="$AlternateMoveDir"
  [[ "$m2kProgramIDCheck" = "EP" && "$MoveDirWritable" != "1" && "$AlternateMoveDirWritable" != "1" ]] && FailSafeState=1

  #Movie handling: Determine where file will fit
  [[ "$m2kProgramIDCheck" = "MV" && "$PrimaryMovieDirWritable" != "1" ]] && PrimaryMovieDir="$AlternateMoveDir"
  [[ "$m2kProgramIDCheck" = "MV" && "$PrimaryMovieDirWritable" != "1" && "$AlternateMovieDirWritable" != "1" ]] && FailSafeState=1

  #Show Handling: Determining Where File will fit
  [[ "$m2kProgramIDCheck" = "SH" && "$PrimaryShowDirWritable" != "1" ]] && PrimaryShowDir="$AlternateShowDir"
  [[ "$m2kProgramIDCheck" = "SH" && "$PrimaryShowDirWritable" != "1" && "$AlternateShowDirWritable" != "1" ]] && FailSafeState=1
}

##### MAKE DIRECTORY TO MOVE RECORDING TO IF NECESSARY #####
MakeShowDir(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  DebugCont "NewShowName: $NewShowName"
  DebugCont "MoveDir: $MoveDir"
  DebugCont "SeasonNumber: $SeasonNumber"
  DebugCont "Notify: $Notify"
  DebugCont "NotifyUserName: $NotifyUserName"
  DebugCont "FailSafeDir: $FailSafeDir"

  #If specified, make $MoveDir = $MoveDir/show name
  if [[ -n "$NewShowName" ]]; then
    MoveDir="$MoveDir/$NewShowName"
    if [ ! -d "$MoveDir" ]; then
      Inform "CREATING SERIES FOLDER: $MoveDir"
      echo "$MoveDir">>"$m2kdir"/dir.tracking
      mkdir "$MoveDir"
      chmod 775 "$MoveDir"
    fi

    #Make the Season folder if it is applicable and does not exist
    if [[ -n "$SeasonNumber" ]]; then
      MoveDir="$MoveDir/Season $SeasonNumber"
      if [ ! -d "$MoveDir" ]; then
        Inform "CREATING SEASON FOLDER: $MoveDir"
        mkdir "$MoveDir"
        chmod 775 "$MoveDir"
        echo "$MoveDir">>"$m2kdir"/dir.tracking
      fi
    fi
  fi

  #Error message if folder was not created
  if [ ! -d "$MoveDir" ]; then
    Err "COULD NOT CREATE $MoveDir"
    ErrCont "##################################################"
    ErrCont "######## FAILSAFE MODE HAS BEEN ACTIVATED ########"
    ErrCont "##################################################"
    if [ "$Notify" = "Enabled" ]; then
      sudo -u "$NotifyUserName" "$binpath"/m2k_notify "myth2kodi error" "failsafe mode activated."  error
    fi
    SYMLINK=LINK
    MoveDir="$FailSafeDir"
    FailSafeState=1
    Warn "Recordings processed in FAILSAFE MODE will be added to the doover queue."
    RequiresDoover=1
    Inform "FailSafe MOVE DIRECTORY SET AS: $MoveDir"
    return 1
  else
    Inform "MOVE DIRECTORY SET AS: $MoveDir"
    return 0
  fi
}

#####USE ORIGINAL DIR#####
#If TargetPathIsInputPath is set, then this changes MoveDir to original dir.
setTargetFolderAsInputPathFolder(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #For directory names: No trailing / is accepted eg. "~/videos" not "~/videos/"
  #MoveDir is the folder which myth2kodi will move the file.
  MoveDir="$originaldirname/Episodes"
  test ! -d "$MoveDir" && mkdir "$MoveDir"
  #AlternateMoveDir will act as a secondary MoveDir if the primary MoveDir fails.
  AlternateMoveDir="$originaldirname/Episodes"
  test ! -d "$AlternateMoveDir" && mkdir "$AlternateMoveDir"
  #Primary Movie Dir. myth2kodi will attempt to move to this dir first.
  PrimaryMovieDir="$originaldirname/Movies"
  test ! -d "$PrimaryMovieDir" && mkdir "$PrimaryMovieDir"
  #AlternateMovieDir will act as a Secondary move dir if the primary move dir fails.
  AlternateMovieDir="$originaldirname/Movies"
  test ! -d "$AlternateMovieDir" && mkdir "$AlternateMovieDir"
  #PrimaryShowDir is where generic episodes will be placed.
  PrimaryShowDir="$originaldirname/Showings"
  test ! -d "$PrimaryShowDir" && mkdir "$PrimaryShowDir"
  #AlternateShowDir will act as a Secondary Show Dir if the primary show dir fails.
  AlternateShowDir="$originaldirname/Showings"
  test ! -d "$AlternateShowDir" && mkdir "$AlternateShowDir"
}

#####GENERATE tvshow.nfo#####
#Generates folder tvshow.nfo file
#TODO: review this function, specifically, tvshow.nfo Vs $ShowFileName.nfo
GenerateTVShowNFO(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  test -f "$MoveDir/tvshow.nfo" && rm -f "$MoveDir/tvshow.nfo"
  echo -e "<tvshow>">>"$MoveDir"/tvshow.nfo
  echo -e "\t<title>$NewShowName</title>">>"$MoveDir/tvshow.nfo"
  if [[ -n "$SeriesID" ]]; then
    echo -e "\t<episodeguide>http://www.thetvdb.com/api/$APIkey/series/$SeriesID/all/$Language.xml</episodeguide>">>"$MoveDir/tvshow.nfo"
  else
    echo -e "\t<episodeguide></episodeguide>">>"$MoveDir/$ShowFileName.nfo"
  fi
  echo -e "</tvshow>">>"$MoveDir/tvshow.nfo"
  return 0
}

#####GENERATE NFO FILE#####
#Create an NFO file based upon extracted information
GenerateEpisodeNFO(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  test -f "$MoveDir/$ShowFileName.nfo" && rm -f "$MoveDir/$ShowFileName.nfo"
  #SAK-REPLACED BELOW, SEE http://forum.kodi.tv/showthread.php?tid=65644&page=65&highlight=json
  #echo -e "<tvshow>">>"$MoveDir/$ShowFileName.nfo"
  echo -e "<episodedetails>">>"$MoveDir/$ShowFileName.nfo"

  if [[ -z "$NamingConvention" ]]; then
    if [ "$GoForDoover" = "1" ]; then
      echo -e "\t<title>$EpisodeSubtitle Recorded $datehour -Episode in --doover Que</title>">>"$MoveDir/$ShowFileName.nfo"
    else
      echo -e "\t<title>$EpisodeSubtitle Recorded $datehour -Showing</title>">>"$MoveDir/$ShowFileName.nfo"
    fi
  else
    echo -e "\t<title>$EpisodeSubtitle Recorded $datehour -Categoric</title>">>"$MoveDir/$ShowFileName.nfo"
  fi

  {
    echo -e "\t\t<rating>$rating</rating>"
    echo -e "\t<Plot>$Plot</Plot>"
    echo -e "\t<genre>$ShowCategory</genre>"
  } >> "$MoveDir/$ShowFileName.nfo"

  if [ "$HasSxxExx" = "1" ] ; then
    {
        echo -e "\t<season>$Sxx</season>"
        echo -e "\t<episode>$Exx</episode>"
    } >> "$MoveDir/$ShowFileName.nfo"
  else
    {
      echo -e "\t<season>0</season>"
      echo -e "\t<episode>0</episode>"
    } >> "$MoveDir/$ShowFileName.nfo"
  fi
  #SAK-REPLACED BELOW, SEE http://forum.kodi.tv/showthread.php?tid=65644&page=65&highlight=json
  #echo -e "</tvshow>">>"$MoveDir/$ShowFileName.nfo"
  echo -e "</episodedetails>">>"$MoveDir/$ShowFileName.nfo"
  echo "'$MoveDir/$ShowFileName.nfo'" "'$MoveDir/$ShowFileName.$OriginalExt'">>"$m2kdir"/created.tracking
  return 0
}

##### IGNORE LIST #####
ignoreList(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local ignoreTest=""
  #Test if the title is in the titleIgnore file
  if [ -f "$m2kdir/titleIgnore" ]; then
    ignoreTest="$(grep "$InputTitle" "$m2kdir/titleIgnore")"
    if [ "$InputTitle" = "$ignoreTest" ]; then
      ExitJob 'titleIgnore'
    fi
  fi
  #Test if the Category is in the categoricIgnore file
  if [ -f "$m2kdir/categoricIgnore" ]; then
    ignoreTest="$(grep "$ShowCategory" "$m2kdir/categoricIgnore")"
    if [ "$ShowCategory" = "$ignoreTest" ]; then
      ExitJob 'categoricIgnore'
    fi
  fi
  return 0
}

#####SHOW TRANSLATIONS HANDLING#####
#Get show translations if the $m2kdir/showTranslations file exists.
#The show title will be replaced by the one in the user created showTranslations file
ShowTranslations(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [[ -f "$m2kdir"/showTranslations && -n "$ShowName" ]]; then
    showtranslation="$(grep "$ShowName = " "$m2kdir/showTranslations" | sed s/"$ShowName = "/""/g)"
    if [[ -n "$showtranslation" ]]; then
      ShowName="$showtranslation"
      Inform "USER TRANSLATION: $InputTitle = $ShowName"
    elif [[ -z "$showtranslation" ]]; then
      showtranslation="Inactive"
    fi
  fi
  return 0
}

#####MAINTENANCE ROUTINE#####
#TODO: Need to go through this function line-by-line and make sure it behaves as expected in a do-no-harm sort of way...
#DoMaintenance loops through all logged files and checks if their parent is there.  If no parent, then file is deleted.
DoMaintenance(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Inform "PERFORMING MAINTENANCE ROUTINE..."
  #check for interrupted undo jobs
  [[ -f "$m2kdir/undo.lock" && ! -f "$m2kdir/undo.sh" ]] && mv "$m2kdir/undo.lock" "$m2kdir/undo.sh"

  #Check and make doover.sh and undo.sh if it does not exist
  test ! -f "$m2kdir/doover.sh" && echo "rm -f \"$m2kdir/doover.sh\"" > "$m2kdir/doover.sh" && chmod 666 "$m2kdir/doover.sh"
  test ! -f "$m2kdir/undo.sh"   && echo "rm -f \"$m2kdir/undo.sh\""   > "$m2kdir/undo.sh"   && chmod 666 "$m2kdir/undo.sh"

  #Check for commskip (.txt) and .nfo files listed in created.tracking and
  #remove them if their associated "main" file (.mpg) is missing.
  if [ "$CommercialMarkupCleanup" = "Enabled" ] && [ -f "$m2kdir/created.tracking" ]; then
    local -i Counter=0
    Inform "PERFORMING CLEANUP OF ORPHANED SUPPORT FILES."
    local SupportFile=""
    while read -r line ; do
      (( ++Counter ))
      #TODO: Figure out the purpose of redirect to stderr and trailing 5 spaces before converting to new messaging mechanism...
      #echo -ne "File record $Counter: ${SupportFile:0:20}     \n" 1>&2
      SupportFile="$(cut -d"'" -f2 <<< "$line")"
      Debug "File record $Counter: ${SupportFile}"
      MainFile="$(cut -d"'" -f4 <<< "$line")"
      Debug "File record $Counter: ${MainFile}"
      ls "$MainFile" > /dev/null 2>&1
      if [ "$?" != "0" ]; then
        if [ -d "$(dirname "$SupportFile")" ]; then
          Inform "REMOVING ORPHAN FILE: $SupportFile"
          rm -f "$SupportFile"
        else
          Warn "${FUNCNAME[0]}() FOLDER DISCONNECTED: $SupportFile"
          if [ "$removedead" != "1" ] ; then
            echo "$line" >> "$m2kdir/created.tracking2"
          else
            Inform "REMOVING FROM FUTURE SEARCHES: $line"
          fi
        fi
      else
        echo "$line" >> "$m2kdir/created.tracking2"
      fi
    done <"$m2kdir/created.tracking"
    test -f "$m2kdir/created.tracking" && rm -f "$m2kdir/created.tracking"
    test -f "$m2kdir/created.tracking2" && mv "$m2kdir/created.tracking2" "$m2kdir/created.tracking"
  fi

  #Check if folders are empty and remove dir if needed and it was created by myth2kodi
  if [ "$DirTracking" = "Enabled" ] && [ -f "$m2kdir/dir.tracking" ]; then
    while read -r line ; do
      (( ++Counter ))
      #TODO: Figure out the purpose of redirect to stderr and trailing 5 spaces before converting to new messaging mechanism...
      #echo -ne "Folder record $Counter: ${DirToCheckCheck:0:20}    \n" 1>&2
      DirToCheck="$line"
      Debug "Folder record $Counter: ${DirToCheck}"
      if [ -d "$DirToCheck" ]; then
        #TODO: the "ls ... | grep"  stuff below seems a bit random, reconsider how to achieve the desired goal here...
        #[[ $(find "$line" -maxdepth 0 -type d -empty 2>/dev/null) ]] && echo "is empty"
        #See also, find option -exec  find "$line" -maxdepth 0 -type d -empty -exec rmdir {} \;
        DirToCheckCheck=$(ls "$line" | sed s/"tvshow.nfo"/""/g | grep -m1 ^)
        [[ -z "$DirToCheckCheck" ]] && DirToCheckCheck=$(ls "$line" | sed s/"tvshow.nfo"/""/g | grep -m2 ^)
        if [[ -z "$DirToCheckCheck" ]]; then
          Inform "REMOVING ORPHAN FOLDER: $line"
          test -f "$line/tvshow.nfo" && rm -f "$line/tvshow.nfo"
          rmdir "$line"
        elif [[ -n "$DirToCheckCheck" ]]; then
          DebugCont "Continuing to track folder record $Counter, it contains, at least: ${DirToCheckCheck}"
          echo "$DirToCheck" >> "$m2kdir/dir.tracking2"
        fi
      elif [ ! -d "$DirToCheck" ]; then
        echo "$DirToCheck" >> "$m2kdir/dir.tracking2"
      fi
    done < "$m2kdir"/dir.tracking
    rm -f "$m2kdir/dir.tracking"
    test -f "$m2kdir/dir.tracking2" && mv "$m2kdir/dir.tracking2" "$m2kdir/dir.tracking"
  fi

  #TODO: this need to be rethought given the cleaner way we now deal with myth2kodi database directories.
  #cleanse myth2kodi database folders if in --maintenance mode
  #TODO: Consider making a m2kCleanse function that removes all but the N most recent local show databases.
  #      Should also remove all but the M most recent compressed LogFiles
  #      Also add an associated --cleanse command line switch.
  if [ "$removedead" = "1" ]; then
    test -f "$m2kdir/cleanup" && rm -f "$m2kdir/cleanup"
    ls -A -1 "$m2kdir" > "$m2kdir/cleanup"

    while read -r line ; do
      (( ++Counter ))
      Debug "Cleansing myth2kodi Database:$Counter ${folderToCheck}"
      #echo -ne "Cleansing myth2kodi Database:$Counter ${folderToCheck:0:20}    \n" 1>&2
      folderToCheck="$m2kdir/$line"
      if [ -d "$folderToCheck" ]; then
        #TODO: Check we haven't added new dirs that need protecting...
        if [ "$folderToCheck" != "$m2kdir/DailyReport" ] &&  [ "$folderToCheck" != "$m2kdir/mythicalSetup" ]; then
          Inform "Removing myth2kodi database directory: $folderToCheck"
          rm -Rf "$folderToCheck"
        fi
      fi
    done < "$m2kdir/cleanup"
    rm -f "$m2kdir/cleanup"
  fi
  test ! -d "$m2kdir/mythicalSetup" && mkdir "$m2kdir/mythicalSetup"
  Inform "MAINTENANCE ROUTINE COMPLETE."
  return 0
}

ScanUsageMsg(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Log the input arg ($1) as an ERROR message and append usage for --scan to the log.
  Err "$1"
  ErrCont '  usage: myth2kodi --scan "ext" "/path/to/folder"'
  ErrCont '  example: myth2kodi --scan "mpg" "/home/mythtv/videos"'
}

#####SCAN MODE#####
#TODO: Need to go through this function line-by-line and make sure it can be run without causing damage.
#This function will scan a folder and process the entire library
m2kScan(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local yesorno=""
  DoMythTVPermissionsCheck
  #Map myth2kodi input variables to local variables for our current purpose.
  local checkext="$InputTitle"
  local scanpath="$InputSubtitle"
  Debug "Running ${FUNCNAME[0]}() on $checkext files in $scanpath"
  #Do some basic checks before we get started.
  if [ "$UID" = "0" ] || [ "$USER" = "root" ]; then
    #SAK: my fault
    Warn     "${FUNCNAME[0]}()"
    WarnCont "myth2kodi has detected that you are (or were previously)"
    WarnCont "running as a privileged user.  This may lead to permission"
    WarnCont "contamination of normally unprivileged files."
    WarnCont "Do not run this command with sudo."
    read -r -p "Possible permission contamination. Continue anyway? yes/(no)" yesorno
    printf '\n'
    #Default to safety, ie do nothing and return with status 1.
    [[ -z "$yesorno" ]] && yesorno="no"
    if [[ "$yesorno" != "yes" ]] ; then
      Debug "Type 'yes' to force the scan to continue, aborting."
      return 1
    fi
    Warn "Continuation forced by $MyUserName, despite possible permission contamination."
  fi
  if [[ -z "$checkext" ]]; then
    ScanUsageMsg 'Cannot process blank file extensions.'
    return 1
  elif [ "${checkext:0:1}" = "." ]; then
    ScanUsageMsg 'Please do not prepend a "." to the file extension.'
    return 1
  elif [[ -z "$scanpath" ]]; then
    ScanUsageMsg 'Please supply a path'
    return 1
  elif [ ! -d "$scanpath" ]; then
    ScanUsageMsg "This folder does not exist: $scanpath"
    return 1
  elif [ "${scanpath:0:1}" != "/" ]; then
    ScanUsageMsg 'Please specify the full path to the file'
    return 1
  fi

  Warn "--You have entered scan Mode."
  WarnCont "myth2kodi will conduct a scan of the folder:"
  WarnCont "  $scanpath"
  WarnCont "searching for file types: $checkext. Each file will be processed"
  WarnCont "through myth2kodi. This mode will only work when database access"
  WarnCont "is functional."
  WarnCont "Please scan a single file to test myth2kodi before running in"
  WarnCont "scan mode. That is, use the following form to test operation:"
  WarnCont "  myth2kodi '/path/to/file.ext'"
  WarnCont "In scan mode, myth2kodi will first run the doovers to prevent"
  WarnCont "clobbering and creation of unnecessary links."
  WarnCont "All myth2kodi operations can be reversed using the following command:"
  WarnCont "  sudo myth2kodi --undo"
  Warn "Data loss can occur if this operation is interrupted."
  read -r -n1 -p "  Would you like myth2kodi to conduct a scan? y/(n)>" yesorno
  printf '\n'
  #Default to safety, ie do nothing.
  [[ -z "$yesorno" ]] && yesorno="n"
  if [ "$yesorno" = "y" ]; then
    #Explicitly call DoMaintenance() here as it's blocked in subsequent calls to myth2kodi from scan mode.
    DoMaintenance
    myth2kodi --doover
    Debug "Creating a temporary scan file: $m2kdir/scan.temp"
    ls -1 "$scanpath"/*."$checkext" > "$m2kdir/scan.temp"
    Inform "Scanning $scanpath for $checkext files"
    while read -r line ; do
      Debug "Attempting to envoke myth2kodi on $line"
      if [ "$InputOption" = "--BypassPermissionsCheck" ]; then
        Warn "${FUNCNAME[0]}() Running myth2kodi with --BypassPermissionsCheck option."
        [[ ! -L "$line" && ! -S "$line" && ! -d "$line" ]] && myth2kodi "$line" "--BypassPermissionsCheck"
      else
        [[ ! -L "$line" && ! -S "$line" && ! -d "$line" ]] && myth2kodi "$line"
      fi
    done<"$m2kdir/scan.temp"
    Debug "Removing the temporary scan file: $m2kdir/scan.temp"
    rm -f "$m2kdir/scan.temp"
    return 0
  else
    Warn "You must press 'y' to scan, aborting."
    return 0
  fi
  return 1
}

setGroupPermissions(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Add read and write permissions for the group to the moved recording.
  chmod g=rw "$MoveDir/$ShowFileName.$OriginalExt"
  #TODO:#NOTE: the above command is slightly inconsistent with the comment as = also implies removal of any unmentioned attributes.
}

dirSummary(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  InformCont "A summary table of writeable directories: 0='NOT WRITEABLE' ; 1='WRITEABLE'"
  InformCont "$(printf '%-18s|%-5s|%-12s|%s\n'    "USER SETTING"      "FLAG"                       "Free Space"                              "Folder name"       )"
  InformCont "$(printf '%-18s|  %s  | %10s | %s\n' "m2kdir"            "$WorkingDirWritable"        "$((WorkingDirFreeSpace/1024)) MB"        "$m2kdir"           )"
  InformCont "$(printf '%-18s|  %s  | %10s | %s\n' "MoveDir"           "$MoveDirWritable"           "$((MoveDirFreeSpace/1024)) MB"           "$MoveDir"          )"
  InformCont "$(printf '%-18s|  %s  | %10s | %s\n' "AlternateMoveDir"  "$AlternateMoveDirWritable"  "$((AlternateMoveDirFreeSpace/1024)) MB"  "$AlternateMoveDir" )"
  if [ "$Database" = "Enabled" ]; then
    InformCont "$(printf '%-18s|  %s  | %10s | %s\n' "PrimaryMovieDir"   "$PrimaryMovieDirWritable"   "$((PrimaryMovieDirFreeSpace/1024)) MB"   "$PrimaryMovieDir"  )"
    InformCont "$(printf '%-18s|  %s  | %10s | %s\n' "AlternateMovieDir" "$AlternateMovieDirWritable" "$((AlternateMovieDirFreeSpace/1024)) MB" "$AlternateMovieDir")"
    InformCont "$(printf '%-18s|  %s  | %10s | %s\n' "PrimaryShowDir"    "$PrimaryShowDirWritable"    "$((PrimaryShowDirFreeSpace/1024)) MB"    "$PrimaryShowDir"   )"
    InformCont "$(printf '%-18s|  %s  | %10s | %s\n' "AlternateShowDir"  "$AlternateShowDirWritable"  "$((AlternateShowDirFreeSpace/1024)) MB"  "$AlternateShowDir" )"
  fi
}

OperationSummary(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  Inform "################ OPERATION SUMMARY ################"
  InformCont "JOB: myth2kodi '$m2karg1' '$m2karg2' '$m2karg3' '$m2karg4'"
  InformCont "m2kVersion=$m2kVersion-"
  InformCont "MyUserName=$MyUserName-"
  InformCont "InputPath=$InputPath-"
  InformCont "InputTitle=$InputTitle-"
  InformCont "InputSubtitle=$InputSubtitle-"
  InformCont "Timeout=$Timeout-"
  InformCont "APIkey=$APIkey-"
  InformCont "m2kdir=$m2kdir-"
  InformCont "MoveDir=$MoveDir-"
  InformCont "FailSafeMode=$FailSafeMode-"
  InformCont "FailSafeDir=$FailSafeDir-"
  InformCont "AlternateMoveDir=$AlternateMoveDir-"
  InformCont "TargetPathIsInputPath=$TargetPathIsInputPath-"
  InformCont "Notify=$Notify-"
  InformCont "showtranslation=$showtranslation-"
  InformCont "ShowName=$ShowName-"
  InformCont "LastUpdatedTVDB=$LastUpdatedTVDB-"
  InformCont "CurrentTimeTVDB=$CurrentTimeTVDB-"
  InformCont "SeriesID=$SeriesID-"
  InformCont "NewShowName=$NewShowName-"
  InformCont "AbsoluteEpisodeNumber=$AbsoluteEpisodeNumber-"
  InformCont "EpisodeSubtitle=$EpisodeSubtitle-"
  InformCont "Sxx=$Sxx- Exx=$Exx-"
  InformCont "SYMLINK=$SYMLINK-"
  InformCont "MoveFileSize=$((MoveFileSize/1024)) MB"
  InformCont "ConfidenceRating=$ConfidenceRating-"
  InformCont "ConfidenceReasoning=$ConfidenceReasoning-"
  #Print a summary table of writeable directories.
  dirSummary
  if [ "$Database" = "Enabled" ]; then
    InformCont "XMLTVGrabber=$XMLTVGrabber-"
    InformCont "ShowStartTime=$ShowStartTime-"
    InformCont "MovieAirDate=$MovieAirDate-"
    InformCont "OriginalAirDate=$OriginalAirDate-"
    InformCont "ProgramID=$ProgramID-"
    InformCont "ChanID=$ChanID-"
    InformCont "StorageGroup=$StorageGroup-"
    InformCont "ShowCategory=ShowCategory-"
    InformCont "GoForDoover=$GoForDoover-"
    InformCont "ProgramIDType=$ProgramIDType-"
    InformCont "rating=$rating-"
    InformCont "Zap2itSeriesID=$Zap2itSeriesID-"
    InformCont "MatchedSeriesID=$MatchedSeriesID-"
    InformCont "InputSeasonNum=$InputSeasonNum-"
    InformCont "InputEpisodeNum=$InputEpisodeNum-"
    InformCont "Plot=$Plot-"
    [[ -n "$AbsoluteEpisodeNumber" ]] && InformCont "Matched Plot=$(sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir/$NewShowName/$NewShowName.Plot.txt")-"
  fi
  Inform "################ END OF OPERATION SUMMARY ################"
}

#####MYTHICAL DIAGNOSTICS#####
#This function provides a functions check on myth2kodi
m2kDiagnostics(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #If there is already a diagnostics file, move it to diagnostics_old_<Date&Time that this script was launched>
  test -f "$DiagnosticsFile" && mv "$DiagnosticsFile" "$m2kdir/diagnostics_old_${FileNameNow}.log"
  #TODO: give these checka, checkb etc more meaningful names
  local checka="" #libmyth-python
  local checkb="" #python-lxml
  local checkc="" #curl
  local checkd="" #agrep
  local checke="" #libnotify-bin
  local checkf="" #python
  local python_version="" #Python Version information
  local pyver=0 #An integer representing first 2 points of python version, ie 2.6.3 => 26
  local packagecheck=""
  local DBTest=""
  local notifytest=""
  local PythonBindingsCheck=""
  local exitstatus
  Inform "Diagnostic mode entered: $(date)"
  Inform "myth2kodi will now conduct a series of tests."
  read -r -n1 -p "press any key to verify installed packages..."
  printf '\n'

  #TODO: rename m2k_notify as m2k_notify
  local -i bashlogging_file
  local -i MythDataGrabber_file
  local -i MythDataGrabber_exec
  local -i m2k_notify_file
  local -i m2k_notify_exec
  local -i our_scripts
  #Test if our own scripts are where they need to be and, if necessary, executable.
  if [[ -f "$binpath"/bashlogging ]]; then bashlogging_file=0; else bashlogging_file=1; fi
  if [[ -f "$binpath"/MythDataGrabber ]]; then MythDataGrabber_file=0; else MythDataGrabber_file=1; fi
  if [[ -x "$binpath"/MythDataGrabber ]]; then MythDataGrabber_exec=0; else MythDataGrabber_exec=1; fi
  if [[ -f "$binpath"/m2k_notify ]]; then m2k_notify_file=0; else m2k_notify_file=1; fi
  if [[ -x "$binpath"/m2k_notify ]]; then m2k_notify_exec=0; else m2k_notify_exec=1; fi
  our_scripts=$((bashlogging_file+MythDataGrabber_file+MythDataGrabber_exec+m2k_notify_file+m2k_notify_exec))
  #Provide initial feedback about our scripts.
  if ((bashlogging_file==0)); then Inform "Found: $binpath/bashlogging"; else Err "Can't Find: $binpath/bashlogging"; fi
  if ((MythDataGrabber_file==0)); then Inform "Found: $binpath/MythDataGrabber"; else Err "Can't Find: $binpath/MythDataGrabber"; fi
  if ((MythDataGrabber_exec==0)); then Inform "Executable: $binpath/MythDataGrabber"; else Err "Not Executable: $binpath/MythDataGrabber"; fi
  if ((m2k_notify_file==0)); then Inform "Found: $binpath/m2k_notify"; else Err "Can't Find: $binpath/m2k_notify"; fi
  if ((m2k_notify_exec==0)); then Inform "Executable: $binpath/m2k_notify"; else Err "Not Executable: $binpath/m2k_notify"; fi
  ((our_scripts!=0)) && Err "Checks for our own scripts ***FAILED***"

  #Test if required packages are installed and accessible to caller.
  test $(which curl)>/dev/null  || checkc="curl"
  test $(which agrep)>/dev/null || checkd="agrep or tre-agrep"
  test $(which notify-send)>/dev/null || checke="libnotify-bin"
  if [ "$DatabaseType" = "MythTVPythonBindings" ]; then
    which python &> /dev/null ; test "$?" = "0" || checkf="python"
    if [[ -z "$checkf" ]]; then
      python_version="$(python --version 2>&1)"  #Python returns version info to stderr
      pyver="$(echo "$python_version" | sed s/"python\s*"//I | cut -f1-2 -d"." | tr -d '.')"
      python -c "from MythTV import MythDB ; exit()" &> /dev/null
      test "$?" != "0" && checka="libmyth-python"
      python -c "import lxml ; exit()" &> /dev/null
      test "$?" != "0" && checkb="python-lxml"
    fi
  fi

  #Provide feedback on package checks
  packagecheck="$checkc$checkd$checke"
  printf '\n' | tee -a "$DiagnosticsFile"
  [[ -z "$checkc" ]] && Inform "package 'curl' found."
  [[ -z "$checkd" ]] && Inform "package 'agrep' or 'tre-agrep' found."
  [[ -z "$checke" ]] && Inform "package 'libnotify-bin' found."
  if [ "$DatabaseType" = "MythTVPythonBindings" ]; then
    packagecheck="$packagecheck$checkf$checka$checkb"
    [[ -z "$checkf" ]] && Inform "package 'python' found."
    if [[ -z "$checkf" ]] && ((pyver < 26 || pyver >= 30)); then
      Warn "Python 3 and Python older than 2.6 aren't supported."
    fi
    [[ -z "$checka" ]] && Inform "package 'libmyth-python' found."
    [[ -z "$checkb" ]] && Inform "package 'python-lxml' found."
  fi
  if [[ -n "$packagecheck" ]] ; then
    packagecheck="***FAILED***"
    Err "Installed packages check ***FAILED***"
    ErrCont "Missing packages are: $checkc $checkd $checke $checkf $checka $checkb"
    ErrCont "If packages are already installed, check your path settings."
    if [ "$m2kPlatform" != "Darwin" ] ; then
      ErrCont "Please run 'apt-get install $checkc $checkd $checke $checkf $checka $checkb' or equivalent."
    else
      ErrCont "Please obtain MacPorts and install $checkb $checkc $checkd $checke"
      [[ -n "$checkf" ]] && ErrCont "Python is missing, please install Python, or make sure it's in your path."
    fi
  else
    packagecheck="***PASSED***"
    Inform "Installed packages check ***PASSED***"
  fi

  #If we're not on Mac OS X, check that user notification is working.
  if [ "$m2kPlatform" != "Darwin" ]; then
    read -r -n1 -p "Press any key to perform Desktop Message test..."
    printf '\n'
    Inform "Performing m2k_notify test"
    InformCont "This test verifies that the message was sent to the DBUS."
    InformCont "This test does not verify the user has a valid desktop open."
    sudo -u "$NotifyUserName" "$binpath"/m2k_notify "myth2kodi test" "Testing Desktop Communications" "info"
    if [ "$?" = "0" ] ; then
      notifytest="***PASSED***"
      Inform "Desktop Notifications test $notifytest"
    else
      notifytest="***FAILED***"
      Warn "Desktop Notifications test $notifytest"
    fi
  else
    notifytest="   N/A"
  fi

  #If we'll be using MythTV python bindings, check that they're functioning.
  if [ "$DatabaseType" = "MythTVPythonBindings" ]; then
    read -r -n1 -p "Press any key to perform a test of the MythTV Database python bindings..."
    printf '\n'
    Inform "Performing MythTV Python Bindings database test."
    if [[ -z "$checkf" ]]; then
      Inform "Python: $(which python)"
      Inform "Version: $python_version"
    fi

    #If checks above found python-lxml & libmyth-python, do a more thorough testing of MythTV python bindings
    if [[ -z "$checkf$checka$checkb" ]]; then
      #Use MythDataGrabber's internal diagnostics function
      "$binpath"/MythDataGrabber --Diagnostic=True
      if [[ $? = "0" ]]; then PythonBindingsCheck="OK"; else PythonBindingsCheck="FAILED"; fi
      if [ "$PythonBindingsCheck" = "OK" ]; then
        Inform "MythTV Python Bindings are installed properly."
        DBTest="***PASSED***"
        Inform "MythTV Database Test $DBTest"
      else
        Err "MythTV PythonBindings are not installed properly"
        ErrCont "there was a problem connecting to the database, check MythDatabase package."
        DBTest="***FAILED***"
        Err "MythTV Database Test $DBTest"
      fi
    else
      DBTest="COULD NOT COMPLETE, SEE MISSING PACKAGES MENTIONED ABOVE."
      Err "MythTV Database Test $DBTest"
    fi
  fi
  
  #TODO: This currently tests Kodi notification even if Notifications are disabled in settings, is this actually the behaviour we want?
  #Test communication with Kodi
  read -r -n1 -p "Press any key to perform KODI Notification test..."
  printf '\n'
  local curlPOST
  local KODINotifyTestMessage
  local data
  local KODIresp
  curlPOST='curl --silent --max-time 8 --connect-timeout 5 -H "Content-Type:application/json;" --data-binary'
  KODINotifyTestMessage="KODI Notification test..."
  data=\''{"jsonrpc": "2.0",
           "method": "GUI.ShowNotification",
           "params": {"title": "myth2kodi Test", "message": "'$KODINotifyTestMessage'"},
           "id": "myth2kodi"}'\'

  Inform "Performing KODI Notifications test"
  for KODIIP in "${KODIIPs[@]}" ; do
    Inform "SENDING REQUESTED COMMANDS TO: $KODIIP"
    #SEE: http://kodi.wiki/view/HOW-TO:Remotely_update_library and 'man curl'
    KODIresp=$( eval "$curlPOST $data http://$KODIIP/jsonrpc" 2>&1 )
    if [[ -n "$KODIresp" ]]; then
      InformCont "TESTING: $KODIresp"
    else
      Err "COMMUNICATIONS NOT ESTABLISHED: $KODIIP"
    fi
  done
  if [ "$(printf '%s' "$KODIresp")" = '{"id":"myth2kodi","jsonrpc":"2.0","result":"OK"}' ] ; then
    KODIcomm="***PASSED***"
    Inform "KODI Communications $KODIcomm"
  else
    KODIcomm="***FAILED***"
    Err "KODI Communications $KODIcomm"
    ErrCont 'Expected response: {"id":"myth2kodi","jsonrpc":"2.0","result":"OK"}'
    ErrCont "Got response: '$KODIresp'"
  fi

  #Check filesystem permissions
  read -r -n1 -p "Press any key to test file system permissions..."
  printf '\n'
  Inform "Testing file system permissions"

  if [ "$TargetPathIsInputPath" = "Enabled" ]; then
    Inform "TargetPathIsInputPath is selected. Testing with current folder"
    #Set originaldir name if none was supplied
    [["$originaldirname" = "./" || "$originaldirname" = "." || "$originaldirname" = "" ]] && originaldirname="$(pwd)"
    setTargetFolderAsInputPathFolder
  fi

  MoveFileSize="10000"
  MoveFileSize=$((MoveFileSize/1024))
  MoveDirFreeSpace=$(df -P "$MoveDir" | sed -n 2p | awk '{print $4}') || MoveDirFreeSpace=0
  AlternateMoveDirFreeSpace=$(df -P "$AlternateMoveDir" | sed -n 2p | awk '{print $4}')|| AlternateMoveDirFreeSpace=0
  if [ "$Database" = "Enabled" ]; then
    PrimaryMovieDirFreeSpace=$(df -P "$PrimaryMovieDir" | sed -n 2p | awk '{print $4}') || PrimaryMovieDirFreeSpace=0
    AlternateMovieDirFreeSpace=$(df -P "$AlternateMovieDir" | sed -n 2p | awk '{print $4}')|| AlternateMovieDirFreeSpace=0
    PrimaryShowDirFreeSpace=$(df -P "$PrimaryShowDir" | sed -n 2p | awk '{print $4}')|| PrimaryShowDirFreeSpace=0
    AlternateShowDirFreeSpace=$(df -P "$AlternateShowDir" | sed -n 2p | awk '{print $4}')|| AlternateShowDirFreeSpace=0
  fi
  #Call permissions check from function.  Write small file, delete, get results
  checkPermissions "$MoveFileSize" "$MoveDirFreeSpace" "$MoveDir"
  MoveDirWritable=$TMoveDirWritable
  checkPermissions "$MoveFileSize" "$AlternateMoveDirFreeSpace" "$AlternateMoveDir"
  AlternateMoveDirWritable=$TMoveDirWritable
  if [ "$Database" = "Enabled" ]; then
    checkPermissions "$MoveFileSize" "$PrimaryMovieDirFreeSpace" "$PrimaryMovieDir"
    PrimaryMovieDirWritable=$TMoveDirWritable
    checkPermissions "$MoveFileSize" "$AlternateMovieDirFreeSpace" "$AlternateMovieDir"
    AlternateMovieDirWritable=$TMoveDirWritable
    checkPermissions "$MoveFileSize" "$PrimaryShowDirFreeSpace" "$PrimaryShowDir"
    PrimaryShowDirWritable=$TMoveDirWritable
    checkPermissions "$MoveFileSize" "$AlternateShowDirFreeSpace" "$AlternateShowDir"
    AlternateShowDirWritable=$TMoveDirWritable
  fi
  if [ "$TargetPathIsInputPath" = "Enabled" ]; then
    OriginaldirFreeSpace="$(df -P "$originaldirname" | sed -n 2p | awk '{print $4}')"
    checkPermissions "1" "$OriginaldirFreeSpace" "$originaldirname"
    OriginalDirWritable=$TMoveDirWritable
  fi
  WorkingDirFreeSpace="$(df -P "$m2kdir" | sed -n 2p | awk '{print $4}')"
  checkPermissions "5000" "$WorkingDirFreeSpace" "$m2kdir"
  WorkingDirWritable=$TMoveDirWritable
  
  #Print a summary table of writeable directories.
  dirSummary

  if [ "$MoveDirWritable" = "1" ] && [ "$AlternateMoveDirWritable" = "1" ] && [ "$WorkingDirWritable" = "1" ] ; then
    folderchecks="***PASSED***"
    Inform "Critical Filesystem checks $folderchecks"
  else
    folderchecks="***FAILED***"
    Err "Critical Filesystem checks $folderchecks"
  fi
  if [ "$packagecheck" = "***PASSED***" ] && [ "$folderchecks" = "***PASSED***" ] ; then
    overallchecks="***PASSED***"
  else
    overallchecks="***FAILED***"
  fi
  if [ "$overallchecks" = "***PASSED***" ]; then
    read -r -n1 -p "press any key to test myth2kodi..."
    printf '\n'
    Inform "Recordings Database is not used for testing."
    InformCont "Performing fuzzy logic lookup on database file.  Please wait."
    InformCont "It may take a moment to build myth2kodi database files."
    InformCont "Executing: myth2kodi testfile.ext 'mister rogers' 'show 1332'"
    InformCont "Testing exit status."

    myth2kodi testfile.ext "mister rogers" "show 1332"
    exitstatus=$?
    InformCont  "exited with status $exitstatus"
    if [ "$exitstatus" = "0" ]; then
      mythicaltest="***PASSED***"
    else
      Err "OVERALL FAILURE -- checks passed, but test run failed."
      mythicaltest="COULD NOT COMPLETE"
      overallchecks="***FAILED***"
    fi
  else
    Err "OVERALL FAILURE"
    mythicaltest="COULD NOT COMPLETE"
  fi
  read -r -n1 -p "press any key to continue on to the final results..."
  printf '\n'
  Inform "RESULTS SUMMARY:"
  test "$DatabaseType"="MythTVPythonBindings" && InformCont "MythTV Database Test: $DBTest"
  InformCont "Installed Packages:  $packagecheck $checka $checkb $checkc $checkd $checke"
  InformCont "Notifications Test:  $notifytest"
  InformCont "KODI Communications: $KODIcomm"
  InformCont "File System Checks:  $folderchecks"
  InformCont "mythicalTesting:     $mythicaltest"

  InformCont "Overall mythicalReadiness: $overallchecks"
  InformCont "-----End of diagnostics-----"
  printf '\n' | tee -a "$DiagnosticsFile"

  #Logging for failure messages
  if [ "$DBTest" = "***FAILED***" ]; then
    Err "Database tests failed"
    ErrCont "When interfacing MythTV/0.24, myth2kodi uses MythTV's Python"
    ErrCont "Bindings.  These must be configured and working for proper access"
    ErrCont "to data required by myth2kodi."
    ErrCont "Could not connect to the database. Check username and password."
    printf '\n' | tee -a "$DiagnosticsFile"
  #TODO: add more information on how to install
  fi

  if [ "$notifytest" = "***FAILED***" ]; then
    Err "Notify tests failed"
    ErrCont "Notifications to the DBUS have failed. myth2kodi relies upon"
    ErrCont "m2k_notify and package lib-notify to display messages on"
    ErrCont "GNOME desktop interface. These messages will not be displayed. "
    printf '\n' | tee -a "$DiagnosticsFile"
  fi
  if [ "$KODIcomm" = "***FAILED***" ]; then
    Err "Kodi communication tests failed"
    ErrCont "KODI Communications have failed.  Likely causes: Improper IP address,"
    ErrCont "or KODI is not equipped to handle external network commands in settings."
    ErrCont "If you've set a user and password for http access to kodi, make sure that"
    ErrCont "it's prepended to the ip addresses user:password@192..."
    ErrCont "myth2kodi can not send messages or library update requests."
    printf '\n' | tee -a "$DiagnosticsFile"
  fi
  #TODO: SUDO_USER is only set in executeDoOver() and executeUndo(), in the original mythicalLibrarian it was also set in the updater.
  #  So, the $SUDO_USER statements here won't evaluate to anything, and would never have worked outside of the context of the updater.
  #  REALLY NEED TO REVIEW sudo USE AND PERMISSIONS EXPECTATIONS WITHIN THE SCRIPT...
  if [ "$folderchecks" = "***FAILED***" ]; then
    Err "Folder checks failed"
    ErrCont "The filesystem checks failed. Likely causes: "
    ErrCont "The user named $SUDO_USER does not have permission to use the folder"
    ErrCont "CORRECTIVE ACTION: sudo chown $SUDO_USER /Name/of/My_failed_folder"
    ErrCont "The folder belongs to a different group then the user named $SUDO_USER"
    if [ "$Database" = "Enabled" ] && [ "$DatabaseType" = "MythTV" ] && [ "$SUDO_USER" != "mythtv" ]; then
      ErrCont "    CORRECTIVE ACTION: sudo adduser mythtv $SUDO_USER"
      ErrCont "                       sudo adduser $SUDO_USER mythtv"
      printf '\n' | tee -a "$DiagnosticsFile"
    else
      ErrCont "    CORRECTIVE ACTION: sudo adduser RecordingManagerUser $SUDO_USER"
      ErrCont "                       sudo adduser $SUDO_USER RecordingManagerUser"
      printf '\n' | tee -a "$DiagnosticsFile"
    fi
    ErrCont "The folder does not exist"
    ErrCont "    CORRECTIVE ACTION: mkdir /Name/of/My_failed_folder"
    printf '\n' | tee -a "$DiagnosticsFile"
  fi
  if [ "$mythicaltest" != "***PASSED***" ]; then
    Err "Test run of myth2kodi failed."
    ErrCont "myth2kodi has encountered an error. This may be due to a"
    ErrCont "lack of network connection. If the problem persists, try"
    ErrCont "reading then asking at: http://forum.kodi.tv/showthread.php?tid=65644" #TODO: If make public, change to new thread that I should've started.
    printf '\n' | tee -a "$DiagnosticsFile"
  fi
  if [ "$overallchecks" = "***FAILED***" ]; then
    Inform "The issues mentioned above must be corrected for myth2kodi to perform correctly."
  fi

  Inform "Diagnostic mode completed: $(date)"
  Inform "A diagnostics log file was written to: $LogFile"

  test "$overallchecks" = "***FAILED***" && return 1

  return 0
}

#####DOOVER PROCESSING#####
#This function provides an easy way to redo failed jobs.
executeDoOver(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local yesorno=""
  local RunSudo=0
  if [ "$(id -u)" = "0" ]; then
    #TODO: So, if id of user is 0, and thus root, test $SUDO_USER is set as
    #  "root" and if it is assign whoami (which for uid=0 will return root) to
    #  the variable  SUDO_USER... Something is wrong here.
    test "$SUDO_USER" = "root" && SUDO_USER=$(whoami)
    RunSudo=1
  fi
  [[ -z "$SUDO_USER" ]] && SUDO_USER=$(whoami)
  Warn "--You have entered doover mode."
  WarnCont "In this mode of operation, myth2kodi will rerun myth2kodi against all"
  WarnCont "files which failed on the last run of myth2kodi."
  WarnCont "It is important that this process isn't interrupted or data loss may occur."
  test "$DoOverBypass" != "1" && read -r -n1 -p "  Press 'y' to continue or 'n' to exit..... y/(n):>" yesorno && printf '\n'
  test "$DoOverBypass" = "1" && yesorno="y"

  if [ "$yesorno" = "y" ] && [ -f "$m2kdir/doover.sh" ]; then
    Debug "Running doover.sh"
    #TODO: Maybe doover.sh.run_YYYY-MM-DDThhMMSS would be better, see $FileNameNow
    #      cp "$m2kdir/doover.sh" "$m2kdir/doover.sh.old_$FileNameNow"
    #preserve permissions
    chmod +x "$m2kdir/doover.sh"
    #NOTE: The first command in doover.sh is to delete the file doover.sh.
    if [ "$RunSudo" = "1" ] ; then
      sudo -u $SUDO_USER cat "$m2kdir/doover.sh" >> "$m2kdir/doover.sh.old"
      sudo -u $SUDO_USER "$m2kdir/doover.sh"
    else
      cat "$m2kdir/doover.sh" >> "$m2kdir/doover.sh.old"
      "$m2kdir/doover.sh"
    fi
    Inform "done."
    return 0
  else
    if [[ -f "$m2kdir/doover.sh" ]]; then Inform "You must press y to execute Doover."; else Inform "No Doover jobs exist."; fi
    return 0
  fi
  return 1
}

#####UNDO JOBS#####
#This function provides an easy way to undo all myth2kodi jobs
executeUndo(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [ "$(id -u)" != "0" ]; then
    Err "You do not have sufficient privileges to run this script."
    ErrCont "--undo must be executed with the sudo command"
    ErrCont "eg. 'sudo myth2kodi --undo'"
    return 1
  fi
  [[ -z "$SUDO_USER" ]] && SUDO_USER=$(whoami)
  Warn "--You have entered undo mode."
  WarnCont " In this mode of operation, myth2kodi will reverse"
  WarnCont " file changes created by the current user while running."
  WarnCont " myth2kodi. There will be no indicators while undo"
  WarnCont " is running. It is important that this process is not "
  WarnCont " interrupted or data loss may occur"
  read -r -n1 -p "  Press 'y' to continue or 'n' to exit..... y/(n):>" yesorno
  printf '\n'
  if [ "$yesorno" = "y" ]; then
    Warn "Running undo.sh DO NOT INTERRUPT THIS PROCESS OR DATA LOSS MAY OCCUR."
    cp "$m2kdir/undo.sh" "$m2kdir/undo.lock"
    test -f "$m2kdir/undo.sh" && cat "$m2kdir/undo.sh">>"$m2kdir/undo.sh.old"
    test -f "$m2kdir/undo.sh" && chmod +x "$m2kdir/undo.sh"
    test -f "$m2kdir/undo.sh" && sudo -u $SUDO_USER cat "$m2kdir/undo.sh" >> "$m2kdir/undo.sh.old"
    test -f "$m2kdir/undo.sh" && sudo -u $SUDO_USER "$m2kdir/undo.sh"
    Debug "If doover.sh file exists, move it to doover.sh.old."
    #TODO: Change doover.sh.old to doover.sh.old_YYYY-MM-DDTHHMMss would be better, see $FileNameNow
    #      also, then we can simply mv "$m2kdir/doover.sh" "$m2kdir/doover.sh.old_$FileNameNow" instead of two steps below...
    test -f "$m2kdir/doover.sh" && cat "$m2kdir/doover.sh" >> "$m2kdir/doover.sh.old"
    test -f "$m2kdir/doover.sh" && rm -f "$m2kdir/doover.sh"
    Debug "If created.tracking file exists, move it to created.tracking.old."
    removedead=1
    test -f "$m2kdir/created.tracking" && cat "$m2kdir/created.tracking">>"$m2kdir/created.tracking.old"
    test -f "$m2kdir/created.tracking" && rm -f "$m2kdir/created.tracking"
    rm -f "$m2kdir/undo.lock"
    sudo -u $SUDO_USER myth2kodi --maintenance
    Inform "Done, undo.sh has finished running."
    return 0
  else
    Inform "You must press y to execute undo"
    return 0
  fi
  return 1
}

#####HELP#####
#This function provides a helpful message.
m2kHelp(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [ "$InputPath" = "%DIR%/%FILE%" ]; then
    UserJobOutsideMythTV
    ExitJob 'GenericUnspecifiedError'
  fi
  echo " myth2kodi --:invalid pattern"
  echo ""
  echo "usage: myth2kodi 'path/to/file' ['title'] ['subtitle']"
  echo "usage: myth2kodi --mode [parameter] [parameter]"
  echo "  items in brackets are [context sensitive]"
  #TODO: Create more detailed help messages for individual options, so that
  #      they can be called something like:
  #      myth2kodi --help maintenance
  if [ "$switchhelp" = "1" ]; then
    echo ""
    echo "mythicalLibrarian Author: Adam Outler outleradam(at)hotmail.com"
    echo "myth2kodi Author: Stuart Knock"
    echo ""
    echo "--diagnostics"
    echo "  diagnostics: tests the functionality of myth2kodi"
    echo "  eg. myth2kodi --diagnostics"
    echo ""
    echo "--scan filetype /path/to/folder"
    echo "  scan: creates a library from an entire folder"
    echo "  eg. myth2kodi --scan mpg /home/mythtv/videos"
    echo ""
    echo "--maintenance"
    echo "  maintenance: removes FOLDER DISCONNECTED errors from logs"
    echo "  eg. myth2kodi --maintenance"
    echo ""
    echo "--update"
    echo "  update: myth2kodi to the current version"
    echo "  eg. sudo myth2kodi --update"
    echo ""
    echo "--doover"
    echo "  doover: reruns previously failed jobs sequentially"
    echo "  eg. sudo myth2kodi --doover"
    echo ""
    echo "--unmanned_doover"
    echo "  unmanned_doover: Same as --doover but for use without human intervention"
    echo "  eg. sudo myth2kodi --unmanned_doover"
    echo ""
    echo "--undo"
    echo "  undo: returns all files to original states"
    echo "  eg. sudo myth2kodi --undo"
    echo ""
    echo "--getSeriesInfo 'Series Name'"
    echo "  getSeriesInfo: Update of local tables for a series from TheTVDB,"
    echo "                 ignoring lastupdated.time."
    echo "  eg. myth2kodi --getSeriesInfo 'Black Books'"
    echo ""
    echo "--commskip /path/to/folder/or/file"
    echo "  commskip: Regenerates the commskip file for recordings that have"
    echo "            already been moved. Argument can be either a single"
    echo "            recording or a directory containing already moved recordings."
    echo "  eg. myth2kodi --commskip '/home/mythtv/recordings/1099_20151210093000.mpg'"
    echo "  eg. myth2kodi --commskip '/home/mythtv/recordings'"
    echo ""
    echo "-?|-h|--help"
    echo "  Help: displays this message"
    echo "  example: myth2kodi --help"
    echo ""
    echo "--special"
    echo "  Special Help: displays extended configuration help."
    echo "  example: myth2kodi --special"
    echo ""
    echo " --confidence"
    echo "  Confidence Help: Displays information on improving confidence"
    echo "  example: myth2kodi --confidence"
    echo "======================================================="
  fi
  echo " ensure you have set the user settings set properly and run"
  echo " --diagnostics before using myth2kodi"
  echo " in --scan mode or as a UserJob."
  echo " For more information type: myth2kodi --help or --special"
  echo " done."
  exit 1
}

special(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  echo " ======showTranslations====="
  echo " If you are having problems with incorrect guide data such"
  echo " as improper titling, use showTranslations."
  echo " ShowTranslations can be applied by creating a file called:"
  echo " $m2kdir/showTranslations"
  echo " ##############################################################"
  echo " #My Guide Show Title = www.TheTVDB.com Show Title            #"
  echo " #Battlestar Gallactica = Battlestar Gallactica (2003)        #"
  echo " #The Office = The Office (US)                                #"
  echo " #Millionaire = Who Wants To Be A Millionaire                 #"
  echo " #Aqua teen Hungerforce = Aqua Teen Hunger Force              #"
  echo " ##############################################################"
  echo ""
  echo "======titleIgnore======"
  echo " If wish to ignore all shows with a specific title, use titleIgnore"
  echo " titleIgnore can be applied by creating a file called:"
  echo " $m2kdir/titleIgnore"
  echo " ##############################################################"
  echo " #Show to ignore                                              #"
  echo " #Battlestar Gallactica                                       #"
  echo " #The Office                                                  #"
  echo " #Millionaire                                                 #"
  echo " #Aqua teen Hungerforce                                       #"
  echo " ##############################################################"
  echo ""
  echo "======categoricIgnore======"
  echo " If you wish to ignore all shows with a specific category, use"
  echo " categoricIgnore"
  echo " categoricIgnore can be applied by creating a file called:"
  echo " $m2kdir/categoricIgnore"
  echo " ##############################################################"
  echo " #Category to ignore                                          #"
  echo " #Sports                                                      #"
  echo " #Sports Talk                                                 #"
  echo " #College Sports                                              #"
  echo " #Comedy                                                      #"
  echo " ##############################################################"
  echo ""
  echo "======globalSettings====="
  echo " If you wish to override any settings in mythicalSetup, use"
  echo " globalSettings.  globalSettings allows you to take any setting"
  echo " from the top of the myth2kodi file and make it permanent."
  echo " mythicalSetup will not change this file.  Your settings will"
  echo " remain static after upgrades."
  echo ""
  echo " globalSettings can be applied by creating a file called:"
  echo " /etc/myth2kodi/globalSettings"
  echo " ##############################################################"
  echo " #SYMLINK=Disabled                                            #"
  echo " #AlternateMoveDir=/media/usbDrive                            #"
  echo " #NotifyUserName=adam                                         #"
  echo " #KODIIPs=( user:password@192.168.1.110:8080 )                #"
  echo " #Database=Disabled                                           #"
  echo " ##############################################################"
  echo "Done."
}

improveConfidence(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  echo -e "About Confidence ratings:"
  echo -e ""
  echo -e " Confidence Ratings are used by myth2kodi."
  echo -e " These ratings serve as a guide to the probability of a"
  echo -e " perfect match. Ratings range from +4 to -6.  Any rating"
  echo -e " at or above 0 should be considered a good match."
  echo -e ""
  echo -e "How can I improve my Confidence Rating?"
  echo -e " 1. myth2kodi --special provides information on how"
  echo -e "    to improve Episode matching confidence by using a"
  echo -e "    showTranslations file to compensate for bad guide data."
  echo -e " 2. Add your favorite show's Zap2it ID to TheTVDB.com."
  echo -e " 3. Add your favorite show's OriginalAirdate to TheTVDB.com."
  echo -e " 4. Add your favorite show's proper Title to TheTVDB.com"
  echo -e "done."
  exit 0
}

getSeriesInfo(){
  Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Force an update of the myth2kodi tables for a specified Series
  #Usage example: myth2kodi --getSeriesInfo "Black Books"
  Inform "Searching for series: $InputTitle"
  ShowName="$InputTitle"
  local tvdbshowname="$(echo "$ShowName" | sed s/" "/"%20"/g | sed s/"&"/"%26"/g)"
  searchTheTVDBAndReturnTxtFileTables
  GetSeriesLineNumberFromTableWithFuzzyLogic
  #if we have a series line number then translate that into a series id
  if [[ -n "$serieslinenumber" ]] && ((serieslinenumber > 0)); then
    setSeriesIDandNewShowNameBasedOnSeriesLineNumber
    Inform "FOUND: $NewShowName ID#:$SeriesID"
    makeShowDirIfNeeded
  else
    Warn "${FUNCNAME[0]}() SeriesID COULD NOT BE DETERMINED"
    return 1
  fi
  if [[ -n "$SeriesID" ]]; then
    downloadInfoAboutMatchedTitleAndCreateTxtFileTables
    return $?
  else
    Err "We had serieslinenumber: $serieslinenumber but couldn't get a SeriesID."
    return 1
  fi
}

########################### END FUNCTION DEFINITIONS ###########################


######################### BEGIN MAIN PROGRAM ###################################

#TODO: The permission handling stuff seems a bit convoluted, I also think I've
#  found at least a few bugs. It would seem far simpler to enforce a dedicated
#  user to function as the "Librarian". That is add a Librarian= to the user
#  settings at the start of this file. Probably with the default of
#  Librarian="mythtv" for maximum compatibility with existing expectations of
#  the code... Then simply refuse to run with a helpful error message if the
#  variable $MyUserName doesn't equal $Librarain. The requirement would just be
#  that the user $Librarian be the one running MythTV and that they have write
#  privileges to the MoveDirs that Kodi can see. Then most/all of the need for
#  running commands with sudo and the need for undo to be run as root can be
#  removed... Need to check expectations of MythDataGrabber and other auxiliary
#  functions before making this change.

#TODO: At some point this main needs to be cleaned up, at the moment it's a 
#  little bit too organic, final structure should be something like:
#    #Basic setup    
#      #Basic tests to make sure we were called correctly.
#      #Who am I, where am I, When am I
#      #Settings to override those at the top of file
#      #If first run make workspace
#    #Command line switches: Are we doing something other than moving a recording?
#    #If trying to move a recording, get info from command line
#    #Command line sanity checks
#    #Now we have all important settings, and know were not performing some other function, do filesystem checks etc -- no point doing a lot of work if we can't move anything at the end..
#    #Do we have enough info from the command line to move, if so jump to verify
#    #If not: Get info from the MythTV-DB
#    #MythTV-DB Guide data basic/common post processing, then sanity checks.
#    #Do we have enough info to move, if so jump to verify
#    #If still lacking information, try matching against TheTVDB info
#      #If SchedulesDirect, check zap2it
#      #If US, check airdate
#      #If SxxExx but no EpisodeTitle, use SxxExx to get EpisodeTitle.
#      #If EpisodeTitle but no SxxExx, use EpisodeTitle to get SxxExx.
#      #If No SxxExx and no EpisodeTitle: check against Plot.
#    #Verify: do checks to make sure what we're moving and where we're moving it too makes sense, and that we have good confidence that the names we're using are correct. 
#    #IF WE'RE NOT CONFIDENT OR ANYTHING ELSE DURING THE ABOVE STEPS IS WRONG, WRITE JOB TO DOOVER, REPORT WHAT WENT WRONG, BUT OTHERWISE DO NOTHING!
#    #Move file...
#    #Notify Kodi, RSS, and whoever else wanted to know that we're done and what it is we've done.
#    #THE END

#####DEFINE ENVIRONMENT AND VARIABLES#####
#Who called the script:
declare -r MyUserName=$(whoami)
Debug "Running myth2kodi as $MyUserName"
#TODO: check of $MyUserName and bailing with an ERROR message if != $Librarian
[[ "$MyUserName" != "$Librarian" ]] && Err "myth2kodi should be run by user '$Librarian'"
#And when, 
declare -r Today="$(date +%F)"  #Date in IEEE standard format, ie YYYY-mm-dd
declare -r ScriptStartTime="$(date +%H:%M:%S)" #Time in a readable IEEE standard format, ie HH:MM:SS
declare -r FileNameNow="$(date +%FT%H%M%S)"  #ISO 8601: YYYY-mm-ddThhMMSS

#Set global values for settings, this overrides those set at the top of this file
test -f "/etc/myth2kodi/globalSettings" && source /etc/myth2kodi/globalSettings

#Make our working directory if it doesn't already exist
if [ ! -d "$m2kdir" ]; then
  mkdir "$m2kdir"
  touch "$LogFile"
  #Keep this as a printf so it's created here regardless of LogType & LogLevel.
  {
    printf 'Creating Working Directory: %s\n' "$m2kdir"
    #TODO: separate out log file creation text into a function so it can be reused in conjunction with Auto-compress of LogFile...
    printf 'Creating Log File: %s\n' "$LogFile"
    printf 'Created on %s at %s\n' "$Today" "$ScriptStartTime"
  } >> "$LogFile"
fi

#Setup defaults for searching Series information
SeriesID=""
NewShowName=""
RequiresDoover=0
declare -i ConfidenceRating=0
declare -i SeriesConfidenceRating=0

#Setup defaults for searching Episode information
Exx=""
Sxx=""
GotEpisodeNumber=0
declare -i EpisodeConfidenceRating=0
MythicalEpiShow=0 #TODO: this is set in multiple places but seems to never be used..

#Load variables from a file if required
test -f "$m2kdir"/myth2kodi.conf && source "$m2kdir"/myth2kodi.conf

#Capture args the script was called with
m2karg1="$1" ; m2karg2="$2" ; m2karg3="$3" ; m2karg4="$4"
#TODO: Set the inputs as fixed (read-only) parameters, then use different variables consistently if we need to modify them...
InputPath="$1"
InputTitle="$2"
InputSubtitle="$3"
#TODO: Consider removing this "InputOption", it's only used by --BypassPermissionsCheck and removing that option seems like it might be a good idea...
InputOption="$4"
#TODO: Should allow manual input of season and episode numbers in addition to
#  Title & Subtitle, with full information all searching should be overridden/bypassed...
#InputSxx="$4"
#InputExx="$5"

#Some basic tests to make sure we were called correctly
[[ "$InputPath" != "testfile.ext" && ! -f "$InputPath" && -z "$InputTitle" && "${InputPath:0:1}" != "-" ]] && m2kHelp
[[ -z "$InputPath" ]] && m2kHelp
#TODO: MythTVUserJobString is not used within this script, check whether it's somehow a requirement of calls from mythtv
MythTVUserJobString="%DIR%/%FILE%"

#####COMMAND LINE SWITCHES#####
#check for command line switches
case "$InputPath" in

  --scan)
    Debug "Recognised command line switch '--scan'"
    #TODO: Add ability to scan only specific files, eg those for a specific ShowName
    export m2kScanMode="True"
    m2kScan
    declare -i scanreturnstatus="$?"
    unset m2kScanMode
    exit $scanreturnstatus
  ;;
  --diagnostics)
    Debug "Recognised command line switch '--diagnostics'"
    PreCallLogFile="$LogFile"
    PreCallLogLevel="$LogLevel"
    (( LogLevel < 3 )) && LogLevel=3 && Inform "Escalating LogLevel to Debug (3)."
    if [[ "$LogType" != "stdout" ]] ; then
     Inform "Running diagnostics, so redirecting subsequent messages to $DiagnosticsFile"
    else
     Warn "Running diagnostics without any logging to file, consider using LogType 'logfile' or 'both'"
    fi
    LogFile="$DiagnosticsFile"
    m2kDiagnostics
    declare -i diagnosticsreturnstatus="$?"
    #Reset the LogFile & LogLevel to previous state, in case we ever call myth2kodi --diagnostics from within myth2kodi
    LogFile="$PreCallLogFile"
    LogLevel="$PreCallLogLevel"
    exit $diagnosticsreturnstatus
  ;;
  --confidence)
    Debug "Recognised command line switch '--confidence'"
    improveConfidence
    exit 0
  ;;
  --doover)
    Debug "Recognised command line switch '--doover'"
    executeDoOver
    exit $?
  ;;
  --unmanned_doover)
    Debug "Recognised command line switch '--unmanned_doover'"
    DoOverBypass=1
    executeDoOver
    exit $?
  ;;
  --undo)
    Debug "Recognised command line switch '--undo'"
    #TODO: Enable undo for a specific file, eg: myth2kodi --undo '/path/to/recordings/1070_20160331073100.mpg'
    executeUndo
    exit $?
  ;;
  --getSeriesInfo)
    Debug "Recognised command line switch '--getSeriesInfo'"
    #Example usage: myth2kodi --getSeriesInfo "Black Books"
    getSeriesInfo
    exit $?
  ;;
  --help|-?|-h)
    Debug "Recognised command line switch '--help|-?|-h'"
    switchhelp=1
    m2kHelp
    exit 0
  ;;
  --update|--upgrade|--build) #TODO: delete this if we're not going to use it.
    Debug "Recognised command line switch '--update|--upgrade|--build'"
    #mythicalUpdater
    Err "NOT MAINTAINING THE UPDATER, SO DON'T BOTHER TRYING TO UPDATE..."
    exit 1
  ;;
  --maintenance)
    Debug "Recognised command line switch '--maintenance'"
    MaintenanceWarning
    [[ "$?" != 0 ]] && exit $?
    removedead=1
    DoMaintenance
    exit $?
  ;;
  --special)
    Debug "Recognised command line switch '--special'"
    special
    exit 0
  ;;
  --version|-v|-ver|-V)
    Debug "Recognised command line switch '--version|-v|-ver|-V'"
    printf '%s\n' "$m2kVersion"
    exit 0
  ;;
  --commskip)
    #TODO: Move scan file generation to a function, use here and in --scan
    #TODO: Move the below into a function, clean-up and add more checking and logging.
    Debug "Recognised command line switch '--commskip'"
    #eg: myth2kodi --commskip '/path/to/recordings/1070_20160331073100.mpg'
    InputPath="$2"
    [[ ! -f "$InputPath" && ! -d "$InputPath" ]] && m2kHelp
    if [[ -f "$InputPath" && -L "$InputPath" ]]; then
      Inform "Regenerating commskip file for $InputPath"
      InputFileBasename="$(basename "$InputPath")"
      GetMythTvPythonBindings
      #TODO: Find the file that $InputPath points to or is pointed to by and use that for the move location below, otherwise we have to run full identification of Episode/etc.
      #[[ -L "$InputPath" ]] && movedrecordingname="$(readlink "$InputPath")"
      movedrecordingname="$(readlink "$InputPath")"
      #TODO: need to deal with link mode case, something like: movedrecordingname="$(find -L "$MoveDir/" -samefile "$InputPath")" #Actually, this form should work for both cases... with the problem that multiple links can be returned in link mode if there are multiple links...
      ShowCommSkip="${movedrecordingname%.*}.txt"
      mv "$m2kdir/markupframes.txt" "${ShowCommSkip}"
      exit $?
    elif [[ -d "$InputPath" ]]; then
      #TODO: confirm InputPath doesn't end in a /
      Warn "YOU ARE ABOUT TO SCAN THE DIRECTORY:"
      WarnCont "$InputPath"
      WarnCont "AND REGENERATE COMMSKIP FILES FOR ALL PREVIOUSLY MOVED RECORDINGS."
      read -r -n1 -p "  Would you like myth2kodi to conduct a scan? y/(n)>" yesorno
      printf '\n'
      #Default to safety, ie do nothing.
      [[ -z "$yesorno" ]] && yesorno="n"
      if [ "$yesorno" = "y" ]; then
        checkext="mpg" #TODO: Make this user/caller specifiable
        scanpath="$InputPath"
        Debug "Creating a temporary commskip_scan file: $m2kdir/commskip_scan.temp"
        ls -1 "$scanpath"/*."$checkext" > "$m2kdir/commskip_scan.temp"
        Inform "Scanning $scanpath for already moved $checkext files"
        while read -r line ; do
          Debug "Attempting to regenerate commskip file for $line"
          [[ -f "$line" && -L "$line" ]] && myth2kodi --commskip "$line"
        done < "$m2kdir/commskip_scan.temp"
        Debug "Removing the temporary scan file: $m2kdir/commskip_scan.temp"
        rm -f "$m2kdir/commskip_scan.temp"
        exit 0
      else
        Warn "You must press 'y' to scan, aborting."
        exit 0
      fi
    else
      [[ -f "$InputPath" && ! -L "$InputPath" ]] && Err "#TODO: --commskip can't deal with link mode moving yet..."
      Err "The argument '$InputPath' is neither an already moved recording nor a directory to scan for them."
      exit 1
    fi
  ;;
esac
Debug "No recognised command line switches set."
[[ "${InputPath:0:1}" = "-" ]] && m2kHelp

#####ENVIRONMENTAL VARIABLES CONTINUED#####

#Initial log entry
m2kPlatform="$(uname)"
printf '%s\n' "@@@@@@@@ NEW SEARCH INITIATED $Today AT $ScriptStartTime @@@@@@@@" >> "$LogFile"
printf '%s\n' "$m2kVersion on $m2kPlatform" >> "$LogFile"

InputFileBasename="$(basename "$InputPath")"

#####GATHER INFORMATION FROM MythTV DATABASE#####
#Get information if database is enabled
if [ "$Database" = "Enabled" ]; then
  #determine proper database grabber
  case "$DatabaseType" in
    MythTV)
      GetMythTVDatabase
    ;;
    MythTVPythonBindings)
      test "$InputPath" != 'testfile.ext' && GetMythTvPythonBindings
      #TODO:What's the purpose of resetting the DatabaseType here...???
      DatabaseType=MythTV
    ;;
  esac

  #determine appropriate processing for guide data
  case "$GuideDataType" in
    SchedulesDirect)
      ProcessSchedulesDirect
    ;;
    NoLookup)
      ProcessNoLookup
    ;;
    SydFTA)
      ProcessSydFTA
    ;;
    *)
      Warn "GuideDataType incorrectly specified, processing MythTV database info assuming SchedulesDirect."
      ProcessSchedulesDirect
    ;;
  esac
#TODO: Should bail with an error here if Database isn't Enabled and InputTitle is empty...
fi

#Report found data
Inform "Input and MythTV-DB Guide Data for $InputFileBasename"
InformCont "RECSTART:$ShowStartTime  DATE:$MovieAirDate $OriginalAirDate"
InformCont "PROGRAMID:$ProgramID  ShowCategory:$ShowCategory"
if [[ -n "$InputSubtitle" ]]; then InformCont "InputSubtitle:$InputSubtitle"; else InformCont "InputSubtitle: UNKNOWN"; fi
if [[ -n "$Sxx" ]]; then InformCont "Sxx:$Sxx"; else InformCont "Sxx: UNKNOWN"; fi
if [[ -n "$Exx" ]]; then InformCont "Exx:$Exx"; else InformCont "Exx: UNKNOWN"; fi
InformCont "PLOT: $Plot"
ShowName="$InputTitle"
[[ -z "$ShowName" ]] && m2kHelp

#TODO: check whether the split on semicolon here and elsewhere should be in ProcessSchedulesDirect
#split on semicolon, there will only be one episode looked up.
EpisodeSubtitle="$(echo $InputSubtitle | sed 's/;.*//')"
#Only keep Alpha-numeric characters and the four basic punctuation chars & , . -
EpisodeSubtitle="$(sed -r s'/[^[:alnum:]|^&,.-]/ /'g <<< "$EpisodeSubtitle")"
ExtensionPrep="$(basename "$InputPath")"
OriginalExt="${ExtensionPrep#*.}"
originaldirname="$(dirname "$InputPath")"
#Set originaldir name if none was supplied
[["$originaldirname" = "./" || "$originaldirname" = "." || "$originaldirname" = "" ]] && originaldirname="$(pwd)"
#TODO: check FileBaseName as the below doesn't strip the suffix but the description of this variable implies that it should. 
FileBaseName="${InputPath##*/}"
FileName="$InputPath"

#Check for show Title translations relating to the show in question.
ShowTranslations
#Do not process files in files categoricIgnore or titleIgnore, just exit
ignoreList
SafeShowName=$(echo "$ShowName" | sed 's/;.*//')
#Only keep Alpha-numeric characters and the four basic punctuation chars & , . -
SafeShowName="$(sed -r s'/[^[:alnum:]|^&,.-]/ /'g <<< "$SafeShowName")"
#Format Show name for Sending to www.TheTVDB.com and KODI
tvdbshowname=$(echo "$ShowName" | sed s/" "/"%20"/g | sed s/"&"/"%26"/g)
#Setup paths if TargetPathIsInputPath is active.
test "$TargetPathIsInputPath" = "Enabled" && setTargetFolderAsInputPathFolder

#####MAINTENANCE#####
#Loop through the list of created comskip files from dir.tracking, created.tracking and remove orphans.
if [ "$m2kScanMode" != "True" ] ; then
  DoMaintenance
else
  Debug "Skipping DoMaintenance() as m2kScanMode has been set to 'True'"
fi

#####SEARCH FOR SHOW AND BUILD INFORMATION#####

#Process as though it's an episode of a tv series.
if [ "$m2kProgramIDCheck" != "SH" ] && [ "$m2kProgramIDCheck" != "MV" ]; then
  #Query TheTVDB on show title, then return a list of Zap2itID, ShowName and seriesid.
  searchTheTVDBAndReturnTxtFileTables

  #TODO: This would be better if it could be [ "$GuideDataType" = "SchedulesDirect" ]
  #  Figure out if that's ok with respect to NoLookUp...
  if [ "$GuideDataType" != "SydFTA" ] ; then
    ConfidenceReasoning="$ConfidenceReasoning Attempted Match On Zap2itID:"
    GetSeriesLineNumberFromTableWithZap2itID
    if [ $? = 0 ]; then
      ((++SeriesConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Successful;"
      Inform "MATCH FOUND BASED ON Zap2itID:$NewShowName"
    else
      ((--SeriesConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Failed;"
    fi
  fi

  #If the previous if block was skipped or failed to find the SeriesLineNumber
  if [ $SeriesConfidenceRating -le 0 ] ; then
    ConfidenceReasoning="$ConfidenceReasoning Attempted match on Standard Logic:"
    GetSeriesLineNumberFromTableWithStandardLogic
    if [ $? = 0 ]; then
      ConfidenceReasoning="$ConfidenceReasoning Successful;"
    else
      Warn "FAILED to get series line number from table with standard logic, requiring doover."
      RequiresDoover=1
      ((--SeriesConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Failed; Attempted Title match on Fuzzy Logic:"
      GetSeriesLineNumberFromTableWithFuzzyLogic
      if [ $? = 0 ]; then
        ConfidenceReasoning="$ConfidenceReasoning Successful;"
      else
        ((--SeriesConfidenceRating))
        ConfidenceReasoning="$ConfidenceReasoning Failed; Information not obtainable;"
        MythicalEpiShow=1
      fi
    fi
  fi

  #if we have a series line number then translate that into a series id
  if [[ -n "$serieslinenumber" ]] && ((serieslinenumber > 0)); then
    setSeriesIDandNewShowNameBasedOnSeriesLineNumber
    Inform "FOUND:$NewShowName ID#:$SeriesID WITH CONFIDENCE:$SeriesConfidenceRating"
  else
    Warn "SERIESID COULD NOT BE DETERMINED"
  fi
fi

#If it's not a recognized episode, then we need to assign the name myth2kodi will use.
test -z "$ShowName" && ShowName="$InputTitle"
test -z "$NewShowName" && NewShowName="$ShowName"

if [[ -n "$SeriesID" ]]; then
  makeShowDirIfNeeded

  #If database is out of date, download new database
  #TODO: Without internet connection, this fails to run properly even when local
  #  information should be sufficient to properly name episode. Add a flag for
  #  Series that have finished, so we don't keep updating for TV Series that
  #  that finished years ago -- see the Status field for the series in the
  #  ShowName.xml in the $m2kdir dir. Also enable using existing data if update fails.
  determineIfDatabaseIsUpToDate
  if [[ $? != 0 ]]; then
    downloadInfoAboutMatchedTitleAndCreateTxtFileTables
    if [[ $? != 0 ]]; then
      Warn "COULD NOT DOWNLOAD UP-TO-DATE INFORMATION FROM TheTVDB! requiring doover."
      RequiresDoover=1
    fi
  fi
#if series id is not obtained send failure message
elif [ -z "$SeriesID" ] && [ "$m2kProgramIDCheck" != "SH" ] && [ "$m2kProgramIDCheck" != "MV" ]; then
  ConfidenceReasoning="$ConfidenceReasoning Failed; "
  Warn "SERIES ID WAS NOT FOUND. TheTVDB MAY BE DOWN. IF NOT TRY USING A showTranslations FILE."
  printf '%s\n' "$InputTitle" >> "$UnrecognizedSeriesFile"
  if [ "$Database" = "Enabled" ]; then
    WarnCont "RECSTART:$ShowStartTime-"
    WarnCont "Movie Air Date:$MovieAirDate-"
    WarnCont "Original Air Date:$OriginalAirDate-"
    WarnCont "Channel ID:$ChanID-"
    WarnCont "Show Category:$ShowCategory-"
    [[ -z "${Exx:2:1}" ]] && Exx=''
  fi
fi

#TODO: Assuming we have identified the Series, but have no Subtitle, try NLP match $Plot against possible plots to guess a subtitle

#####PROCESS EPISODE INFORMATION#####
#If we have a SeriesID but don't already have Season and Episode information
if [[ -n "$SeriesID" ]]; then
  Inform "SEARCHING: www.TheTVDB.com information for EPISODE: $EpisodeSubtitle"
  #####GET ABSOLUTE EPISODE NUMBER#####
  if [ "$GuideDataType" = "SchedulesDirect" ] ; then
    ConfidenceReasoning="$ConfidenceReasoning Attempted match on OriginalAirDate:"
    getAbsoluteEpisodeNumberWithOriginalAirdate
    AirdateExitStatus=$?
    [[ "$AirdateExitStatus" = "1" && -n "$EpisodeSubtitle" ]] && ResolveMultipleAirdateMatches
    test "$?" = "0" && AirdateExitStatus=0
    if [ "$AirdateExitStatus" = "0" ]; then
      ((++EpisodeConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Successful; "
      GotEpisodeNumber=1
    else
      Warn "AIRDATE FAILED. TITLE MATCH ON ABSOLUTE EPISODE NUMBER: $AbsoluteEpisodeNumber"
      ((--EpisodeConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Failed;"
    fi
  fi

  if ((GotEpisodeNumber != 1)) && [[ -n "$EpisodeSubtitle" ]]; then
    ConfidenceReasoning="$ConfidenceReasoning  Attempted SubTitle match on Standard logic:"
    getAbsoluteEpisodeNumberWithStandardLogic
    if [ "$?" = "0" ]; then
      ConfidenceReasoning="$ConfidenceReasoning Successful; "
    else
      Warn "AIRDATE/STANDARD LOGIC FAILED. FUZZY LOGIC ABSOLUTE: $AbsoluteEpisodeNumber. Requiring doover."
      RequiresDoover=1
      ((--EpisodeConfidenceRating))
      ConfidenceReasoning="$ConfidenceReasoning Failed; Attempted SubTitle match on Fuzzy logic:"
      getAbsoluteEpisodeNumberWithFuzzyLogic
      if [ "$?" = "0" ]; then
        ConfidenceReasoning="$ConfidenceReasoning Successful; "
      else
        MythicalEpiShow=1
        ((--EpisodeConfidenceRating))
        ConfidenceReasoning="$ConfidenceReasoning Failed;"
      fi
    fi
  fi

  #update confidence total
  let ConfidenceRating=EpisodeConfidenceRating+SeriesConfidenceRating

  #Verification only makes sense if we got AbsoluteEpisodeNumber from a method
  # other than Standard or Fuzzy logic above.
  if ((GotEpisodeNumber == 1)) && [[ -n "$AbsoluteEpisodeNumber" ]]; then
    #####VERIFICATION OF CONFIDENCE RATING#####
    #backup AbsoluteEpisodeNumber for tests
    AbsoluteEpisodeNumberBackup="$AbsoluteEpisodeNumber"
    if [[ -n "$InputSubtitle" && -n "$OriginalAirDate" ]]; then
      #Verify with Standard logic
      getAbsoluteEpisodeNumberWithStandardLogic
      if [ "$AbsoluteEpisodeNumber" != "$AbsoluteEpisodeNumberBackup" ]; then
        StandardLogicDoesNotJiveMessage
        [[ -z "$AbsoluteEpisodeNumber" ]] && AbsoluteEpisodeNumber="Nothing"
        ConfidenceReasoning="$ConfidenceReasoning Standard Logic came up with Episode Number $AbsoluteEpisodeNumber. This does not match $AbsoluteEpisodeNumberBackup;"
      else
        #TODO For shows which are way off, we need some sort of doover mechanism.
        #CONFIDENCE:2 LOGIC PATH:  Attempted Match On Zap2itID: Successful; Attempted match on OriginalAirDate: Successful;
        #Standard Logic came up with line 76. This does not match 85; Fuzzy Logic test came up with line 76. This does not match 85;
        #JOB: myth2kodi '/home/mythtv/Videos/1035_20101109001500.mpg' 'Aqua Teen Hunger Force' 'Couple Skate'
        #TARGET SET:/home/mythtv/Videos/Episodes/Aqua Teen Hunger Force/Season 6/Aqua Teen Hunger Force S06E03 (She Creature).mpg
        updateRunningFuzzyLogicErrorCount
        ConfidenceReasoning="$ConfidenceReasoning Verified with Standard logic;"
        (( ++ConfidenceRating ))
      fi

      #Verify with Fuzzy
      getAbsoluteEpisodeNumberWithFuzzyLogic
      if [ "$AbsoluteEpisodeNumber" != "$AbsoluteEpisodeNumberBackup" ]; then
        [[ -z "$AbsoluteEpisodeNumber" ]] && AbsoluteEpisodeNumber="Nothing"
        ConfidenceReasoning="$ConfidenceReasoning Fuzzy Logic test came up with Episode Number $AbsoluteEpisodeNumber. This does not match $AbsoluteEpisodeNumberBackup;"
        FuzzyLogicDoesNotJiveMessage
      else
        updateRunningFuzzyLogicErrorCount
        ConfidenceReasoning="$ConfidenceReasoning Verified with Fuzzy logic;"
        (( ++ConfidenceRating ))
      fi
    fi
    #Restore AbsoluteEpisodeNumber after testing
    AbsoluteEpisodeNumber="$AbsoluteEpisodeNumberBackup"
  fi

  #Statistical Fuzzy Logic monitoring
  updateRunningTotalMatchesCount
  Inform "TOTAL FUZZY LOGIC MATCHES:$FuzzyLogicMatches"
  #TODO: Consider repositioning this Inform, also look into updateRunningFuzzyLogicErrorCount usage... Maybe use $FuzzyLogicError here.
  Inform "TOTAL VERIFIED FUZZY ERRORS:$(test -f "$m2kdir"/FuzzyLogicError.log && cat "$m2kdir"/FuzzyLogicError.log || echo "0")"
fi

#TODO: The following few blocks will run even if we haven't properly identified the series, which doesn't make
#      sense for the things trying to set SxxExx...

#If we already have Sxx and Exx from MythTV DB, use them. If we also had a Subtitle, then do some verification.
if [[ "$Sxx" != "S" && -n "$Sxx" && "$Sxx" != "S00" && "$Exx" != "E" && -n "$Exx" && "$Exx" != "E00" ]] ; then
  #TODO: If the confidence rating from the above is good, and we have an
  #  AbsoluteEpisodeNumber then use it to validate the Sxx, Exx & Subtitle from
  #  the MythTV DB.
  Inform "Using episode number: $Sxx$Exx, extracted from the MythTV DB."
  #TODO: Probably should only do the following if the Series confidence rating
  #  is ok.
  #If we don't have a Subtitle, then use Sxx & Exx to get it from the TVDb info.
  if [[ -z "$EpisodeSubtitle" ]]; then
    AbsoluteEpisodeNumberBackup=$AbsoluteEpisodeNumber
    getAbsoluteEpisodeNumberWithSxxExx
    if [ "$?" = "0" ]; then
      EpisodeSubtitle=$(sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir"/"$NewShowName"/"$NewShowName".actualEname.txt)
      Inform "MythTV DB didn't have an EpisodeSubtitle, using '$EpisodeSubtitle' from TheTVDB."
    else
      AbsoluteEpisodeNumber=$AbsoluteEpisodeNumberBackup
    fi
  fi
  #Strip the leading "S" from Sxx,
  SeasonNumber=${Sxx#S}
  #and any leading "0"
  SeasonNumber=${SeasonNumber#0}

#If we don't already have EXX and SXX, set them by matching Absolute Episode Number across myth2kodi's database
elif [[ -n "$AbsoluteEpisodeNumber" ]]; then
  #NOTE: this function also sets EpisodeSubtitle and SeasonNumber
  setSxxAndExxFromAbsoluteEpisodeNumber
else
  Warn "Couldn't set Sxx and Exx from MythTV-DB or set them based on InputSubtitle."
  ConfidenceReasoning="$ConfidenceReasoning Could not get Sxx and Exx from MythTV-DB or set them based on InputSubtitle; "
fi

#If it's not tagged as a Movie but lacking SxxExx and then as a fallback check storagegroup in case it's a Movie we missed
if [ "$StorageGroupFallback" = "Enabled" ] ; then
  Debug "StorageGroupFallback is Enabled"
  #TODO: Make a HasSxxExx variable that is set and used consistently, #NOTE: there is already one but it's weirdly used
  if [ "$m2kProgramIDCheck" != "MV" ] && [[ "$Sxx" = "S" || -z "$Sxx" || "$Sxx" = "S00" || "$Exx" = "E" || -z "$Exx" || "$Exx" = "E00" ]] ; then
    if grep -iq '\(Movies*\|Films*\)' <<< "$StorageGroup" ; then
      Inform "GUESSING that this is a Movie based on being in storagegroup: $StorageGroup"
      m2kProgramIDCheck="MV"
      ProgramIDType="Movie"
      ((--ConfidenceRating)) #Decrement confidence, because this is a guess.
      ConfidenceReasoning="$ConfidenceReasoning Possible misidentified Movie, overriding Guide Data, Guess; "
    fi
  fi
fi

#TODO: Need to add checks for existence of myth2kodi database files for $NewShowName and/or check that we've identified the series before bothering with the following 

#TODO: If this works reliably, then consider moving it up to directly below fuzzy match on subtitle
#As a last resort, if we still think it's an episode but have no episode info, try fuzzy match on plot
if [ "$PlotMatchFallback" = "Enabled" ] ; then
  Debug "PlotMatchFallback is Enabled"
  if [ "$m2kProgramIDCheck" = "EP" ] && [[ "$Sxx" = "S" || -z "$Sxx" || "$Sxx" = "S00" || "$Exx" = "E" || -z "$Exx" || "$Exx" = "E00" ]] ; then
    getAbsoluteEpisodeNumberWithFuzzyPlotMatch
    if [[ "$?" = "0" && -n "$AbsoluteEpisodeNumber" ]]; then
      Inform "Setting Sxx, Exx, and EpisodeSubtitle based on FuzzyPlotMatch:"
      #NOTE: setSxxAndExxFromAbsoluteEpisodeNumber also sets EpisodeSubtitle and SeasonNumber
      setSxxAndExxFromAbsoluteEpisodeNumber
      ((--ConfidenceRating)) #Decrement confidence, because this is a guess.
      ConfidenceReasoning="$ConfidenceReasoning Found AbsoluteEpisodeNumber with fuzzy plot match, Guess; "
    else
      Err "Failed in last ditch attempt to identify episode with fuzzy plot match, we have no SxxExx."
      #TODO: Probably should exit here...
    fi
  fi
fi


#######SANITY CHECKS#####

if [ "$m2kProgramIDCheck" = "EP" ] && [[ "$Exx" = "E" || -z "$Exx" ]]; then
  ConfidenceReasoning="$ConfidenceReasoning Guide Data did not match a specific Episode;"
  MythicalEpiShow=1
  Warn "Identified recording as episode but failed to determine episode number, requiring doover."
  RequiresDoover=1
  #TODO come up with a way to have a variable like DataWasNotObtainable to check and make it a SH later

#If it's a movie or a showing, give it a name.
#TODO: If it's a movie, try using imdb or similar with available $Plot to determine if the Title is correct...
elif [ "$m2kProgramIDCheck" = "MV" ] || [ "$m2kProgramIDCheck" = "SH" ] ; then
  NewShowName="$InputTitle"
  ConfidenceReasoning="$ConfidenceReasoning Guide Data reported this is a $ProgramIDType;"
fi

#if the confidence was low, then show requires a doover
((ConfidenceRating <= -4)) && RequiresDoover=1 && Warn "ConfidenceRating low. Requiring doover."

#If file is a link then activate link mode so the original link is not screwed up.
if [ -L "$InputPath" ]; then
  Warn "FILE IS A LINK FORCING SYMLINK LINK MODE"
  SYMLINK=LINK
fi

#If user wants database data deleted, then we will do that if the match was a good confidence level
[[ "$SYMLINK" = "Disabled" ]] && ((ConfidenceRating > -4)) && RequiresDoover=0

#####INVALID FILE HANDLING####
#If file to be moved does not exist, then report
if [ ! -f "$InputPath" ] && [ "$InputPath" != "testfile.ext" ]; then
  InvalidFileErrorMessage
  if [ "$Notify" = "Enabled" ]; then
    sudo -u "$NotifyUserName" "$binpath"/m2k_notify "myth2kodi Error" "Invalid File supplied" error
  fi
  ExitJob 'InvalidFileNameSupplied'
fi

##TEST FILESYSTEM##
#Get file size and free space
[[ -f "$InputPath" ]] && MoveFileSize=$(wc --bytes < "$InputPath") || MoveFileSize=0
MoveFileSize=$((MoveFileSize/1024))
MoveDirFreeSpace=$(df -P "$MoveDir" | sed -n 2p | awk '{print $4}') || MoveDirFreeSpace=0
AlternateMoveDirFreeSpace=$(df -P "$AlternateMoveDir" | sed -n 2p | awk '{print $4}')|| AlternateMoveDirFreeSpace=0
if [ "$Database" = "Enabled" ]; then
  PrimaryMovieDirFreeSpace=$(df -P "$PrimaryMovieDir" | sed -n 2p | awk '{print $4}') || PrimaryMovieDirFreeSpace=0
  AlternateMovieDirFreeSpace=$(df -P "$AlternateMovieDir" | sed -n 2p | awk '{print $4}')|| AlternateMovieDirFreeSpace=0
  PrimaryShowDirFreeSpace=$(df -P "$PrimaryShowDir" | sed -n 2p | awk '{print $4}')|| PrimaryShowDirFreeSpace=0
  AlternateShowDirFreeSpace=$(df -P "$AlternateShowDir" | sed -n 2p | awk '{print $4}')|| AlternateShowDirFreeSpace=0
fi
#Call permissions check from function.  Write small file, delete, get results
checkPermissions "$MoveFileSize" "$MoveDirFreeSpace" "$MoveDir"
MoveDirWritable=$TMoveDirWritable
checkPermissions "$MoveFileSize" "$AlternateMoveDirFreeSpace" "$AlternateMoveDir"
AlternateMoveDirWritable=$TMoveDirWritable
if [ "$Database" = "Enabled" ]; then
  checkPermissions "$MoveFileSize" "$PrimaryMovieDirFreeSpace" "$PrimaryMovieDir"
  PrimaryMovieDirWritable=$TMoveDirWritable
  checkPermissions "$MoveFileSize" "$AlternateMovieDirFreeSpace" "$AlternateMovieDir"
  AlternateMovieDirWritable=$TMoveDirWritable
  checkPermissions "$MoveFileSize" "$PrimaryShowDirFreeSpace" "$PrimaryShowDir"
  PrimaryShowDirWritable=$TMoveDirWritable
  checkPermissions "$MoveFileSize" "$AlternateShowDirFreeSpace" "$AlternateShowDir"
  AlternateShowDirWritable=$TMoveDirWritable
fi
OriginaldirFreeSpace=$(df -P "$originaldirname" | sed -n 2p | awk '{print $4}')
WorkingDirFreeSpace=$(df -P "$m2kdir" | sed -n 2p | awk '{print $4}')
checkPermissions "1" "$OriginaldirFreeSpace" "$originaldirname"
OriginalDirWritable=$TMoveDirWritable
checkPermissions "5000" "$WorkingDirFreeSpace" "$m2kdir"
WorkingDirWritable=$TMoveDirWritable

#Report naming decisions
Inform "CONFIDENCE:$ConfidenceRating LOGIC PATH: $ConfidenceReasoning"

OperationSummary

######PRE-NAMING CHECKS#####
#if no episode data and it's not a movie or a test
if [[ -z "$Exx" && "$InputPath" != "testfile.ext" ]]; then
  if [[ -z "$ChanID" && -n "$InputPath" ]]; then #TODO: check this...
    Warn "This episode could not be matched based on supplied Title and SubTitle."
    ExitJob 'NameCouldNotBeAssigned'
  elif [ "$m2kProgramIDCheck" = "MV" ]; then
    #Ensures the doover value was not set for the movie and use safe show name
    RequiresDoover=0
    NewShowName="$SafeShowName"
  #If user has determined that they do not want unrecognisable tv shows in their library
  elif [ "$ShowStopper" = "Enabled" ]; then
    tvDbIsIncomplete
    writeJobToDooverQue "$1" "$2" "$3"
    ExitJob 'NameCouldNotBeAssigned'
  elif [ "$m2kProgramIDCheck" = "SH" ]; then
    #Ensures the doover value was not set for the show and use safe show name
    NewShowName="$SafeShowName"
    DisplayShowWarning
  else
    #This marks Episodes as shows. AKA EpiShows. Episodes for which no information can currently be obtained.
    MythicalEpiShow=1
    #change the show to a Generic type
    NewShowName="$SafeShowName"
    DisplayEpiShowMessage
  fi
fi

#Figure out if the file can go in the MoveDir, or if the alternate should be used
determinePrimaryOrAlternateFolderUsage

#####OUTPUT FILE NAME FORMATTING#####
#Format Shows
#Only keep Alpha-numeric characters and the four basic punctuation chars & , . -
EpisodeSubtitle="$(sed -r s'/[^[:alnum:]|^&,.-]/ /'g <<< "$EpisodeSubtitle")"
NewShowName="$(sed -r s'/[^[:alnum:]|^&,.-]/ /'g <<< "$NewShowName")"
ShowName="$(sed -r s'/[^[:alnum:]|^&,.-]/ /'g <<< "$ShowName")"

#Format Episodes showname=show name Sxx=season number Exx=episode number EpisodeSubtitle=episode name
if [[ -z "$NamingConvention" ]]; then
  TraditionalNamingConventions
else
  [[ -z "$NewShowName" ]] && NewShowName="$ShowName"
  CategoricNamingConventions
fi

#### MAKE THE DIRECTORY WE'LL MOVE THE RECORDING TO ####
MakeShowDir

#####FAILSAFE HANDLING#####
#TODO: Review the "FailSafe" handling throughout the script.
#If failsafe state is set then create link in FailSafeMode
if [ "$FailSafeState" = "1" ]; then
  #doFailSafeMode activates MoveDir = failsafe dir and link mode is used
  doFailSafeMode
  #--doover will reprocess the show
  writeJobToDooverQue "$1" "$2" "$3"
  ExitJob 'FailSafeModeComplete'
fi

#####ANTI-CLOBBER#####
#TODO: IF WE'RE MAKING THE MISTAKE OF MOVING A RECORDING THAT WE'VE ALREADY MOVED, OR
#    IF WE'VE IDENTIFIED A DIFFERENT SHOW AS THE SAME SHOW THEN SENSIBLE BEHAVIOUR 
#    IS TO REPORT A DETAILED ERROR MESSAGE AND DO NOTHING!!! 
if [ -f "$MoveDir/$ShowFileName.$OriginalExt" ]; then
  Err "FILE NAME ALREADY EXISTS:"
  ErrCont "$MoveDir/$ShowFileName.$OriginalExt"
  ErrCont "CALLED AS: myth2kodi '$1' '$2' '$3' '$4'"
  ErrCont "InputTitle: $InputTitle"
  ErrCont "InputSubtitle: $InputSubtitle"
  ErrCont "Plot: $Plot"
  ErrCont "WE'VE EITHER ALREADY PROCESSED THIS RECORDING OR OUR FILE NAME GENERATION IS TOO GENERIC."
  ErrCont "EITHER WAY, ABORTING."
  #Write an entry in the duplicates file, for easy check/removal of duplicates.
  printf "'%s' '%s' '%s' '%s'\n" "$InputTitle" "$ShowStartTime" "$InputPath" "$ShowFileName" >> "$DuplicatesFile"
  ExitJob 'FileAlreadyExists'
  #TODO: When refactoring main, consider allowing forced move with auto name incrementing when move-to file already exists.
  #If file exists then make a new name for it
  # myth2kodiCounter=0
  # NameCheck=0
  # while [ $NameCheck = '0' ]; do
  #   #TODO: Sublime text syntax highlighting fails here, the different coloured 2 in
  #   #  the variable name below isn't actually a problem, fix the syntax highlighting.
  #   ((++myth2kodiCounter))

  #   #If file does not exist, then it is a valid target
  #   if [ ! -e "$MoveDir/$ShowFileName-$myth2kodiCounter.$OriginalExt" ]; then
  #     NameCheck="1"
  #     ShowFileName=$(echo "$ShowFileName"-"$myth2kodiCounter")
  #     Warn "FILE NAME EXISTS.  FILE WILL BE KNOWN AS: $ShowFileName"
  #   fi
  # done
fi

#If this is a test file, then exit now.
[[ "$InputPath" = "testfile.ext" && "$Exx" != "E07" ]] && Err 'FUZZY FAILURE' && exit 1
test "$InputPath" = "testfile.ext" && DoTestFileExit

#If the user is not mythtv and the settings are set for mythtv only, then exit, display a clear status message.
DoMythTVPermissionsCheck

#If the show is generic programming, this is the best myth2kodi can do.
test  "$m2kProgramIDCheck" = "SH" && DisplayShowWarning

#####MOVE MODE HANDLING#####
#If symlink is not in LINK mode, Move and rename the file.
if [ "$SYMLINK" != "LINK" ]; then
  #Send notifications, Move the file and rename
  Inform "MOVING FILE: '$InputPath' to '$MoveDir/$ShowFileName.$OriginalExt'"
  test "$Notify" = "Enabled" && sudo -u "$NotifyUserName" "$binpath"/m2k_notify "myth2kodi Moving" "Moving and renaming $ShowFileName" drive-harddisk
  mv "$InputPath" "$MoveDir/$ShowFileName.$OriginalExt"

  #Check and report if file was moved
  if [ -e "$MoveDir/$ShowFileName.$OriginalExt" ]; then
    if [ -f "$MoveDir/$ShowFileName.$OriginalExt" ]; then
      #Create Commercial skip data with file
      if [ "$CommercialMarkup" = "Created" ]; then
        mv "$m2kdir/markupframes.txt" "$MoveDir/$ShowFileName.txt"
        echo "'$MoveDir/$ShowFileName.txt'" "'$MoveDir/$ShowFileName.$OriginalExt'">>"$m2kdir"/created.tracking
      fi
      #Make symlink back to original file
      if [ "$SYMLINK" = "MOVE" ]; then
        Inform "CREATING SYMLINK IN MOVE MODE"
        ln -s  "$MoveDir/$ShowFileName.$OriginalExt" "$InputPath"
        test ! -L "$InputPath" && Err "ERROR CREATING SYMLINK: FILESYSTEM MAY NOT SUPPORT SYMLINKS"
      fi
      DisplayCompletedMoveMessage

      #If SYMLINK=Disabled, remove database entries
      if [ "$SYMLINK" = "Disabled" ]; then
        chmod 775 "$MoveDir/$ShowFileName.$OriginalExt"
        if [ "$RequiresDoover" != "1" ]; then
          DeleteRelevantDatabaseFilesAndPictures
        else
          Inform "CREATING SYMLINK IN SYMLINK=DISABLED MODE"
          ln -s  "$MoveDir/$ShowFileName.$OriginalExt" "$InputPath"
          test ! -L "$InputPath" && Err "ERROR CREATING SYMLINK: FILESYSTEM MAY NOT SUPPORT SYMLINKS"
        fi
      fi

      #Send notification of completion
      test "$Notify" = "Enabled" && sudo -u "$NotifyUserName" "$binpath"/m2k_notify "myth2kodi Success" "$ShowFileName moved to $MoveDir" info

      #Additional features, notifications, rss, daily report.
      if [ "$RequiresNFO" = "1" ]; then
        GenerateTVShowNFO
        GenerateEpisodeNFO
      fi
      KODIAutomate
      performLoggingForMoveMode
      dailyreport
      generaterss
      test "$SYMLINK" = "Disabled" && setGroupPermissions
      ExitJob 'MoveModeSuccessful'

    #if file was not moved, then fail
    elif [ ! -s "$MoveDir/$ShowFileName.$OriginalExt" ]; then
      rm -f "$MoveDir/$ShowFileName.$OriginalExt"
      writeJobToDooverQue "$1" "$2" "$3"
      Wrote0LengthFile
      ExitJob 'PermissionError0Length'

    fi
  elif [ ! -f "$MoveDir/$ShowFileName.$OriginalExt" ]; then
    writeJobToDooverQue "$1" "$2" "$3"
    PermissionErrorWhileMoving
    ExitJob 'PermissionErrorWhileMoving'
  fi

#####LINK MODE HANDLING#####
#If symlink is in LINK mode then create symlink
elif [ "$SYMLINK" = "LINK" ]; then
  Inform "CREATING LINK IN LINK MODE WITH CONFIDENCE:$ConfidenceRating"

  ln -s "$InputPath" "$MoveDir/$ShowFileName.$OriginalExt"

  #if file was created
  if [ -L "$MoveDir/$ShowFileName.$OriginalExt" ]; then
    Inform "Symlink created $MoveDir/$ShowFileName.$OriginalExt"
    echo "@@@@@@@@ OPERATION COMPLETE $(date) @@@@@@@@" >> "$LogFile"
    if [ "$Notify" = "Enabled" ]; then
      sudo -u "$NotifyUserName" "$binpath"/m2k_notify "myth2kodi Success" "$ShowFileName linked to $MoveDir" info
    fi

    #Move comskip data to proper folder
    if [ "$CommercialMarkup" = "Created" ]; then
      mv "$m2kdir"/markupframes.txt "$MoveDir/$ShowFileName.txt"
      echo "$MoveDir/$ShowFileName.txt" >> "$m2kdir"/created.tracking
    fi

    #Additional features, notifications, rss, daily report.
    if [ "$RequiresNFO" = "1" ]; then
      GenerateTVShowNFO
      GenerateEpisodeNFO
    fi
    KODIAutomate
    performLoggingForLinkMode
    dailyreport
    generaterss
    test "$SYMLINK" = "Disabled" && setGroupPermissions
    ExitJob 'LinkModeSuccessful'

  #If link failure, send notification and fail
  elif [ ! -L "$MoveDir/$ShowFileName.$OriginalExt" ]; then
    SymlinkNotCreated
    writeJobToDooverQue "$1" "$2" "$3"

  fi
  ExitJob 'LinkModeFailed'

fi

#####GENERIC UNSPECIFIED ERROR#####
#if no match is found then send error messages
[[ -z "$Exx" ]] &&  genericUnspecifiedError

#send notification if enabled
if [ "$Notify" = "Enabled" ] ; then
  sudo -u "$NotifyUserName" "$binpath"/m2k_notify "myth2kodi error" "myth2kodi operation failed See $LogFile for more information" error
fi
writeJobToDooverQue "$1" "$2" "$3"
ExitJob 'GenericUnspecifiedError'

Err "The ExitJob function must be broken for you to see this message..."
exit 4
