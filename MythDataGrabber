#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""
MythDataGrabber is designed to pull data from MythTV python bindings.

  MythDataGrabber utilizes mythtv python bindings to obtain information about
  a recording and can write the information to a file or stdout.

  Written by Mike Szczys and Adam Outler.

  For support, please visit: http://forum.xbmc.org/showthread.php?t=65644
  This file was written for the mythicalLibrarian project, and is licensed
  under the Apache License, which requires a notification to
  outleradam (at) hotmail.com as a formality before any derrivative work.
  We just want to hear about your project.

USAGE:
  MythDataGrabber [options]

OPTIONS:
   --filename=file.ext : returns information to a file
   --DBHostName        : sets the DB Host, default: localhost
   --DBName            : sets the DB Name, default: mythconverg
   --DBUserName        : sets the User Name, default: mythtv
   --DBPassword        : sets the Password, default: mythtv
   --SecurityPin       : sets the Pin, default: 0
   --writeFile         : don't display output, write to output file.
   --output=file.txt   : sets the output, default: ~/showdata.txt
   --version|-v|-ver   : displays version information

EXAMPLES:
  MythDataGrabber --filename=1000_20101010101010.mpg

  MythDataGrabber --Diagnostic --verbosity=3

  MythDataGrabber --filename=1000_20101010101010.mpg
                  --DBHostName=localhost
                  --DBName=mythconverg
                  --DBUserName=mythtv
                  --DBPassword=mysupersecurenonstandardpassword
                  --writeFile
                  --output=/home/myfile.txt

REQUIRES:
  libmyth-python
  python-lxml

#NOTE: Then a listing of people to blame, the below form won't show up in docs.
.. moduleauthor:: Stuart Knock <>
.. moduleauthor:: Mike Szczys <>
.. moduleauthor:: Adam Outler <outleradam (at) hotmail.com>
"""

__version__ = '0.1.0'

# First, import from python standard library
import logging
logging.basicConfig(level=logging.DEBUG)
LOG = logging.getLogger(__name__)
import sys
import os

# Then, try importing less reliable packages
try:
    from MythTV import MythDB
except ImportError:
    LOG.error("Failed to import MythTV.MythDB...")
    raise ImportError
###########################################################################


def readMysqlTxt():
    """Read database settings from ~/.mythtv/mysql.txt
    Function: readMysqlTxt
    Arguments: None
    Returns: extracted login information
    """
    LOG.debug("Calling readMysqlTxt()")

    mysqlTXT = os.path.expanduser('~') + "/.mythtv/mysql.txt"

    dbdata = {}
    for line in open(mysqlTXT, 'r'):
        if line.startswith('#'):
            continue
        if '=' in line:
            o, v = line.strip().split('=')
            dbdata[o.strip()] = v.strip()
    return dbdata
###########################################################################


def writeData():
    """
    Function: writeData
    Arguments: None
    Returns: extracted login information
    """
    LOG.debug("Calling writeData()")
    # loop through Recorded items
    for x in rec.items():
        #filter out unicode strings:
        if type(x[1]) == str:
            f.write('%s = "%s"\n' % (x[0], x[1].encode('utf-8')))
        else:
            f.write('%s = "%s"\n' % x)

    # loop through comm-start points
    for i, data in enumerate(markupstart):
        f.write('startdata[%s] = "%s"\n' % (i, data))

    # loop through comm-end points
    for i, data in enumerate(markupstop):
        f.write('stopdata[%s] = "%s"\n' % (i, data))

    # grab guide data provider
    with db as cursor:
        # set cursor on xmltvgrabber
        cursor.execute("SELECT xmltvgrabber FROM videosource")
        # pull the data
        res = cursor.fetchone()
        # write the data if any
        if res is not None:
            f.write('xmltvgrabber = "%s"\n' % res[0].strip())
    # verify valid data was written
    if rec.chanid != '':
        LOG.info("Operation complete")
###########################################################################


def closefile():
    """If we have an open file, close it."""
    LOG.info("Closing out the file/stdout")
    if f is not None:
        if f.fileno() != 1:
            f.close()
###########################################################################


if __name__ == "__main__":

    import argparse
    parser = argparse.ArgumentParser(
        description="Pull data from MythTV-DB via python bindings.")
    group = parser.add_mutually_exclusive_group(required=True)
    #Diagnostic arg
    group.add_argument('--Diagnostic',
        action='store_true',
        default='False',
        help="Displays diagnostic information.")
    #File arg
    group.add_argument('-f', '--filename',
        help="Name of the recording file you want information about.")
    #writeFile arg
    parser.add_argument('--writeFile',
        action='store_true',
        default='False',
        help="Use this flag to write data to the file specified by --output.")
    #Output file arg
    parser.add_argument('-o', '--output',
        type=argparse.FileType('w'),
        default=os.path.expanduser('~') + "/showdata.txt",
        help="Use this argument to override default output file. NB. You must also set --writeFile.")
    #DBHostName arg
    parser.add_argument('--DBHostName',
        default="localhost",
        help="Sets the DB Host")
    #DBName arg
    parser.add_argument('--DBName',
        default="mythconverg",
        help="Sets the MythTV-DB Name, default: mythconverg")
    #DBUserName arg
    parser.add_argument('--DBUserName',
        default="mythtv",
        help="Sets the MythTV-DB User Name")
    #DBPassword arg
    parser.add_argument('--DBPassword',
        default="mythtv",
        help="Sets the MythTV-DB Password")
    #SecurityPin arg
    parser.add_argument('--SecurityPin',
        type=int,
        default=0,
        help="Sets the MythTV-DB SecurityPin")
    #version arg
    parser.add_argument('--version',
        action='version',
        version=__version__,
        help="Displays version information")
    #Logging arg
    parser.add_argument("--verbosity",
        type=int,
        choices=[0, 1, 2, 3],
        default=2,
        help="Set the logging verbosity: 0=ERROR; 1=WARNING; 2=INFO; 3=DEBUG.")
    args = parser.parse_args()
    #######################################################################
    #mythdb_arg_dict = dict((k,v) for k,v in vars(args).items() if k not in ("Diagnostic","filename","writeFile","output","version","verbosity"))
    #import pdb; pdb.set_trace()

    #Set the logging level
    loglevelmapping = ["ERROR","WARNING","INFO","DEBUG"]
    LOG.setLevel(loglevelmapping[args.verbosity])

    #Get a connection to the database
    LOG.info("Establishing database connection")
    try:
        # Defaults or args
        db = MythDB(**vars(args))  #mythdb_arg_dict, if MythDB doesn't gracefully handle superfluous kwargs
    except Exception:
        try:
            # mythtv preconfigured options
            LOG.error('Failed: attempting to use system default configuration')
            db = MythDB(SecurityPin=args.SecurityPin)
        except Exception:
            try:
                # read from the mysql.txt
                LOG.error('Failed: attempting to read from default mythtv file')
                db = MythDB(readMysqlTxt(), SecurityPin=args.SecurityPin)
            except Exception:
                LOG.error('Failed: Please specify database information manually')
                LOG.error('See --help for more information.')
                raise Exception
    #######################################################################

    #If requested, run some Diagnostics.
    if args.Diagnostic == True:
        try:
            LOG.info("Connected to: " + db.gethostname())
            LOG.info("Diagnostics passed...")
            #TODO: Consider expanding the diagnostics.

        except Exception:
            LOG.error("Diagnostics failed.")
            raise Exception

        sys.exit(0)
    #######################################################################

    #GatherInformation from the Database
    # search for a recording
    try:
        rec = db.searchRecorded(basename=args.filename).next()
    except StopIteration:
        LOG.error("Failed to find DB record for: " + args.filename)
        raise Exception('Recording Not Found')

    # set comskip data
    try:
        markupstart, markupstop = zip(*rec.markup.getskiplist())
    except Exception:
        LOG.warning("No comskip information found.")
        markupstart, markupstop = '', ''
    #######################################################################

    # Return the data, either to a file or to stdout
    f = None
    if args.writeFile == True:
        LOG.debug("Attempting to write data to file: " + args.output.name)
        try:
            # Write data to file defined by "output" keyword arg.
            f = args.output
            writeData()

        except IOError: #the file failed to write
            LOG.error("Write Failed: " + args.output.name)
            raise IOError

    else:
        LOG.debug("Writing data to standard out (terminal).")
        f = sys.stdout
        writeData()

    closefile()

