#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""
  mythdb_access can be used to access data from a MythTV-DB or to request
  the mythbackend to delete a recording.

  mythdb_access uses the MythTV python bindings to access a MythTV-DB.
  It currently supports: obtaining information about a recording, which
  can be written to a file or stdout; obtaining StorageGroup information
  which is written to stdout; and requesting the mythbackend to delete a
  specified recording. It is part of the myth2kodi project.
    https://github.com/stuart-knock/myth2kodi

  mythdb_access is a derivative of MythDataGrabber.

  MythDataGrabber -- Written by Mike Szczys and Adam Outler.
    https://github.com/adamoutler/mythicallibrarian
    http://forum.xbmc.org/showthread.php?t=65644

  MythDataGrabber was written for the mythicalLibrarian project, and is
  licensed under the Apache License, which requires a notification to
  adamoutler (at) gmail.com as a formality before any derivative work.
  We just want to hear about your project.


USAGE:
  mythdb_access [options]
  See,
  mythdb_access --help

OPTIONS:
   --filename=file.ext : recording to be accessed
   --DBHostName        : sets the DB Host, default: localhost
   --DBName            : sets the DB Name, default: mythconverg
   --DBUserName        : sets the User Name, default: mythtv
   --DBPassword        : sets the Password, default: mythtv
   --SecurityPin       : sets the Pin, default: 0
   --writeFile         : don't display output, write to output file.
   --output=file.txt   : sets the output, default: ~/showdata.txt
   --version           : displays version information
   --verbosity         : Sets the logging level.
   --Diagnostic        : perform some basic diagnostic checks.
   --storagegroups     : write the MythTV-DB StorageGroup info to stdout.
   --delete            : request the mythbackend to delete a recording.
   --force             : force deletion of DB-entry for recording.
   --help              : print a help message (autogenerated by argparse).

EXAMPLES:
  #Write the information for a recording to stdout
  mythdb_access --filename=1000_20101010101010.mpg

  #Perform diagnostics
  mythdb_access --Diagnostic --verbosity=3

  #Write the information for a recording to a file.
  mythdb_access --filename=1000_20101010101010.mpg
                --DBHostName=192.168.1.42
                --DBName=mythconverg
                --DBUserName=mythtv
                --DBPassword=mysupersecurenonstandardpassword
                --writeFile
                --output=/home/myfile.txt

  #Delete a specific recording.
  mythdb_access --filename=1000_20101010101010.mpg
                --writeFile
                --output=/tmp/deleted_recording_info.txt
                --delete

REQUIRES:
  libmyth-python
  python-lxml

#NOTE: A listing of people to blame, the below form won't show up in docs.
.. moduleauthor:: Stuart Knock <>
.. moduleauthor:: Mike Szczys <>
.. moduleauthor:: Adam Outler <adamoutler (at) gmail.com>
"""

__version__ = '0.4.2'

# First, import from python standard library
import logging
logging.basicConfig(level=logging.DEBUG)
LOG = logging.getLogger(__name__)
import sys
import os

# Then, try importing less reliable packages
try:
    from MythTV import MythDB
except ImportError:
    LOG.error("Failed to import MythTV.MythDB...")
    raise
###########################################################################


def read_mysql_text():
    """Read database settings from ~/.mythtv/mysql.txt
    Function: read_mysql_text
    Arguments: None
    Returns: extracted login information
    """
    LOG.debug("Calling read_mysql_text()")

    mysql_text = os.path.expanduser('~') + "/.mythtv/mysql.txt"

    dbdata = {}
    for line in open(mysql_text, 'r'):
        if line.startswith('#'):
            continue
        if '=' in line:
            setting_name, setting_value = line.strip().split('=')
            dbdata[setting_name.strip()] = setting_value.strip()
    return dbdata
###########################################################################


def write_data():
    """
    Function: write_data
    Arguments: None
    Returns: database information for the recording.
    """
    LOG.debug("Calling write_data()")
    # loop through recording information
    for field, value in REC.items():
        #write recording information as unicode strings:
        if isinstance(value, str):
            OUTPUT.write('%s = "%s"\n' % (field, value.encode('utf-8')))
        else:
            OUTPUT.write('%s = "%s"\n' % (field, value))

    # loop through comm-start points
    for i, data in enumerate(MARKUPSTART):
        OUTPUT.write('startdata[%s] = "%s"\n' % (i, data))

    # loop through comm-end points
    for i, data in enumerate(MARKUPSTOP):
        OUTPUT.write('stopdata[%s] = "%s"\n' % (i, data))

    # grab guide data provider
    with DB as cursor:
        # set cursor on xmltvgrabber
        cursor.execute("SELECT xmltvgrabber FROM videosource")
        # pull the data
        res = cursor.fetchone()
        # write the data if any
        if res is not None:
            OUTPUT.write('xmltvgrabber = "%s"\n' % res[0].strip())
    # verify valid data was written
    if REC.chanid != '': #TODO: this is strange to do at the end, and also doesn't test writing but rather that a valid recording was found in the first place.
        LOG.info("Operation complete.")
###########################################################################


def closefile():
    """If we have an open file, close it."""
    LOG.debug("Closing out the file/stdout")
    if OUTPUT is not None:
        if OUTPUT.fileno() != 1:
            OUTPUT.close()
###########################################################################

if __name__ == "__main__":

    import argparse
    PARSER = argparse.ArgumentParser(
        description="Pull data from MythTV-DB via python bindings.")
    GROUP = PARSER.add_mutually_exclusive_group(required=True)
    #Diagnostic arg
    GROUP.add_argument('--Diagnostic',
                       action='store_true',
                       default='False',
                       help="Displays diagnostic information.")
    #Storage group arg
    GROUP.add_argument('--storagegroups',
                       action='store_true',
                       default='False',
                       help="Write MythTV-DB storage-group information to stdout.")
    #File arg
    GROUP.add_argument('-f', '--filename',
                       help="Name of the recording file you want information about.")
    #writeFile arg
    PARSER.add_argument('--writeFile',
                        action='store_true',
                        default='False',
                        help="""Use this flag to write data to the file
                                specified by --output.""")
    #Output file arg
    PARSER.add_argument('-o', '--output',
                        type=argparse.FileType('w'),
                        default=os.path.expanduser('~') + "/showdata.txt",
                        help="""Use this argument to override default output file.
                                NB. You must also set --writeFile.""")
    #delete arg
    PARSER.add_argument('--delete',
                        action='store_true',
                        default='False',
                        help="""Use this flag to delete the recording
                                specified by --filename.""")
    #force arg
    PARSER.add_argument('--force',
                        action='store_true',
                        default='False',
                        help="""Use this flag to force the deletion the DB-entry
                                for the recording even if the associated
                                recording file cannot be found.""")
    #DBHostName arg
    PARSER.add_argument('--DBHostName',
                        default="localhost",
                        help="Sets the DB Host")
    #DBName arg
    PARSER.add_argument('--DBName',
                        default="mythconverg",
                        help="Sets the MythTV-DB Name, default: mythconverg")
    #DBUserName arg
    PARSER.add_argument('--DBUserName',
                        default="mythtv",
                        help="Sets the MythTV-DB User Name")
    #DBPassword arg
    PARSER.add_argument('--DBPassword',
                        default="mythtv",
                        help="Sets the MythTV-DB Password")
    #SecurityPin arg
    PARSER.add_argument('--SecurityPin',
                        type=int,
                        default=0,
                        help="Sets the MythTV-DB SecurityPin")
    #version arg
    PARSER.add_argument('--version',
                        action='version',
                        version=__version__,
                        help="Displays version information")
    #Logging arg
    PARSER.add_argument("--verbosity",
                        type=int,
                        choices=[0, 1, 2, 3],
                        default=2,
                        help="""Set the logging verbosity: 0=ERROR; 1=WARNING;
                                2=INFO; 3=DEBUG.""")
    ARGS = PARSER.parse_args()
    #######################################################################
    #import pdb; pdb.set_trace()

    #Set the logging level
    LOGLEVELMAPPING = ["ERROR", "WARNING", "INFO", "DEBUG"]
    LOG.setLevel(LOGLEVELMAPPING[ARGS.verbosity])

    #Get a connection to the database
    LOG.info("Establishing database connection")
    try:
        # Defaults or ARGS
        DB = MythDB(**vars(ARGS))
    except Exception:
        try:
            # mythtv preconfigured options
            LOG.error('Failed: attempting to use system default configuration')
            DB = MythDB(SecurityPin=ARGS.SecurityPin)
        except Exception:
            try:
                # read from the mysql.txt
                LOG.error('Failed: attempting to read from default mythtv file')
                DB = MythDB(read_mysql_text(), SecurityPin=ARGS.SecurityPin)
            except Exception:
                LOG.error('Failed: Please specify database information manually')
                LOG.error('See --help for more information.')
                raise
    #######################################################################

    #If requested, run some diagnostics.
    if ARGS.Diagnostic is True:
        try:
            LOG.info("Connected to: " + DB.gethostname())
            LOG.info("Identified StorageGroups:")
            for sg in DB.getStorageGroup():
                LOG.info("  %s: %s" % (sg.groupname, sg.dirname))
            LOG.info("Diagnostics passed...")
        except Exception:
            LOG.error("Diagnostics failed.")
            raise

        sys.exit(0)
    #######################################################################

    #If requested, return storage group information.
    if ARGS.storagegroups is True:
        try:
            STORAGE_GROUPS = DB.getStorageGroup()
            OUTPUT = sys.stdout
            for sg in STORAGE_GROUPS:
                sg_dirname = sg.dirname.encode('utf-8')
                LOG.debug("Found StorageGroup: " + sg_dirname.strip())
                OUTPUT.write("%s " % sg_dirname.strip())
        except Exception:
            LOG.error("StorageGroup access failed.")
            raise

        sys.exit(0)
    #######################################################################

    #Gather information from the database for the recording
    try:
        REC = DB.searchRecorded(basename=ARGS.filename).next()
    except StopIteration:
        LOG.error("Failed to find DB record for: " + ARGS.filename)
        raise

    #Set comskip data
    try:
        MARKUPSTART, MARKUPSTOP = zip(*REC.markup.getskiplist())
    except Exception:
        LOG.warning("No comskip information found.")
        MARKUPSTART, MARKUPSTOP = '', ''
    #######################################################################

    # Return the data, either to a file or to stdout
    OUTPUT = None
    if ARGS.writeFile is True:
        LOG.debug("Attempting to write data to file: " + ARGS.output.name)
        try:
            # Write data to file defined by "output" keyword arg.
            OUTPUT = ARGS.output
            write_data()
        except IOError: #the file failed to write
            LOG.error("Write Failed: " + ARGS.output.name)
            raise
    else:
        LOG.debug("Writing data to standard out (terminal).")
        OUTPUT = sys.stdout
        write_data()

    closefile()
    #######################################################################

    # Ask mythbackend to delete the recording, if the --force flag is also
    # set then ask for the DB-entry to be deleted even if the recording file
    # cannot be found.
    if ARGS.delete is True:
        LOG.debug("Deleting recording: " + ARGS.filename)
        REC.delete(force=ARGS.force)
